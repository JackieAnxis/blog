[{"title":"Windows装机指南","url":"/blog/2021/11/15/2021-11-15 Window装机指南/","content":"\n我平时工作因为有多台 Windows 设备，或者之后需要装新的 Windows 设备，常常需要同步多个设备之间的操作习惯（再加上我有一台 mac），故而写一个文档，方便装机同步。\n\n当然大家也可以看一下我的软件列表，有些软件还是可以大大提高效率的。\n\n## 软件\n\n### 基础软件\n\n-   [Google Chrome ](https://www.google.cn/intl/zh-CN/chrome/)：浏览器，上网冲浪必不可少，推荐安装插件详见：[Chrome 配置方案](#Chrome-配置方案)\n-   [7-Zip](https://www.7-zip.org/): 压缩解压缩\n-   [微信](https://weixin.qq.com/)：聊天、沟通、摸鱼\n-   [Snipaste](https://www.snipaste.com/): 截图\n-   [坚果云](https://www.jianguoyun.com/): 文件夹云同步，199 一年\n-   [AutoHotKey](https://www.autohotkey.com/): 热键，其配置详见：[AutoHotKey 配置方案](#AutoHotKey-配置方案)\n\n### 工作相关\n\n-   Microsoft Office：浙大购买了相关的软件许可，具体访问[浙江大学科研软件平台](https://soft.zju.edu.cn/)\n-   Adobe：浙大购买了相关的软件许可，具体访问[浙江大学科研软件平台](https://soft.zju.edu.cn/)\n-   [TeamViewer](https://www.teamviewer.com/) : 远程连接\n-   [Rere](https://rere.appinn.me/) : 休息提醒\n-   [WPS](https://www.wps.cn/)\n-   [Zotero](https://www.zotero.org/): 文献（pdf 电子书）管理器\n    -   为了能够使用坚果云同步，需要配置如下：\n-   [texlive](https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/): Latex 的编译器，想要在 VSCode 上写论文必备\n\n-   [DingTalk](https://www.dingtalk.com/): 工作交流、合作工具\n\n-   [QQ](https://im.qq.com/pcqq/) or [TIM](https://tim.qq.com/): 聊天沟通\n\n### 开发相关\n\n-   [Typora](https://typora.io/) : markdown 编辑器\n-   [Visual Studio Code](https://code.visualstudio.com/): 代码编辑器，详细配置请见下方[VSCode 配置方案](#VSCode-配置方案)\n-   [Cmder](https://cmder.net/): Windows 上的终端行命令工具\n-   [Nodejs](https://nodejs.org/): 一个建立在 Chrome 的 V8 JavaScript 引擎上的服务器端 JavaScript\n-   [Python](https://www.python.org/downloads/windows/)\n-   [Jebrain IDEs](https://www.jetbrains.com/): 编译器，集成开发环境，学生可以免费申请\n-   [Windows Linux Bash Shell](https://docs.microsoft.com/en-us/windows/wsl/install): 方便编译一些 C++库\n\n### 效率/摸鱼工具\n\n-   [Ditto](https://www.microsoft.com/en-us/p/ditto-clipboard/9nblggh3zbjq): 剪贴板历史\n-   [Wox](http://www.wox.one/): Windows 的启动器，类似于 Macbook 的搜索（推荐快捷键：`ctrl`+`space`）\n\n    -   配合[Everything](https://voidtools.com/) (用于搜索文件) 使用更加\n\n-   [Listary](https://www.listary.com/): 类似 Wox，曾经以 Listary 为主力，目前已经转向 Wox\n-   [QuickLook](https://www.microsoft.com/en-us/p/quicklook/9nv4bs3l1h4s): 快速预览\n-   [ScreenToGif](https://www.screentogif.com): 录屏转换为 gif，表情包制作大师\n-   [Dism++](https://www.chuyu.me/en/index.html): Windows 性能优化（清垃圾专用）\n-   [PicGo](https://github.com/Molunerfinn/PicGo): 图床，配合阿里云 oss 使用\n-   [优效日历](http://www.youxiao.cn/): 增强 Windows 任务栏的日历\n\n-   [网易云音乐](https://www.microsoft.com/en-us/p/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/9wzdncrfj2mr) & [QQ 音乐](https://y.qq.com/download/index.html)\n\n-   [Clash](https://github.com/Dreamacro/clash): V2Ray 客户端\n-   [oss-browser](https://github.com/aliyun/oss-browser): 阿里云 oss 的客户端\n-   [HotSwap!](http://mt-naka.com/hotswap/index_enu.htm): 当弹出移动硬盘时显示正在被使用，该软件可以方便 U 盘/移动硬盘的热插拔；首次使用，需要右键 HotSwap! 在系统托盘区域的图标，在**设备类型**中，勾选**可移除磁盘设备**与**安全移除设备**，这样就可以操作 U 盘了。当然用 HotSwap! 操作移动 SATA/eSATA 硬盘也是没问题的\n\n## Windows 的一些基础配置\n\n-   为了能够同步 Windows 和 MacOS 的`ctrl`/`alt`交互，而且我发现`ctrl`键本身也会比`alt`常用一些，用小拇指去按会比较累，所以我在 Windows 操作系统上替换了`ctrl`和`alt`，方便与 Mac 统一，具体操作方式如下：\n\n    -   > 将下列内容复制粘贴到 txt 中，并重命名为`.reg`格式文件，然后双击执行。只需要操作一次就会写入注册表，不需要每次开机都操作。\n        >\n        > ```reg\n        > Windows Registry Editor Version 5.00\n        >\n        > [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]\n        > \"Scancode Map\"=hex:00,00,00,00,00,00,00,00,05,00,00,00,3a,00,01,00,01,00,3a,00,38,00,1D,00,1D,00,38,00,00,00,00,00\n        > ```\n        >\n        > 具体参考：[Windows 中更改 ctrl 与 alt 键互换位置](https://blog.csdn.net/sky_9900/article/details/112256132)，也可以浏览器搜索博客即可\n\n## Chrome 配置方案\n\n推荐安装插件（登录后会自动同步）：\n\n-   1Password\n-   AdBlock\n-   购物党\n-   广告终结者\n-   Zotero Connector\n-   Proxy SwitchyOmega\n-   沙拉查词\n-   其余一些可装可不装的插件：Earth View from Google Earth, Folx, Free Download Manager, GitHub Isometric Contributions, LaTex2Word-Equation, MathJax Plugin for Github, Octohint, Octotree, Sourcegraph, Stylish, 小丰二维码，简悦\n\n## VSCode 配置方案\n\n-   基础配置\n\n    ```json\n    {\n        \"explorer.confirmDelete\": false,\n        \"explorer.confirmDragAndDrop\": false,\n        \"editor.formatOnSave\": true,\n        \"editor.fontFamily\": \"Consolas, 'Microsoft Yahei', 'Courier New', monospace\",\n        \"terminal.integrated.fontSize\": 12,\n        \"terminal.integrated.cursorStyle\": \"underline\",\n        \"terminal.integrated.defaultProfile.windows\": \"cmder\",\n        \"terminal.integrated.profiles.windows\": {\n            \"cmder\": {\n                \"path\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\",\n                \"args\": [\"/k\", \"C:\\\\Program Files\\\\cmder\\\\vendor\\\\init.bat\"]\n            }\n        },\n        \"files.associations\": {\n            \"*.glsl\": \"hlsl\"\n        },\n        \"editor.wordWrap\": \"on\",\n        \"workbench.editor.enablePreview\": false,\n        \"workbench.editorAssociations\": {\n            \"*.svg\": \"default\",\n            \"*.ipynb\": \"jupyter.notebook.ipynb\"\n        },\n        \"workbench.colorCustomizations\": {\n            \"terminal.background\": \"#112233\",\n            \"terminal.foreground\": \"#ffffff\",\n            \"terminal.ansiBlack\": \"#1D2021\",\n            \"terminal.ansiBrightBlack\": \"#665C54\",\n            \"terminal.ansiBrightBlue\": \"#0D6678\",\n            \"terminal.ansiBrightCyan\": \"#8BA59B\",\n            \"terminal.ansiBrightGreen\": \"#237e02\",\n            \"terminal.ansiBrightMagenta\": \"#8F4673\",\n            \"terminal.ansiBrightRed\": \"#FB543F\",\n            \"terminal.ansiBrightWhite\": \"#FDF4C1\",\n            \"terminal.ansiBrightYellow\": \"#FAC03B\",\n            \"terminal.ansiCyan\": \"#8BA59B\",\n            \"terminal.ansiGreen\": \"#95C085\",\n            \"terminal.ansiMagenta\": \"#8F4673\",\n            \"terminal.ansiRed\": \"#FB543F\",\n            \"terminal.ansiWhite\": \"#A89984\",\n            \"terminal.ansiYellow\": \"#FAC03B\"\n        },\n        \"javascript.updateImportsOnFileMove.enabled\": \"always\"\n    }\n    ```\n\n-   VSCode 插件\n\n    -   **Prettier**: 根据配置自动美化代码\n\n        ```json\n        {\n            \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n            \"prettier.tabWidth\": 4,\n            \"prettier.semi\": false\n        }\n        ```\n\n    -   **Better Comments**: 根据一些规则能够高亮注释\n\n        ```json\n        {\n            \"better-comments.tags\": [\n                {\n                    \"tag\": \"!\",\n                    \"color\": \"#FF8C00\",\n                    \"strikethrough\": false,\n                    \"backgroundColor\": \"transparent\"\n                },\n                {\n                    \"tag\": \"?\",\n                    \"color\": \"#FF2D00\",\n                    \"strikethrough\": false,\n                    \"backgroundColor\": \"transparent\"\n                },\n                {\n                    \"tag\": \"//\",\n                    \"color\": \"#474747\",\n                    \"strikethrough\": true,\n                    \"backgroundColor\": \"transparent\"\n                },\n                {\n                    \"tag\": \"todo\",\n                    \"color\": \"#3498DB\",\n                    \"strikethrough\": false,\n                    \"backgroundColor\": \"#fbbc05\"\n                },\n                {\n                    \"tag\": \"*\",\n                    \"color\": \"#98C379\",\n                    \"strikethrough\": false,\n                    \"backgroundColor\": \"transparent\"\n                }\n            ]\n        }\n        ```\n\n    -   **Document This**: 自动生成一些注释（对于 JS/TS 的类、函数）\n\n    -   **ESLint**: 在 VSCode 中集成 ESLint JavaScript\n\n    -   **GitLens**: 能够去浏览一些代码的修改历史\n\n    -   **open in browser**: 能够让 html 文件直接右键>在浏览器中打开\n\n    -   **LaTex Workshop**: VSCode 中写 Latex 必备\n\n        ```json\n        {\n            \"latex-workshop.latex.tools\": [\n                {\n                    \"name\": \"xelatex\",\n                    \"command\": \"xelatex\",\n                    \"args\": [\n                        \"-synctex=1\",\n                        \"-interaction=nonstopmode\",\n                        \"-file-line-error\",\n                        \"%DOC%\"\n                    ]\n                },\n                {\n                    \"name\": \"pdflatex\",\n                    \"command\": \"pdflatex\",\n                    \"args\": [\n                        \"-synctex=1\",\n                        \"-interaction=nonstopmode\",\n                        \"-file-line-error\",\n                        \"%DOC%\"\n                    ]\n                },\n                {\n                    \"name\": \"bibtex\",\n                    \"command\": \"bibtex\",\n                    \"args\": [\"%DOCFILE%\"]\n                }\n            ],\n            \"latex-workshop.latex.recipes\": [\n                {\n                    \"name\": \"pdflatex -> bibtex -> pdflatex*2\",\n                    \"tools\": [\"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\"]\n                },\n                {\n                    \"name\": \"PDFLaTeX\",\n                    \"tools\": [\"pdflatex\"]\n                },\n                {\n                    \"name\": \"XeLaTeX\",\n                    \"tools\": [\"xelatex\"]\n                },\n                {\n                    \"name\": \"latexmk\",\n                    \"tools\": [\"latexmk\"]\n                },\n                {\n                    \"name\": \"BibTeX\",\n                    \"tools\": [\"bibtex\"]\n                },\n                {\n                    \"name\": \"xelatex -> bibtex -> xelatex*2\",\n                    \"tools\": [\"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\"]\n                }\n            ],\n            \"latex-workshop.view.pdf.viewer\": \"tab\"\n        }\n        ```\n\n    -   **Git History**: 查看 git 历史\n\n    -   **Auto Close Tag**: 自动补充 HTML/XML close tag\n\n    -   **HTML Boilerplate**: 提供 HTML 模板\n\n    -   **npm Intellisense**: 自动补全 JS 的 import/require\n\n    -   **Path Intellisense**: 自动补全文件路径\n\n    -   **Rainbow CSV**: 让 csv 文件能够以彩虹色显示，比较直观看到每一列\n\n    -   **Remove - WSL**: 能够让 vscode 直接访问 WSL 的文件\n\n    -   **vscode-author-generator**: 自动生成关于作者的注释\n\n        ```json\n        {\n            \"author-generator.author\": \"Jiacheng Pan\",\n            \"author-generator.email\": \"panjiacheng@zju.edu.cn\"\n        }\n        ```\n\n    -   **CMake** & **CMake Tools**: 对 cmake 语言进行支持\n\n        ```json\n        {\n            \"cmake.configureOnOpen\": true\n        }\n        ```\n\n    -   **JSON Tools**: 帮助美化/最小化 JSON\n\n    -   各种 Snippet 插件：**HTML Snippets**，**JS JSX Snippets**，**JavaScript (ES6) code snippetsxabikos**\n\n## Cmder 配置方案\n\n1. 修改默认主题\n\n    1. 下载或者 clone：[AmrEldib/cmder-powerline-prompt](https://github.com/AmrEldib/cmder-powerline-prompt)\n    2. 下载[`powerline` fonts](https://github.com/powerline/fonts)并安装\n    3. 将所有`.lua`文件放在`${CMDER_HOME}/config`中\n    4. 重启 cmder，然后在设置中将字体改成`powerline`\n\n1. 对于别名的设置（alias），也就是用一个缩写命令，代替一个长命令，可以将常用的长命令缩写；下面`@REM` 表示这句缩写；打开`${CMDER_HOME}/config/user_aliases.cmd`，接下去我都会以`${CMDER_HOME}`表示 cmder 的安装路径，在我的电脑上，一般是：`C:\\Program Files\\cmder`\n\n    ```cmd\n    ;= @echo off\n    ;= rem Call DOSKEY and use this file as the macrofile\n    ;= %SystemRoot%\\system32\\doskey /listsize=1000 /macrofile=%0%\n    ;= rem In batch mode, jump to the end of the file\n    ;= goto:eof\n    ;= Add aliases below here\n    gl=git log --oneline --all --graph --decorate  $*\n    history=cat \"%CMDER_ROOT%\\config\\.history\"\n    unalias=alias /d $1\n    vi=vim $*\n    cmderr=cd /d \"%CMDER_ROOT%\"\n\n    @REM ls=ndir32 -c -j -2 -p\n    l=ls --show-control-chars -F --color $*\n    clear=cls\n    pwd=cd\n    open=explorer $*\n    ~=cd C:\\Users\\Jackie\n    ```\n\n1. 让你的右键菜单栏可以拥有\"Open Cmder Here\": https://github.com/cmderdev/cmder/wiki/Context-menu-integration:\n\n    > 将下列内容复制粘贴到 txt 中，并重命名为`.reg`格式文件，然后双击执行。只需要操作一次就会写入注册表，不需要每次开机都操作。记得将`%CMDER_HOME%`替换成你的 cmder 安装路径，或者确保它成为了一个全局变量。\n    >\n    > ```reg\n    > Windows Registry Editor Version 5.00\n    >\n    > [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Cmder]\n    > @=\"Open Cmder Here\"\n    > \"Icon\"=\"\\\"%CMDER_HOME%\\\\icons\\\\cmder.ico\\\",0\"\n    >\n    > [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Cmder\\command]\n    > @=\"\\\"%CMDER_HOME%\\\\Cmder.exe\\\" /START \\\"%v\\\"\"\n    > ```\n    >\n    > 你可能需要重新启动文件浏览器\n\n1. 防止出现像[issues#48988](https://github.com/microsoft/vscode/issues/48988)的光标错误：找到 `${CMDER_HOME}` 中所有的 `λ` 符号, 主要在 `${CMDER_HOME}/vendor/clink.lua` 和 `${CMDER_HOME}/config/powerline_core.lua` 中，将 \"λ\" 替换成 \"#\" 或者其他的一些符号...\n\n1. 新建窗口的快捷键修改：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/picgocmder-split-shortcuts.png)\n\n## AutoHotKey 配置方案\n\n为了方便使用，我对一些键用 AutoHotKey 做了自定义的功能，但 AutoHotKey 需要开机运行，所以需要进行配置：\n\n1. 首先，AutoHotKey 是每次开机都需要运行一次的，所以不同的设备要能够保持一致，我们需要用坚果云同步`.ahk`文件\n2. 为了开机能够自动运行`.ahk`文件，我们需要将该`.ahk`文件的快捷方式放入一个文件夹，该文件夹中的所有快捷方式都会在开机的时候被执行一次：\n    1. Win+R，在打开的运行程序中输入：`shell:startup`，回车，会打开一个文件夹\n    2. 将该`.ahk`文件放入这个文件夹\n\n接下去是我的脚本配置：\n\n-   为了能够用鼠标方便切换不同桌面，我用鼠标的前进后退键，编码成了左右桌面切换，具体脚本如下：\n\n    ```ahk\n    XButton1::\n    Send, {Ctrl down}{LWin down}{Right down}{Ctrl up}{LWin up}{Right up}\n    return\n\n    XButton2::\n    Send, {Ctrl down}{LWin down}{Left down}{Ctrl up}{LWin up}{Left up}\n    return\n    ```\n\n## Zotero 配置\n\n1. Zotero 插件\n\n    - [ZotFile](http://zotfile.com/)：帮助重命名文件和文件夹，需要对命名规则进行简单的修改：\n        - 修改重命名规则：\"工具>ZotFile Preferences>Renaming Rules\"，取消勾选\"Renaming Format>Use Zotero to Rename\"，将\"Format for all Item Type except Patents\"按照需要修改，我修改的先后顺序是：title(t)，year(y)，author(a)\n\n2. Zotero 配合坚果云同步\n\n    1. 在坚果云中新建一个同步文件夹，专门用于同步 pdf：当前我使用`坚果云>应用数据>Zotero>Storage`作为同步文件夹\n\n3. 设置 Zotero，让 Zotero 只同步文件结构索引：\n    1. \"编辑>首选项>同步>设置\"：登录你的账户，勾选\"自动同步\"和“同步全文内容”，将“同步文献库中的附件\"和\"使用 Zotero 云存储同步群组文献库中的附件\"取消勾选\n    2. “编辑>首选项>高级>文件和文件夹\"：将根目录改成步骤 2.1 中设置的坚果云同步文件夹（比如，我使用的`坚果云>应用数据>Zotero>Storage`，它的对应绝对路径是`D:\\应用数据\\Zotero\\storage`）；然后将”数据存储位置“修改为当前你的 Zotero 文件夹，比如我用了`D:\\Zotero`\n    3. 设置 ZotFile 的\"源文件夹\"：\"工具>ZotFile Preferences\"，将\"Location of Files\"选择为\"Custom Location\"，将它的值修改为步骤 2.1 中设置的坚果云同步文件夹，设置\"Use subfolder defined by\"为`/%w/%y`\n4. 对新加入的文件进行重命名（右键>Manage Attachments>Rename Attachments）\n","tags":["Windows","software"]},{"title":"Lumos Increasing Awareness of Analytic Behavior during Visual Data Analysis","url":"/blog/2021/10/11/2021-10-11-Lumos/","content":"\n### 基本信息\n\n-   **论文：**Lumos: Increasing Awareness of Analytic Behavior during Visual Data Analysis\n-   **作者：**Arpit Narechania, Adam Coscia, Emily Wall, Alex Endert\n-   **来源：**VIS 2021\n-   **链接：**https://arxiv.org/abs/2108.02909\n-   **视频：**https://www.youtube.com/watch?v=o2lGQLaT7T4\n\n一作、二作、四作来自于乔治亚理工，三作来自埃默里大学，\n\n| Arpit Narechania                                                                                          | Adam Coscia                                                                                               | Emily Wall                                                                                                | Alex Endert                                                                                               |\n| --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\n| ![image-20211011202840864](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202840864.png) | ![image-20211011202842766](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202842766.png) | ![image-20211011202844715](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202844715.png) | ![image-20211011202846488](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202846488.png) |\n| Ph. D. from~2019                                                                                          | Ph. D. from~2020                                                                                          | Assistant Prof.                                                                                           | Associate Prof.                                                                                           |\n| 人机交互、可视界面、自动驾驶、自然语言、cognitive bias                                                    | 人机交互、可视分析、cognitive bias                                                                        | decision making、可视分析、cognitive bias                                                                 | 人机交互、信息可视化、可视分析                                                                            |\n\n### Introduction - 问题 & 贡献\n\n浏览数据时，可能会产生无意间的偏差从而引起偏见，当你浏览的数据分布和真实的数据分布存在区别时，你就会形成偏见，比如你见过的黑人都犯罪，你会觉得黑人都犯罪，然而现有的分析工具（Tableau/Excel）并不会报告上述偏差。\n\n作者想要提出能够在分析过程中反馈偏差的工具，于是他们贡献了 Lumos，一个可视化数据交互历史的分析工具，能够在数据分析和决策时提醒用户存在潜在的交互偏见。\n\n### Related Work - 相关工作\n\n作者主要展示了两个方面的相关工作，Graphical History 相关的工作主要聚焦于展示交互的历史，本文的工作受到它们的启发；Modeling User Behavior 的工具主要提出一些能够描绘行为的指标，本文的 metrics 来源 17 年 VAST，衡量**用户交互行为**和**均匀行为 (uniform behavior)**的偏差。以往的交互焦聚于 explicit subset selection; 本文更广（包括点击、悬浮、可视化配置、过滤器配置等）。\n\n### Terminologies - 术语\n\n-   **Interaction Logs**：交互日志，记录了用户交互行为（如 hover）以及用户界面元素（如 散点图的 datapoints）\n-   **Analytic Behavior Model**：分析行为模型，根据交互日志量化用户行为的模型（比如计算被交互的 datapoints 及其属性的分布）\n-   **Interaction Traces**：交互痕迹，交互行为在界面上的视觉反馈，通过从两方面增加视觉痕迹（visual scents）：in-situ 和 ex-situ\n-   **Awareness**：意识，知道在探索过程中发生了什么，从而可以进行推理\n\n### Design Goals - 设计目标\n\n作者们根据：1）相似的可视分析工具；2）试点实验的反馈；3）他们自己关于 usability 的假设，总结并得到了如下的射击目标：\n\n-   DG1. 捕获并展示分析行为中的**相关属性**\n\n-   DG2. 捕获并展示分析行为中的**相关数据点**\n\n-   DG3.帮助设置不同的**目标基准分布**\n\n-   DG4.帮助**分析行为**和**基准分布**的比较\n\n-   DG5.在可视数据探索时展示**awareness**\n\n### 量化分析行为 - Quantifying Analytic Behavior\n\n作者采用了两个方面来量化分析行为：\n\n-   第一个为属性分布指标 (Wall et al.’s attribute distribution metric, AD metric)，泳衣描述**用户交互行为**和**期望行为之间**的偏差，0 表示无偏见，1 表示高偏见。\n-   第二个为数据/属性的交互频率，主要记录对不同数据点和属性的交互次数\n\n### 用户界面 - User Interface\n\n![image-20211011194626522](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011194626522.png)\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">A</div> Data Panel，展示加载好的数据集;\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">B</div> Attribute Panel，展示数据集包含的属性，每行的开始是一个icon，展示属性的类型，A表示nominal类型，#表示quantitative类型，日历符号表示temporal类型。这里，蓝色的深浅还编码了这个属性被交互的次数（这里的交互主要指通过该属性过滤，或者该属性被用于x/y轴，视图C和D会用到），颜色越深表示被交互的次数越多，白色表示完全没有被交互过；\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">C</div> Encoding Panel，可以选择图表类型，用于编码X/Y轴的属性；\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">D</div> Filter Panel，控制不同类型属性的过滤；\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">E</div>  Visualization Canvas，交互次数越多的datapoint会编码的越深\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;line-height:1.5em;\">F</div> Details View，Hover在single datapoint上：显示数据本身的属性；Hover在aggregation上：显示table；\n\n<div style=\"display:inline-block;border-radius:50%;width:1.5em;height:1.5em;background-color:#7030A0;text-align:center;color:white;\">G</div> Distribution Panel，设置你要浏览的目标分布，展示目前浏览的属性分布和目标分布之间的区别，红:该属性的浏览和目标差距较大；绿:该属性的浏览接近目标分布；\n\n#### 内置/外置的交互踪迹\n\n作者提出了两种展示 interaction traces（交互踪迹）的方法，in-situ 的方法将 **Interaction Traces**集成在数据点/属性上，如下图所示，颜色展示交互频率。\n\n![image-20211011201316845](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011201316845.png)\n\nex-situ 的方法通过另外的视图来展示，下图左用颜色编码了不同属性上的浏览与目标之间的相似度，下图右则直接描绘了浏览的数据分布（蓝色区域）和目标分布（黑线）之间的区别。\n\n![image-20211011201403025](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011201403025.png)\n\n#### 配置不同的目标分布\n\n作者提供了两种不同的预制的分布：propositional（下图左）的分布表示目标分布应该和源数据分布保持一致（成比例的），equal（下图中）的分布则表示用户的浏览应该雨露均沾，不同的范围都应该浏览同样多；custom（下图右）则允许用户自己通过拖动，sketch 一个自定义的分布。\n\n![image-20211011201643236](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011201643236.png)\n\n### 使用场景\n\n两个使用场景，不在赘述，第一个展示了系统能够增加对于交互行为的意识（increasing awareness of analytic behavior），第二个则展示系统能够消除分析行为的偏见（Mitigating biased analytic behavior）\n\n![image-20211011202423257](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202423257.png)\n\n![image-20211011202430856](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011202430856.png)\n\n### 评估\n\n作者采用了一个 between-subjects qualitative study，将 24 个人分成实验组和对照组，实验组使用拥有 awareness 的系统，对照组使用没有 awareness 的系统，看不到任何的 interaction traces。\n\n-   任务：分析电影数据集的分析，推荐电影出品公司下次应该出品的电影的特征（“analyze a dataset of moviesto recommend the characteristics of movies that a movie production company should make next”）\n-   假设\n    -   H1. interaction traces 能够唤起对分析行为的意识\n    -   H2. 两组之间的交互行为会有区别\n    -   H3. ex-situ 的 awareness 会比 in-situ 的 awareness 更有用\n    -   H4. 实验组的参与者会对 interaction traces 有反应，减少偏差\n\n首先，作者让被试们对不同模块的 usefulness 进行打分，分别比较了对照组和实验组的打分区别（下图 A），以及在实验组中，in-situ 的交互痕迹与 ex-situ 的交互痕迹之间的打分区别（下图 B），结合打分结果与被试的访谈，作者讨论了很多相关内容，证明了 H3。\n\n![image-20211011203234466](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011203234466.png)\n\n紧接着，作者还让被试谈及自己的 awareness moments，也就是他们意识到自己有 bias 的时刻，以此来验证 H1 和 H4。\n\n作者还记录并统计了不同的交互次数，展现了对照组和实验组的交互行为的区别，主要包括对数据点的交互，对属性的交互，图表类型选择、过滤和编码，以及 distribution panel 中的不同 card 的使用。\n\n![image-20211011203924759](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011203924759.png)\n\n但是作者只观察到个别实验组的被试，在使用系统时因为开启了 interaction traces，从而使 bias（AD metrics）下降的情况（下图 D），大部分人并不会有意识的去控制 bias。\n\n![image-20211011204034683](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20211011204034683.png)\n\n### 讨论\n\n-   根据用户反馈，用颜色来编码交互痕迹似乎不妥，然而除了颜色也似乎没法\n-   target distribution：很难去描绘一个特定的 distribution\n-   假阳性：用户会有意识的忽略一些东西，但系统会将它们标记出来\n-   更多的缓解偏见的策略，被试提的一些小建议\n-   学到的教训\n    -   好的系统需要通过增加 usability 来鼓励用户沉浸、深入地进行分析（get lost），但也需要能使用 awareness 来提醒用户发生了什么\n    -   虽然用户能够意识到偏见的产生，但系统本身并不能主动帮助用户修正分析行为（比如推荐数据）\n    -   不同的任务会有不同的目标分布\n    -   系统帮助修正用户的行为反而会招致用户对系统的控制力降低\n\n### 限制\n\n-   可视化形式较少\n-   用户行为仅根据交互来建模\n-   不同交互的权重一样\n-   对于 aggregation visualization 的交互仅仅是简单的除以 N\n\n### 我的看法\n\n-   优点：\n    -   问题小，对 bias 的定义比较好，是对前作 (Warning, Bias May Occur) 的扩展\n    -   evaluation 做的很好\n    -   开源\n-   缺点：\n    -   容易被 challenge 文章的 novelty、contribution 不足的问题\n    -   evaluation 在总体上对于 AD metrics 缺少衡量，因为结果不太好\n-   一些创新想法？\n    -   bias 的引起：数据本身、可视化编码、分析过程的覆盖率，甚至展示的硬件等\n    -   bias 的类型：表格类型数据以外？数据探索的覆盖率以外的偏见？\n    -   coverage：交互过 = covered？\n","tags":["论文评述","报告"]},{"title":"P4 P5 以及 P6","url":"/blog/2021/06/10/2021-06-10 P4&P5&P6/","content":"\n# 基本信息\n\n- **论文：** P4 P5 以及 P6\n- **作者：** Jianping Kelvin Li 和 Kwan-Liu Ma\n- **来源：** TVCG 2018 (P4), VIS 2019 (P5), and VIS2020 (P6)\n\nUCD马匡六老师组Jianping Kelvin Li的三篇接续工作，虽然关注内容不一样，但写作风格比较相似，都是做这种工具式的东西，值得自己模仿；\n\n\n\n# P4: Portable Parallel Processing Pipelines for Interactive Information Visualization\n\nP4的目的是实现一个信息可视化的 **P**ortable (轻便的) **P**arallel (并行) **P**rocessing (处理) **P**ipelines (管道)。\n\n因为现有的可视化工具在expressiveness和high performance之间存在gap，于是作者期待能够开发一种工具，能够使用GPU的计算性能来加速信息可视化的**处理**和**渲染**。其提出了四个目标：\n\n- performance：性能（数据处理性能和可视化渲染性能）\n- productivity：生产力（不懂GPU编程的人也能用，提供 JSON 格式接口）\n- programmability：可编程性（懂的人能编写自己的逻辑，提供 JavaScript 接口）\n- portability：轻便性（面向浏览器）\n\n它的contribution是：with **declarative grammar** to leverage **GPU** computing for accelerating both **data transformations** and **visualziations**\n\n\n\n对于data transformation (数据转换)而言，坐着定义了一些原子操作：\n\n- **Derive** - 从已有属性用自定义逻辑**导出**新属性\n- **Match** - 保留复合所有指定条件的数据\n- **Aggregate** - 根据指定属性和统计方法进行 聚集（group）/ 装箱（bin）\n\n而对于可视化的可视映射而言，则定义了\n\n- **形状**：circle, line, and rectangle\n- **通道**：color, opacity, width, height, 以及 position x and y\n\n最后还有交互：click, hover, brush, zoom, or pan\n\n\n\n以上的这些操作都可以在GPU上完成，具体做法是把以上的这些操作拆分为底层GPU的实现，底层GPU实现分成四种基本操作：\n\n- fetch (key => value): 通过fetch来找到对应某个属性的value\n- map\n- filter\n- reduce\n\n比如derive就可以通过fetch+map的组合进行实现，具体不再详述，只描述一个理念。文章还支持自己实现一些用户逻辑，但感觉写的语言应该是webgl的shader，不太容易；\n\n为了说明GPU对于可视化而言能做的事情，作者还举例了一个感官增强的例子，也就是用透明度来展示密度：\n\n![image-20210623131358111](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623131358111.png)\n\n这种操作其实就是核密度估计，可以被用于GPU的操作。\n\n\n\n# P5: Portable Progressive Parallel Processing Pipelinesfor Interactive Data Analysis and Visualization\n\n渐进式可视化（progressive visualization）属于一种逼近正确可视化结果的一种操作，通过每次操作部分数据，不断累加可视化结果，放弃部分精准度来增加可视化速度，算是一种在computation latency和quality之间的权衡。渐进式可视化特别适合大数据的可视化，其动机也和P4用GPU处理数据的动机是吻合的。\n\n对于这一项工作，作者提出了三个goals：\n\n- Progressive **Parallel** Processing: 渐进式的并行处理（GPU）\n- **Declarative** Progressive Visualization: 有声明式语法\n- **Interactive** Progressive Analysis: 交互\n\n该工作的贡献是：\n\n- 无缝衔接GPU计算和渐进式处理的可视化框架：**a visualization framework** that seamlessly integrates GPU computing with progressive processing\n- API很直观的渐进式数据转换和可视化声明式语法：**an intuitive API** with **declarative grammar** for specifying progressive data transformations and visualization operations, both of which effectively run on the GPU\n\n与传统的可视分析流程不同，渐进式可视化的分析流主要包含了一个划分、批处理、再整合的结果（下图左）；本文提出的可视分析详见右边：其主要改变在于它可以提供**批量加载数据**，并且提供对于每个批次的操作（`batch`），对于中间结果的操作（`progress`），以及对于流程的控制（`excute` `next`）。\n\n![image-20210623131702872](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623131702872.png)\n\n- `batch`操作符指定每个批次的**统计计算**和**数据转换**操作，自动累加batch的计算结果，产生**中间结果**；\n- `progress`操作符指定对于**中间结果**的数据转换和可视化操作；\n- 还拥有一系列对于流程的信号和控制进行回馈的操作符：`execute` `pause` `resume` `onEach` `onComplete`\n\n下面是例子：\n\n![image-20210623132228018](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623132228018.png)\n\n对于可视化而言，作者认为并非所有的可视化形式都适合渐进式可视分析，只选取了 numeric / categorical / temporal / geospatial 四大类。并且，对P4中的多视图可视化做了一些调整和升级。\n\n![image-20210623132444234](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623132444234.png)\n\n对于交互而言（主要是brush的选择操作），渐进式可视化对于很多统计类型的图表无法操作到具体的细节数据元（如tabular数据的每一行），所以里面用到了累和表来减少对内存的依赖，只需要通过累和表中的cell之间的加减就能得到刷选区域的元素数量。\n\n![image-20210623132716246](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623132716246.png)\n\n\n\n# P6: A **Declarative Language** for Integrating **Machine Learning** in Visual Analytics\n\n机器学习和可视分析经常结合在一起用，但缺少一个通用和统一的工具，能够集成两者。作者提出了一个新的框架，设立了三个目标：\n\n- Interactive Machine Learning and Visualization（在界面上交互式调整参数）\n- Interactive and Scalable systems（高性能计算（并行计算））\n- Declarative Visual Analytics（声明式语法）\n\n他们贡献了一个可以用以集成机器学习和可视化方法的交互式语言（**a declarative language** for rapidly specifying the design of visual analytics systems that integrate machine learning and visualization methods for interactive visual analysis）\n\n该框架融合了可视分析流程和KDD流程，左边是传统的可视分析流程（将数据进行转化和可视映射，然后绘制成视图），上方则是KDD（知识和数据挖掘）的流程。\n\n![image-20210623135229061](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623135229061.png)\n\n文章主要对这个流程进行了剖析，首先是pipeline：\n$$\n\\begin{aligned}\npipeline &:= \\{data, analyses, view\\mbox{-}layout, visualizations, interactions\\}\\\\\ndata &:= \\{source, selection, preprocessing, transform\\}\\\\\nanalysis &:= \\{features, scaling, algorithm, [parameters]\\}\n\\end{aligned}\n$$\n整个分析流，需要依赖数据（data），分析（analyses），视图及其布局（view-layout），可视化（visualizations）以及交互（interactions）；\n\n其中数据（data）又依赖这几项：数据源（source），选择（筛选部分数据，selection），预处理（preprocessing）以及转换（transform）；preprocessing主要进行数据清洗、类别型数据的one-hot encoding等，而transform则主要指的是对数据的聚合、过滤、排序等。\n\n分析（analysis）则主要指数据挖掘算法进行挖掘，其中features表示选择的数据属性，scaling则是数据缩放（比如进行标准化），algorithm指挖掘模型，用户还可以通过model训练一个algorithm：\n$$\nmodel := \\{module, method, training\\mbox{-}data, target, features, [parameters]\\}\n$$\n\n\n文章主要集成了一些分类、回归等经典的机器学习模型，对原有的多视图语法稍微进行了修改，还能整合多个可视化形式。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20210623140647952.png)\n\n作者还支持了模型调参，主要是通过grid search进行参数搜索，还有对于模型选择的属性的一些可视化结果的展示。这个项目并非全部在前端集成，而是一个BS系统，通过python和P4分别执行机器学习和可视分析。\n\n","tags":["Visualization","Authoring","WebGL"]},{"title":"Kyrix-S: Authoring Scalable Scatterplot Visualizations of Big Data","url":"/blog/2021/04/20/2021-04-20 Kyrix-S-Authoring Scalable Scatterplot Visualizations of Big Data/","content":"\n# 基本信息\n\n- **论文：** Kyrix-S: Authoring Scalable Scatterplot Visualizations\n- **作者：** Wenbo Tao, Xinli Hou, Adam Sah, Leilani Battle, Remco Chang and Michael Stonebraker\n- **来源：** TVCG 2020\n\n一作和他的导师（Michael）来自MIT的CSAIL可视化实验室。\n\nStonebraker的研究领域主要聚焦于数据库，特别是关系型数据库，曾获图灵奖。目前，Stonebraker是MIT的兼职教授。\n\n\n\n# 复述文章\n\n> 太长不看版：\n>\n> 作者做了一个大规模散点图的创作语法及其相应的系统，通过**配置语法**和一个**自动生成不同缩放层次布局**（mark的摆放位置）的方法，解决了大规模散点图的创作困难；\n\n## Motivation&Challenges\n\n- scatterplots能够提供一系列任务来揭示对于数据集的洞见。\n- 以往的工作对于解决大数据集具有一些不足：\n  - 基于聚类的工作无法inspecting individual objects；\n  - 其他的工作使用了一系列不同scale的zoom level，但这些系统都具有scalability的问题。并且这些工作需要developer work来生成不同缩放层次上的标记放置位置。\n\n## Contributions\n\n- Kyrix-S：支持声明式创作的系统；\n- 简洁且易于表达的声明式语法；\n- 支持对大规模SSV (scalable scatterplot visualizations) 进行离线indexing以及交互式browsing的框架；\n\n## 文章组织\n\n1. 根据【existing guidelines and our experience with SSV users】定义了四个design goals，包括1. **快速创作**；2. **表达能力**；3. **可用的SSV** (在layout那边进行了详细介绍)；4. **scalability** (offline indexing + interactive online serving)；\n\n2. 介绍了grammar的组成：\n\n   - 先举了三个例子；\n   - 其次讲了语法中的marks怎么绘制：基于template和自定义扩展；template是基于一些tasks精心挑选的，比如热力图、扇形图等等；\n   - 最后讲了布局：对于X/Y/Z轴的配置选项；\n\n3. 介绍了layout是怎么生成的。其实scatterplot本身没有是没有layout问题的，因为x/y方向都直接根据两个属性的值就能确定了；但因为涉及到重叠的问题，就需要把一些过度重叠的marks进行合并。于是作者系统的定义了layout这个问题：\n\n   - **Non/partial overlap**: $\\theta$参数来控制每个mark的bbox (bounding box)的允许重叠程度；\n   - **Bounded visual density**: $K$参数控制viewport允许的mark数量上限；\n   - **Zoom consistency**: 在i层的元素必须要在j层能被看到（j比i更深）\n   - **Data abstraction quality**: 这一点感觉作者讲的有点模糊。首先说 cluster mark 的质量可以根据within-cluster variation (这个mark所代表的objects到mark的平均距离) 来进行刻画；后面又重复说了一次importance policy来说明abstract的时候需要保留重要的东西...\n\n   然后作者开始介绍在单机（single node）上，如何处理layout的算法：\n\n   1. 首先计算每个mark之间的ncd距离；如果$ncd \\lt 1$，两个mark存在重叠；通过$\\theta$来设置最小的ncd限制，$\\theta$越小，mark之间越近，mark的density也会越高（因为一旦mark之间的$ncd<\\theta$就会被合并起来）；\n\n   2. 需要找到一个最小的$\\theta$，使得在viewport中包含的mark数量不超过$K$；可以通过如下公式来估算当前viewport能够容纳的mark数量上限 ($\\mathscr{P}(\\theta)$)，只要设置$\\mathscr{P}(\\theta) \\leq K$，就可以保证数量不超过K了；作者通过二分查找法进行查找。\n      $$\n      \\mathscr{P}(\\theta)=\\left\\lceil\\frac{W_{V}}{W_{B} \\cdot \\theta}\\right] \\cdot\\left[\\frac{H_{V}}{H_{B} \\cdot \\theta}\\right]\n      $$\n\n   3. 层次聚类：对于在$i+1$层的某个mark A，找到在$i$层，其ncd距离最小的mark B，如果$ncd_{A,B} \\lt \\theta$，就把B合并到A中。\n\n   作者接下去描述了分布式的并行策略：通过KD树对于区域进行划分，不同区域用不同的计算节点进行处理，然后再处理在划分边界上的cluster；\n\n4. 实验部分：展示了online serving的时间（数据获取的时间）以及offline indexing的时间；然后对比了Kyrix-S 和 他们之前的 Kyrix 的代码行数；\n\n# 文章评价\n\n个人比较赞赏这篇文章，因为它并没有用到非常难的技术，却解决了一个实际的问题。但说实话，因为其中不包含任何算法部分，novelty的确是一个比较大的问题，所有的设计都是很trivial的，但贵在其处理的数据量比较大，解决的问题比较实际，且代码是开源的。个人能给到4分。\n\n- 值得学习的地方：\n  1. introduction在老的问题（scaterplot authoring）定义了一个新的点（large scale），然后去描述前人工作的不足，可以学习一下套路；\n  2. grammar的设计还是挺全的，比较convincing；\n  3. 一个grammar+一个类似algorithm的framework的组织形式，丰富了文章的contribution；做authoring相关的工作时，很容易遇到grammar本身没有什么新意，本身grammar就要让用户容易理解，这就导致它的设计本身，并不会有太多的新意（因为大家都能理解）；所以加入一些算法就会让工作不会显得那么trivial；\n  4. 对于做scatter plot的grammar其实没啥新意，但是对某个垂直领域做grammar就有点意思了。\n- 做的不足的地方：\n  1. 对三个contribution的evaluation比较不足。不过创作型工具的确比较难进行实验对比；\n  2. 其实文章并没有讲Kyrix-S这个系统，而是语法，把它作为contribution让人有点迷惑；\n  3. 聚类算法比较单一，应该写一下他能够支持其他的聚类算法，感觉这种贪心的策略不够精准；\n- 个人启发：\n  1. 大家可以尝试去挖掘某个垂直领域的authoring tool，在图里面，可以往matrix、layout、large graph这些方向进行细挖；然后再套上一个看上去像回事儿的算法，paper就差多了。\n  2. 有时候design choice很难选，比如文章中设计cluster mark的时候，就有：热力图、Contour map、扇形图、雷达图等等，文章说这些是基于完成某些有背书的任务而设计的，其他可以支持用户自己扩展即可。我们在做design choice的时候，几乎也只要这么写就行了，你的设计有背书、有意义；其他的就让用户自己扩展即可。\n\n","tags":["Visualization","Authoring","Scatterplot"]},{"title":"ATOM: A Grammar for Unit Visualizations","url":"/blog/2020/08/06/2020-08-06 ATOM-a grammar of unit visualization/","content":"\n# 基本信息\n\n- **论文：** ATOM: A Grammar for Unit Visualizations\n- **作者：** Deokgun Park, Steven M. Drucker, Roland Fernandez, and Niklas Elmqvist\n- **来源：** TVCG 2018\n\n# 背景\n\n单元可视化（unit visualization）是一种区别于聚合可视化的形式。往往聚合可视化焦聚于生成具有统计结果意义的可视化形式，比如柱状图，饼图，直方图（histogram）等等；而单元可视化则使得每一个数据点都能够在可视空间中被绘制出来，比如散点图（scatterplot，下图 a），点图（dotplots，下图 b），单元图表（unit chart，下图 c）。\n\n![1596716549128](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/1596716549128.png)\n\n相较之下，聚合可视化能够解决视觉混乱的问题（visual clutter），而单元可视化因为其进行数据空间到可视空间一对一映射，其 computational scalability（内存、计算、渲染等）、display scalability（展示空间不足）和 perceptual scalability（人的处理能力）都会较差；但单元可视化也并未没有优势，它因为完全展示了所有数据点，故而能够进行异常值检测，并且能够提供在动画、交互过程中对个体元素进行追踪，并且这种一对一映射的单元可视化，更接近人们的思考和构建可视化时的思考习惯和认知，且还能解决一些更细致的交互需求。\n\n基于上述特点，作者提供了一种高层次的单元可视化语法，它基于一次对设计空间的结构化探索，提供了自顶向下递归式的数据和空间剖分。\n\n![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/bVYg2CL3T2Ev8K0HIkCAZ_ZRATl_cIMcdvUxee_LUgVYrkERj4bURGcqUaFbJwFBG1_QYsnaPE7nUosxBsyngK_I35Lir7Ti_fTxmYDGUdp3jW0vC1fhqOuwv5w7W393PWwDcHTIoD8.jpg)\n\n# 相关工作\n\n作者对以往的单元可视化进行了一个分类，一直追溯到上古时期。对于他们的布局方法、坐标系统和单元图标进行了一些分类。\n\n![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/j_Ob9gc6zdfTMEOBHObNLtBJ7ZOKPpBaBxFvDzt4xAOSc8RrkBNu5_lGlCHHbJBbrCAGslL0zfg_QTrOA8lpLK78Ce25UqecmNbC2Wo6QbAdvaFLa0azA9MdExuMrZ2BnKU6OBs5MLs.jpg)\n\n![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/mnxDZTcj9RF_k8KKrw87HSauTsuWQr6cjHAJTXabwyjPVte-ubb23uWr_czjlQgfbkOEtM9XL-FjCtqZRUbX3b3l5i4Vr4abAoaiNqTC9aYWIpW_IKB6Mx3gNxY54PQQM1pPHz-yOqQ.jpg)\n\n除此以外，作者还讨论了一些以往的可视化创作（语法）工具，比如 Prefuse/Processing/D3/Protovis 等编程式工具，ggplot2/vega/reactive-vega/vega-lite 等声明式工具等。\n\n# Design Space\n\n在本文中，作者焦聚于静态的可视化形式，而不讨论任何交互、动画等。\n\n作者将布局类型划分成两类：重叠的和非重叠的。重叠的布局，每个数据点位置和大小只依赖于自身，比如散点图。非重叠的布局，其数据点位置和大小往往需要通过整体或者周围的数据点来决定，其一般是空间填充类型的，上图的大部分可视化都是如此。对于这种类型，又可以分成两种手段，一种是划分（subdividing），即自顶向下分配可视化空间；另一种是填充（packing），则是自下向上把空间挤满（这种可视化形式，每个数据点往往是正方形或正圆形，横纵比 1:1）。\n\n对于每个点的表达，又可以大致分成两种：一种是静态的预定义好的几何形状（比如一个 icon 或者 image），一种是根据数据自身决定的（比如不同类别绘制不同形状，glyph 等等）。\n\n# ATOM\n\n接下去，作者开始讨论语法的设计。ATOM 主要要解决以下几个问题：\n\n1. 数据空间的操纵，作者定义了四种方法：\n\n   - BIN：可以对数据进行分类 or 聚类；\n   - FILTER：根据某种过滤类型过滤数据；\n   - DUPLICATE：数据拷贝\n   - FLATTEN：数据平面化，不再进行任何聚类，直接将数据一对一绘制；\n\n2. 可视空间的划分：在这里，作者将以往存在的划分手段进行了一个层次划分，但最后只实现了以下几种：\n\n   - Map2D：直接用数据中的特征将数据映射到可视空间中（最常见的就是 scatterplot）\n   - FillX&FillY：对一维空间进行填充\n   - MaxFill：对整个空间寻找一个最大填充的解（类似背包问题）\n   - Pack：类似上面的 MaxFill，但是每个图形都是方正的\n\n   ![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/aTvF2S7Ot35oPD3mdS6EjdejukOCJw__ubr8rt8YkJr4x6_7_xUARlIvuQcT7smVVmVyeJUfTOzWGRR3kADAhbQpel1LoxrvGAlZ2VFj-f_o0t0Ci3wglqbngOjKhXragU6tOrP2rlI.jpg)\n\n   上述的几种手段，具体效果可以见下图；上面一行表示的是均匀划分，下面一行则是加权平均进行划分；\n\n   ![1596718302877](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/1596718302877.png)\n\n3. 单位外观的问题\n\n   1. shape 是长方形还是圆形？\n\n   2. 大小是 uniform 的还是根据 count/sum 进行的；\n\n   3. isShared 属性；也就是，单位大小是否要根据隔壁组进行统一？该配置项大概效果如下图，左边是三列共享大小，右图则是不共享。\n\n      ![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/WDIVqks07wb-DsvkLjvM4X9jEflY2GsfMGIyBXs9zNOtPg_Xl7n3Y8dkoxo9YS2C15XlSl7BMDAbK9ggvHCBcgRpEEsnDDHeBjYdJIS_f9Qeh7sIvHs-koXlX9xDbnWF7JU_K7puJdU.jpg)\n\n# 评估\n\n最后，作者进行了两次评估。为了证明其表达力，作者罗列了为了解决以往存在的不同单元可视化形式，用 ATOM 可以怎么进行详见下面的表格；为了证明其生成可视化的能力，作者又创作了两种不曾存在的可视化形式。\n\n![1596719563432](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/1596719563432.png)\n\n![1596718568727](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20-08-06/1596718568727.png)\n","tags":["Visualization","Graph Visualization","Authoring"]},{"title":"CS229：16-模型选择和特征选择","url":"/blog/2019/01/18/2019-01-18 16-模型选择和特征选择/","content":"\n首先来说几种验证训练结果的方法。\n\n- 保留交叉验证法 hold out cross validation\n\n  给出一个训练集，随机分成两个，一部分当做训练子集（一般占 70%）用于训练，另一部分当做保留交叉验证子集（30%）用于测试。\n\n- k 重交叉验证法 k-fold cross validation\n\n  将整个数据集分成 k 部分，拿出 k-1 部分进行训练，将剩下一个用于测试。重复上述过程 k 次（每次都不一样），求出均值即为验证结果。一般 k 取 10。\n\n  优点：增加了训练数据；缺点：计算代价高；\n\n- 留一交叉验证法 leave one out cross validation\n\n  当 k=m（训练数据量）时，称之为留一交叉验证法。一般用于训练数据过少的情况。\n\n## 特征选择\n\n在进行学习时，过多的特征容易带来过拟合，需要选出一个特征子集，其中的特征与学习算法最相关。\n\n### 前向搜索法 forward search\n\n过程如下：\n\n1. 初始化特征集$\\cal F$\n2. 对于不属于$\\cal F$的每一个特征，计算添加该特征后模型精度的提升；\n3. 选择提升最大的特征加入$\\cal F$\n4. 重复 2 和 3，直到精度不在上升。\n\n当然可以设置阈值 k，当$\\cal F$包含了 k 个特征后即停止。\n\n### 后向搜索法 backward search\n\n基本步骤与上述类似，只是过程相反：首先从满的特征集开始，之后每次删除表现最差的特征。\n\n---\n\n上述的方法都被称为**\"wrapping\" feature selection**（“封装”特征选择），\"封装\"这个词，意味着：\n\n当你进行选择时（前向搜索或者后向搜索）你需要重复使用学习算法去训练模型，根据结果来选择特征子集。\n\n这种方法主要缺点是计算量大，但是它是一种比较准确的选择方法。\n\n另外有一种算法，可能它的泛化误差不会太低，但是计算代价较小。\n\n### 特征过滤 filter method\n\n主要方法是，计算每一个特征的一些度量，来衡量对 y（label）的影响有多大，一般使用互信息（Mutual Information）来度量：\n\n$$\n\\begin{align}\nMI(x_i, y) &= \\sum_{x_i \\in \\lbrace 0,1 \\rbrace} \\sum_{y \\in \\lbrace 0,1 \\rbrace} p(x_i, y) \\log \\frac{p(x_i, y)}{p(x_i)p(y)} \\\\\\\n&= KL(p(x, y) || p(x)p(y)) \\text{, KL divergence}\n\\end{align}\n$$\n\n然后去选择最好的 k 个特征。\n","tags":["Course Notes","Machine Learning"]},{"title":"杂谈：图的相关基础知识","url":"/blog/2019/01/16/2019-01-16 图的基础知识/","content":"\n# Graph Knowledge\n\n一些图论、图挖掘等图相关领域的知识收集、汇总。\n\n## 节点相关的概念\n\n### degree 度\n\n一个顶点的度（degree）指与该顶点关联的边的数目。当边有权重时，就是所有边的权重和。记做$deg(v)$。\n\n在有向图中，还有出度（out-degree）和入度（in-degree）的概念。\n\n出度（out-degree）指以该顶点为起点的边的权重和，入度（in-degree）指的是以该顶点为终点的边的权重和。\n\n## 链接相关的概念\n\n## 结构相关的概念\n\n### bipartite 二部\n\n将图的顶点分成两个非空集合$V_1$和$V_2$，如果这个图的每一条边的两个端点都分别属于$V_1$和$V_2$，那么称这个图是二部图（bipartite）。\n\n在这个概念的基础上，还有完全二部图（complete bipartite graph）的概念，指的是在 bipartite 的基础上，$V_1$中的每个点，都与$V_2$中的每个点相连。\n\n### graphlets 图元\n\n图元，指的是一系列异构的（_isomorphism_）导出（_induced_）子图。\n\n下面列举所有的 3 节点、4 节点、5 节点的图元：\n\n![3节点、4节点、5节点的所有图元](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-1/21892478.jpg)\n\n### induced 导出\n\n给定一个图$G$，以及这个图的子图（subgraph）$G'=(V', E')$，其中$V'\\subseteq V$并且$E' \\subseteq E$。如果$E' = \\{(v_i,v_j)|(v_i,v_j) \\in E \\text{ and }v_i, v_j \\in V'\\}$，也就是对于所有属于$V'$的节点，他们在原图$G$的中出现的所有边，也都出现在$G'$的$E'$中，那么，这个子图$G'$称为$G$的导出（induced）子图。\n\n下面是导出子图的一个示例：\n\n![导出子图](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-25-085552.png)\n\n### isomorphism 同构\n\n如果两个图$G = (V,E)$ 和 $G' = (V', E')$ 之间存在一个双射（bijection）函数 $f: V \\rightarrow V'$，使得$ (v_i, v_j) \\in E \\Leftrightarrow (f(v_i),f(v_j)) \\in E' \\text{ for all }v_i,v_j \\in V$，那么这两个图互为同构图（isomorphism）\n\n### subgraph 子图\n\n给定一个图$G$，那么定义这个图的子图$G'=(V', E')$，其中$V'\\subseteq V$并且$E' \\subseteq E$。\n\n## 矩阵相关的概念\n\n### adjacency matrix 邻接矩阵\n\n一个图的邻接矩阵的定义是：$A=\\lbrace a_{ij} \\rbrace$，其中$a_{ij}=e_{ij}$，第$ij$个元素指的是边$e_{ij}$的值。\n\n### incidence matrix 关联矩阵\n\n一个图的关联矩阵定义为：$M=\\lbrace m_{ij} \\rbrace$，其中$m_{ij}$为 1，如果节点$v_i$和边$e_j$相关，举例而言：\n\n![image-20190116204213867](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/GraphKnoledge/image-20190116204213867.png)\n\n的关联矩阵为：\n\n|     | e1  | e2  | e3  | e4  | e5  | e6  |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| v1  |  1  |  1  |  0  |  0  |  0  |  0  |\n| v2  |  0  |  0  |  1  |  1  |  0  |  1  |\n| v3  |  0  |  0  |  0  |  0  |  1  |  1  |\n| v4  |  1  |  0  |  1  |  0  |  0  |  0  |\n| v5  |  0  |  1  |  0  |  1  |  1  |  0  |\n","tags":["Graph Mining","Math","Graph"]},{"title":"CS229：15-Vapnik–Chervonenkis dimension","url":"/blog/2019/01/10/2019-01-10 15-Vapnik-Chervonenkis Dimension/","content":"\n延续上节课的内容。\n\n给定$|\\cal H| = k$，给定$\\delta, \\gamma$，为了保证：\n\n$$\n\\varepsilon({\\hat h}) \\leq \\varepsilon(h) + 2\\gamma\n$$\n\n的概率不小于$1-\\delta$，那么$m$需要满足：\n\n$$\nm \\geq \\frac{1}{2\\gamma^2}\\log \\frac{2k}{\\delta} = O(\\frac{1}{\\gamma^2}\\log \\frac{k}{\\delta})\n$$\n\n假如$\\cal H$是以$d$个实数为参数的(比如为了解决*n*个特征的分类问题，*d*就等于*n+1*)，而在计算机中，实数多以 64 位浮点数保存，d 个实数就需要 64d 位来存储，那么$\\cal H$的整个假设空间大小就为$2^{64d}$，也即$k=2^{64d}$，那么：\n\n$$\nm \\geq O(\\frac{1}{\\gamma^2}\\log \\frac{k}{\\delta}) = O(\\frac{d}{\\gamma^2}\\log \\frac{1}{\\delta})\n$$\n\n最直观的解释就是$m$与假设类的参数数量几乎是成正比的。\n\n---\n\n定义**Shatter（分散）**：给定一个由$d$个点构成的集合：$S=\\lbrace x^{(1)}, \\ldots, x^{(d)} \\rbrace$，我们说一个假设类$\\cal H$能够**分散(shatter)**一个集合$S$，如果$\\cal H$能够实现对$S$的任意一种标记方式，也即，对$S$的任意一种标记方式，我们都可以从$\\cal H$中找到对应的假设来进行分割。\n举例而言，如果${\\cal H} = \\lbrace \\text{linear classification in 2D} \\rbrace$(二维线性分类器的集合)，对于二维平面上的三个点，有 8 种标记方式：\n\n![image-20190111094049430](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-1-11/image-20190111094049430.png)\n\n那么，蓝线所代表的线性分类器，都能完成对它们的标记，所以我们称$\\cal H$能够分散平面上三个点所构成的集合。但是对于平面上四个点，就有存在以下这种情况，没有任何的线性分类器能够实现这种标记：\n\n![image-20190111094649618](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-1-11/image-20190111094649618.png)\n\n---\n\n定义**Vapnik-Chervonenkis dimension（VC 维）**：假设集$\\cal H$的**VC 维**，写成$VC({\\cal H})$，指的是能够被$\\cal H$分散的最大集合的大小。\n举例而言，如果$\\cal H$是所有二维线性分类器构成的集合，那么$VC(\\cal H) = 3$。当然并不是说$\\cal H$要能分散所有三个点构成的集合，只要有某个三个点构成的集合能被$\\cal H$分散即可，比如下面这种标记方式，$\\cal H$就无法实现，但是我们还是称$VC(\\cal H) = 3$。\n\n![image-20190111095306079](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-1-11/image-20190111095306079.png)\n\n有一个推论：\n\n$VC({\\text{linear classification of n D}}) = n + 1$\n\n---\n\n定理：给定假设集合$\\cal H$，令$VC({\\cal H})=d$，那么，对于任意的$h \\in {\\cal H}$：\n\n$$\n|\\varepsilon(h)-{\\hat \\varepsilon}(h)| \\leq O(\\sqrt{\\frac{d}{m} \\log \\frac{m}{d} + \\frac{1}{m} \\log \\frac{1}{\\delta}})\n$$\n\n的概率不小于$1 - \\delta$，以及\n\n$$\n\\varepsilon({\\hat h}) \\leq \\varepsilon(h^\\ast) + 2 \\gamma, \\gamma = O(\\sqrt{\\frac{d}{m} \\log \\frac{m}{d} + \\frac{1}{m} \\log \\frac{1}{\\delta}})\n$$\n\n的概率不小于$1-\\delta​$。\n\n引理：为了保证$\\varepsilon({\\hat h}) \\leq \\varepsilon(h ^ \\ast) + 2 \\gamma$至少在$1 - \\delta$的概率下成立，应该满足：\n\n$$\nm = O_{\\gamma, \\delta}(d)\n$$\n\n$O_{\\gamma, \\delta}(d)$指的是，在固定$\\gamma, \\delta$的情况下，与$d$线性相关。\n\n也即，$m$必须与$\\cal H$的 VC 维保持一致，也可以这么理解，为了使泛化误差和训练误差近似，训练样本数目必须和模型的参数数量成正比。\n\n---\n\n在 SVM 中，给定数据集，如果我们只考虑半径 R 以内的点，以及间隔至少为$\\gamma$的线性分类器构成的假设类，那么：\n\n$$\nVC({\\cal H}) \\leq \\lceil \\frac{R^2}{4\\gamma^2} \\rceil + 1\n$$\n\n也就说明，$\\cal H​$ 的 VC 维上限，并不依赖于数据集中点$x​$的维度，换句话说，虽然点可能位于无限维的空间中，但是如果只考虑那些具有较大函数间隔的分类器所组成的假设类，那么 VC 维就存在上界。\n\n所以 SVM 会自动尝试找到一个具有较小 VC 维的假设类，所以它不会过拟合（模型参数不会过大）\n","tags":["Course Notes","Machine Learning"]},{"title":"动态图overview论文阅读总结","url":"/blog/2019/01/08/2019-01-08 动态图overview论文阅读总结/","content":"\n### NetFork: Mapping Time to Space in Network Visualization\n\n-   Proceedings of the International Working Conference on Advanced Visual Interfaces. ACM 2016\n\nRequirements：\n\n1. Overview of dynamic activity. 动态活动的概览\n2. Change-cause analysis. 分析变化发生原因\n3. Identification of impacted sources. 分辨出有影响的源\n4. Detailed analysis of the temporal evolution of a source-destination path. 对路径的时序演化进行细化分析\n\n其他不是很有参考价值。\n\n### Visualizing a Sequence of a Thousand Graphs (or Even More)\n\n-   EuroVis 2017\n\n文章解决了具有超过 1000 个时间片段的动态图的展示问题。\n\n#### 可视化\n\n1. 每一个时间步的独立编码：\n\n    转换成二部表示，左边的有向图可以被编码成右图的形式，然后利用抛雪球算法（splatting）来减少边相交；\n\n    ![image-20190109101702184](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109101702184.png)\n\n2. 不同时间步的叠加：\n\n    将不同的时间片叠加在一起，但保留一个像素的偏移，最终产生最右边的结果\n\n    ![image-20190109104128274](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109104128274.png)\n\n3. 低通滤波：\n\n    当简单进行叠加时，可能产生下图（a）的结果，边之间有较多的交错；为了使得结果更加平滑，可以使用低通滤波器。不断使用箱型滤波器（box filter）后，就会产生下面（b）（box filter 十次迭代）（c）（box filter 二十次迭代）的结果，边之间的相交更少了，细节变得不可见的同时，一些较大规模的结构也更容易被看到。![image-20190109104342835](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109104342835.png)\n\n4. 每一个时间步的宽度调节\n\n    每一个时间步的宽度较小时，就会变成一条直线；但太大时，屏幕空间要求就会加大，能展示的时间步数量就会下降。\n\n    ​\n\n5. 等高线：\n\n    假如等高线之后，就能更好的描述可见结构的形状。\n\n    ![image-20190109110448825](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109110448825.png)\n\n#### 交互\n\n1. 过滤：多种过滤机制来过滤节点、时间等\n2. 聚合和聚类：对接点进行聚合、聚类等\n3. 细节：corsshair function 来追踪垂直和水平的位置；\n\n#### Patterns\n\n1. 一般的 Pattern\n2. 边 Pattern\n3. 动态 Pattern\n    - repeating patterns\n    - trend patterns\n    - contertrend patterns（逆向的）\n    - temporal shifts\n    - oscillating/alternating patterns\n    - outlier/anomaly patterns\n\n### Let It Flow: a Static Method for Exploring Dynamic Graphs\n\n-   Visualization Symposium (PacificVis) 2014\n\n用于总结动态图中的结构特征的标准有：degree, betweenness, closeness, cluster coefficient\n\n1. 根据节点的结构特征（degree, betweenness, closeness, cluster coefficient 等）为每个时间步的节点排序，多个时间步最终组成一个矩阵（图中的节点颜色表示了节点的类别信息）：\n\n    ![image-20190109141500847](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109141500847.png)\n\n2. 根据节点排序的上升下降来为每个时刻的每个节点生成向量：\n\n    ![image-20190109142010096](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190109142010096.png)\n\n3. 利用 Line Integral Convolution（LIC）将向量渲染成一系列连续的流图（下图 a 至 b）\n\n4. 将相似颜色、相似方向的向量进行合并以加强主要的趋势（下图 c）\n\n5. alpha blending（下图 d）\n\n    ![image-20190110160848832](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190110160848832.png)\n\n### Exploring Evolution of Dynamic Networks via Diachronic Node Embeddings\n\n-   2018TVCG\n\n五个设计目标：\n\nG1. The evolution analysis of the network as a whole. 网络整体的演变分析\n\nG2. The evolution analysis of dynamic nodes. 动态节点的演变分析\n\nG3. The temporal analysis of temporal communities. 动态社团的时序分析\n\nG4. The structural analysis of stable communities. 稳定社团的结构分析\n\nG5. Relate the analysis to the original networks. 将分析关联至原始网络（可以用来验证）\n\n方法：\n\n1. 对每一时间步的每一个节点都做了高维空间嵌入（为了保证每一帧的嵌入结果尺度一致，作者做了一个缩放 Embedding Alignment）\n2. 利用 PCA 将至一维，颜色可以用来编码：时间、节点年龄、节点分类、演变值等等\n3. 这个方法的好处在于，图嵌入方法将至一维后仍然能够很好地将社团聚集在一起\n\n![image-20190111165723729](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190111165723729.png)\n\n### Reducing Snapshots to Points\n\n![image-20190111203134834](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190111203134834.png)\n\n1. Discretization：将事件离散化为多个动态网络\n2. Vectorization & Normalization：将$|V|\\times|V|$的邻接矩阵表达转换为行向量$1 \\times |V|^2$，N 个帧就会形成$N \\times |V|^2$的矩阵，每一行表达一帧，每一列则是一条边随着时间的变化。当然，除了邻接矩阵，其他矩阵也可使用。对这些高维空间的向量进行归一化，比如：Binarization，Min-Max，Z-score 等。\n3. Dimensionality Reduction：先使用了 PCA，但是也可以使用 MDS 和 t-SNE（这两者在欧几里得距离度量下表现较好）。kolmogorov-smirnov test 和 Degree Distribution Quantification and Comparison 可以用于提供两个网络之间的结构比较（距离计算）\n\n![image-20190111204346817](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-13/image-20190111204346817.png)\n","tags":["Visualization","Graph Visualization","Dynamic Graph"]},{"title":"CS229：14-经验风险最小化","url":"/blog/2019/01/05/2019-01-05 14-经验风险最小化/","content":"\n就线性分类模型而言，可以将其表示为：\n\n$$\nh_\\theta(x)=g(\\theta^Tx), \\\\\\\ng(z) = 1\\lbrace z \\geq 0 \\rbrace\n$$\n\n其中，训练集表示为：\n\n$$\nS=\\lbrace (x^{(i)}, y^{(i)}) \\rbrace _ {i = 1} ^ m, (x^{(i)}, y^{(i)}) \\sim {\\cal D}\n$$\n\n这里假设了训练数据都是独立同分布的。\n\n那么，我们认为，这个线性分类器的**训练误差**就可以表示为它分类错误的样本比例：\n\n$$\n{\\hat{\\varepsilon}}(h_\\theta) = {\\hat{\\varepsilon}}_s(h_\\theta) = \\frac{1}{m}\\sum_{i=1}^m1\\lbrace h_\\theta (x^{(i)}) \\neq y^{(i)} \\rbrace\n$$\n\n在这里，我们把训练误差也称为**风险**（risk），由此我们导出了经验风险最小化。\n\n### 经验风险最小化\n\n### Empirical Risk Minimization，ERM\n\n经验风险最小化，最终导出一组参数，能够使得训练误差最小：\n\n$$\n{\\hat{\\theta}} = \\arg \\min {\\hat{\\varepsilon}}_s(h_\\theta)\n$$\n\n我们再定义一个假设类${\\cal{H}} = \\lbrace h_\\theta, \\theta \\in {\\Bbb R}^{n+1} \\rbrace$，它是所有假设的集合。在线性分类中，也就是所有线性分类器的集合。\n\n那么，我们可以重新定义一次 ERM：\n\n$$\n{\\hat h} = \\mathop{\\arg \\min}_{h \\in {\\cal H}} {\\hat \\varepsilon}(h)\n$$\n\n对上述公式的直观理解就是：从假设类中选取一个假设，使得训练误差最小。我们这里用了$\\hat{h}$表示估计，因为毕竟不可能得到最好的假设，只能得到对这个最好的假设的估计。\n\n但这仍然不是目标，我们的目标是使得**泛化误差 Generalization Error**最小化，也即新的数据集上分类错误的概率：\n\n$$\n\\varepsilon(h)=P_{(x,y) \\sim {\\cal D}}(h(x) \\neq y)\n$$\n\n接下去，为了证明：\n\n-   （1）${\\hat \\varepsilon} \\approx \\varepsilon$，训练误差近似于泛化误差（理解为，泛化误差和训练误差之间的差异存在上界）\n\n-   （2）ERM 输出的泛化误差$\\varepsilon({\\hat h})$存在上界；\n\n我们引出两个引理：\n\n-   联合界引理（Union Bound）\n\n    > $A_1, A_2, \\ldots , A_k$是 k 个事件，他们之间并不一定是独立分布的，有：\n    >\n    > $$\n    > P(A_1 \\cup \\ldots \\cup A_k) \\leq P(A_1) + \\dots + P(A_k)\n    > $$\n\n-   Hoeffding 不等式（Hoeffding Inequality）\n\n    > $z_1, \\ldots z_m$是 m 个 iid（independent and identically distribution，独立同分布），他们都服从伯努利分布，$P(z_i=1) = \\phi$，那么对$\\phi$的估计：\n    >\n    > $$\n    > {\\hat \\phi} = \\frac{1}{m}\\sum_{i=1}^m z_i\n    > $$\n    >\n    > 于是，给定$\\gamma > 0$，有：\n    >\n    > $$\n    > P(|{\\hat{\\phi}} - \\phi| > \\gamma) \\leq 2 exp(-2\\gamma^2m)\n    > $$\n\n    Hoeffding 不等式的直观解释就是，下图中的阴影面积，会有上界。\n\n    ![image-20190106143941030](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-06/image-20190106143941030.png)\n\n### 一致收敛\n\n### Uniform Conversions\n\n对于某个$h_j \\in \\cal{H}$，我们定义$z_i = 1 \\lbrace h_j(x^{(i)}) \\neq y^{(i)}\\rbrace \\in \\lbrace{}$为第 i 个样本被分类错误的指示函数的值，对于 logistic 而言，它服从伯努利分布。\n\n那么：\n\n1. 泛化误差：$P(z_i=1) = \\varepsilon(h_j)$\n2. 训练误差：${\\hat{\\varepsilon}}(h_j) = \\frac{1}{m}\\sum_{i=1}^m z_i$\n\n根据 Hoeffding 不等式，我们能够得到：\n\n$$\nP(|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| > \\gamma) \\leq 2e^{-2\\gamma^2m}\n$$\n\n接着，我们定义训练误差和泛化误差之间的差大于$\\gamma$（$|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| > \\gamma$）为事件$A_j$，根据以上结论，我们可知：\n\n$$\nP(A_j) \\leq 2e^{-2\\gamma^2m}\n$$\n\n那么根据联合界引理：\n\n$$\n\\begin{array}{l}\n& P(\\exists h_j \\in H, |{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| > \\gamma) \\\\\\\n= & P(A_1 \\cup A_2 \\cup \\ldots \\cup A_k) \\\\\\\n\\leq & \\sum_{i=1}^k P(A_i) \\\\\\\n\\leq & \\sum_{i=1}^k 2e^{-2\\gamma^2m} \\\\\\\n= & 2ke^{-2\\gamma^2m}\n\\end{array}\n$$\n\n可以表述为：存在$h_j$使$|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| > \\gamma$的概率$\\leq 2ke^{-2\\gamma^2m}$。\n\n等价于：不存在$h_j$使$|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| > \\gamma$的概率$\\geq 1 - 2ke^{-2\\gamma^2m}$。\n\n等价于：$\\cal H$中任意的$h_j$使得$|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| \\leq \\gamma$的概率$\\geq 1 - 2ke^{-2\\gamma^2m}$。\n\n我们将上面这个结论称之为**一致收敛 Uniform Conversions**，也就是说事实上，所有的假设，训练误差和泛化误差之间都存在上界。\n\n### 样本复杂度，误差界以及偏差方差权衡\n\n上面的结论，我们可以引出以下的一些推论：\n\n#### 样本复杂度 Sample Complexity\n\n给定$\\gamma, \\delta$，需要多大的训练集合（$m$）？其中$\\delta$指的是泛化误差和训练误差之差大于$\\gamma$的概率。\n\n我们知道，$\\delta \\leq 2ke^{-2\\gamma^2m}$，可求解：\n\n$$\nm \\geq \\frac{1}{2 \\gamma ^ 2} log(\\frac{2k}{\\delta})\n$$\n\n这个，也被称为样本复杂度（类似于时间复杂度），指的是，只要满足上面这个条件，任意$h \\in \\cal H$，都能得到$|{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| \\leq \\gamma$\n\n#### 误差界 Error Bound\n\n给定$\\delta, m$时，我们会得到多大的误差上界$\\gamma$。\n\n经过求解可以得到：\n\n$$\nP(\\forall h \\in {\\cal H}, |{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| \\leq \\sqrt{\\frac{1}{2m}log(\\frac{2k}{\\delta})}) \\geq 1 - \\delta\n$$\n\n也就是误差上界是：$\\gamma = \\sqrt{\\frac{1}{2m}log(\\frac{2k}{\\delta})}$。\n\n### 偏差方差权衡 Bias Variance Tradeoff\n\n我们定义：\n\n$$\n\\begin{align}\n{\\hat h} &= \\mathop{\\arg \\min}_{h \\in \\cal H} {\\hat \\varepsilon}(h) \\text{, 使得训练误差最小的h}\n&\\tag{1} \\\\\\\nh^\\ast &= \\mathop{\\arg \\min}_{h \\in \\cal H} \\varepsilon(h) \\text{, 使得泛化误差最小的h} \\tag{2}\n\\end{align}\n$$\n\n假如：\n\n$$\n\\forall h \\in {\\cal H}, |{\\hat{\\varepsilon}}(h_j) - \\varepsilon(h_j)| \\leq \\gamma \\tag{3}\n$$\n\n那么：\n\n$$\n\\begin{align}\n\\varepsilon(\\hat h) &\\leq {\\hat \\varepsilon}({\\hat h}) + \\gamma, &\\text{derived from (3)}\\\\\\\n&\\leq {\\hat \\varepsilon}(h^\\ast) + \\gamma, &\\text{derived from (1)}\\\\\\\n&\\leq {\\varepsilon(h^\\ast)} + \\gamma + \\gamma, &\\text{ derived from (3)}\n\\end{align}\n$$\n\n于是，我们得到如下定理：\n\n给定大小为$k$的假设集合$\\cal H$，给定$m, \\delta$，那么：\n\n$$\n\\varepsilon(\\hat h) \\leq \\underbrace{(\\min_{h \\in {\\cal H}}\\varepsilon(h))}_{\\varepsilon(h^\\ast)} + 2 \\underbrace{\\sqrt{\\frac{1}{2m}log(\\frac{2k}{\\delta})}}_{\\gamma}\n$$\n\n的概率不低于$1-\\delta$。\n\n可以想象，为了得到最佳的假设$h^\\ast$，我们尽可能增大$\\cal H$（能够减小$\\varepsilon(h^\\ast)$），但随之而来的就是$\\gamma$的增大，所以需要在这两者之间进行权衡，我们指的就是**偏差方差权衡 Bias Variance Tradeoff**。\n\n![image-20190106154201189](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/19-01-06/image-20190106154201189.png)\n\n由此，我们得到一个推论：\n\n给定$\\delta, \\gamma$，为了能够保证$\\varepsilon(\\hat h) \\leq (\\min_{h \\in {\\cal H}}\\varepsilon(h)) + 2\\gamma$的概率不小于$1-\\delta$（ERM 得到的假设的一般误差，与最佳假设的一般误差之间，差值不大于$2\\gamma$）\n\n我们需要保证：\n\n$$\nm \\geq \\frac{1}{2\\gamma^2}log(\\frac{2k}{\\delta})\n$$\n","tags":["Course Notes","Machine Learning"]},{"title":"redux浅析","url":"/blog/2018/12/04/2018-12-04 redux浅析/","content":"\n读完了胡子大哈的[React.js 小书](http://huziketang.mangojuice.top/books/react/)后，总结一下对 redux 的新理解吧，主要是 store，connect，reducer，provider 等内容的一些浅见。\n\nredux 的出现，事实上为了解决状态管理的问题。最直接的问题就是，如何在各个组件之间共享状态（即组件间通讯）。\n\n#### Provider\n\nredux 应对上述问题的解决方案，就是将这些需要共享的状态放置在根组件的[context](http://huziketang.mangojuice.top/books/react/lesson29)中（类似于全局变量），其子组件都能获取到 context。\n\n具体的做法，其实是将 Index 组件（根组件）包装成 Provider 组件：\n\n```jsx\nexport class Provider extends Component {\n  static propTypes = {\n    store: PropTypes.object,\n    children: PropTypes.any,\n  };\n\n  static childContextTypes = {\n    store: PropTypes.object,\n  };\n\n  getChildContext() {\n    return {\n      store: this.props.store,\n    };\n  }\n\n  render() {\n    return <div>{this.props.children}</div>;\n  }\n}\n```\n\n这个 Provider 组件，为整个组件树添加了 store，任何子组件都能获取到 store\n\n```jsx\n<Provider store={store}>\n  <Index />\n</Provider>\n```\n\n#### Store\n\nstore 算是组件的状态管理器，也是整个 redux 的核心。\n\n```javascript\nfunction createStore(reducer) {\n  let state = null;\n  const listeners = [];\n  const subscribe = (listener) => listeners.push(listener);\n  const getState = () => state;\n  const dispatch = (action) => {\n    state = reducer(state, action);\n    listeners.forEach((listener) => listener());\n  };\n  dispatch({});\n  return {\n    getState,\n    dispatch,\n    subscribe,\n  };\n}\n```\n\nstore 做的事情包括以下三件：\n\n1. getState：用于获取当前的状态\n2. dispatch：修改状态（reducer），并将事件分发给所有监听器\n3. subscribe：订阅事件，用它来增加新的监听器\n\n#### Reducer\n\nreducer 由用户自己定义，有两个参数，前者是老状态，后者是一个 action。\n\n它做的事情仅仅是：**初始化和计算新的 state**；根据 action 的信息，reducer 修改对应的状态，并返回一个新状态（全新的对象，而不是在老对象上修改）。\n\n举个书中的例子：\n\n```javascript\nconst themeReducer = (state, action) => {\n  if (!state)\n    return {\n      themeColor: \"red\",\n    };\n  switch (action.type) {\n    case \"CHANGE_COLOR\":\n      return { ...state, themeColor: action.themeColor };\n    default:\n      return state;\n  }\n};\n```\n\nreducer，按照规定，应该是一个[纯函数](http://huziketang.mangojuice.top/books/react/lesson32)。\n\n#### Connect\n\nconnect 从本质上讲，是一个[高阶组件](http://huziketang.com/books/react/lesson28)，它的作用可以理解为：\n\n1. 子组件通过 connect 成为高阶组件后，其内部不用再去对 context 进行读写（降低依赖性）\n2. 经过 connect 后，从 context 的 store 里面读取到的 state/dispatch/props，将会统一以 props 的状态传入子组件\n\n```jsx\nexport const connect = (mapStateToProps, mapDispatchToProps) => (\n  WrappedComponent\n) => {\n  class Connect extends Component {\n    static contextTypes = {\n      store: PropTypes.object,\n    };\n\n    constructor() {\n      super();\n      this.state = {\n        allProps: {},\n      };\n    }\n\n    _updateProps() {\n      const { store } = this.context;\n      let stateProps = mapStateToProps\n        ? mapStateToProps(store.getState(), this.props)\n        : {}; // 防止 mapStateToProps 没有传入\n      let dispatchProps = mapDispatchToProps\n        ? mapDispatchToProps(store.dispatch, this.props)\n        : {}; // 防止 mapDispatchToProps 没有传入\n      this.setState({\n        allProps: {\n          ...stateProps,\n          ...dispatchProps,\n          ...this.props,\n        },\n      });\n    }\n\n    componentWillMount() {\n      const { store } = this.context;\n      this._updateProps();\n      store.subscribe(() => this._updateProps());\n    }\n\n    render() {\n      return <WrappedComponent {...this.state.allProps} />;\n    }\n  }\n\n  return Connect;\n};\n```\n","tags":["FrontEnd","React"]},{"title":"dyngraph2vec, Capturing Network Dynamics using Dynamic Graph Representation Learning","url":"/blog/2018/11/26/2018-11-26 dyngraph2vec/","content":"\n# dyngraph2vec:Capturing Network Dynamics using Dynamic Graph Representation Learning\n\n-   论文原文：[dyngraph2vec: Capturing Network Dynamics using Dynamic Graph Representation Learning](https://arxiv.org/pdf/1809.02657.pdf)\n-   作者：Goyal, Palash, Sujit Rokka Chhetri, and Arquimedes Canedo\n-   发表刊物/会议： arXiv\n\n## 方法\n\n### 问题陈述\n\n-   图：$G(V, E)$\n-   动态图：$\\mathcal{G}={G_1,...,G_T}$\n-   目标：将一个节点，通过学习一个映射方法：$f_t=\\lbrace V_1,...,V_t,E_1,...,E_t\\rbrace \\to \\Bbb{R}^d$转换为一组低维向量：$y_{v_1},...,y_{v_t}$，其中$y_{v_i}=f_i(V_1,...,V_i,E_1,...,Ei)$，是一个 d 维的向量，捕获了$1-i$时刻的图动态变换。\n\n#### dyngraph2vec\n\ndyngraph2vec 是一个深度学习模型，输入前面几个时间片段的图，即可输出下一个时刻的图。\n\n模型通过优化下面这个损失函数，来学习时刻$t$的图嵌入（network embedding，即其向量表达）。\n\n$$\n\\begin{aligned}\nL_{t+1} &= \\parallel (\\hat{A_{t+l+1}}-A_{t+l+1})\\odot \\mathcal{B} \\parallel^2_F \\\\\\\n&= \\parallel (f(A_t,...,A_{t+l}) - A_{t+l+1}) \\odot \\mathcal{B}\\parallel ^2_F\n\\end{aligned}\n$$\n\n其中，A 表示图的邻接矩阵，$f$函数用来计算$\\hat{A}$，也就是对$t+l+1$时刻的图的邻接矩阵的估计。\n\n$\\mathcal{B}$是惩罚项，$\\mathcal{B}_{ij}=\\beta, for (i,j) \\in E_{t+l+1}, else 1$。\n\n$\\odot​$表示一种矩阵的布尔运算，具体定义可以在这个[pdf](https://www.math.fsu.edu/~pkirby/mad2104/SlideShow/s5_4.pdf)里面找一下（https://www.math.fsu.edu/~pkirby/mad2104/SlideShow/s5_4.pdf），不再详述。\n\n文章使用的深度学习模型有如下三种：$dyngraph2vecAE, dyngraph2vecRNN, dyngraph2vecAERNN$。\n\n![image-20181126170553492](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181126170553492.png)\n\n我们可以看到，这三种方法都分成两个步骤，Deep encoders 的目的，是输入动态的邻接矩阵，为每个节点生成低维向量；Deep decoders 则可以根据低维向量，来生成下一时刻的预测图。\n","tags":["Graph Mining","Graph Embedding","Dynamic Graph"]},{"title":"The State of the Art in Visualizing Dynamic Graphs","url":"/blog/2018/11/16/2018-11-16 The State of the Art in Visualizing Dynamic Graphs 2014/","content":"\n# The State of the Art in Visualizing Dynamic Graphs\n\n-   论文原文：The State of the Art in Visualizing Dynamic Graphs\n-   作者：Fabian Beck, Michael Burch, Stephan Diehl, and Daniel Weiskopf\n-   发表刊物/会议： Eurographics Conference on Visualization (EuroVis2014)\n\n论文前半部分讲其如何收集数据，如何进行分类等等，就不再细述，直接从介绍方法开始。\n\n有个表格比较有意思，这里展示一下：\n\n| 类型                | 论文类型                             |\n| ------------------- | ------------------------------------ |\n| application（应用） | 讲动态图可视化方法应用于某个特定领域 |\n| evaluation（评估）  | 系统，理论地对可视化方法进行评估     |\n| technique（技术）   | 新颖的可视化技术或系统               |\n\n| 时间表达方法       |                                                 |\n| ------------------ | ----------------------------------------------- |\n| animation（动画）  | 利用动画来映射不同的时间                        |\n| timeline（时间轴） | 将时间映射到时间轴上的空间                      |\n| generic（一般）    | being applicable to all representations of time |\n\n| 图的表达方法          |                                               |\n| --------------------- | --------------------------------------------- |\n| node-link（节点链接） | 用链接连起来的节点                            |\n| matrix（矩阵）        | 邻接矩阵                                      |\n| generic（一般）       | being applicable to all graph representations |\n\n| 评估        | 评估的类型                           |\n| ----------- | ------------------------------------ |\n| algorithmic | 用指标来算法性的评估表达方法         |\n| case_study  | 用一些应用案例来进行讨论             |\n| none        | 没有                                 |\n| user_study  | 通过其他用户来进行用户实验           |\n| expert      | 通过其他领域或者可视化专家来评价方法 |\n| survey      | 相关工作的调研                       |\n| theoretical | 证明或者是运行时间复杂度的理论考察   |\n\n| 应用                 |                                                                                                        |\n| -------------------- | ------------------------------------------------------------------------------------------------------ |\n| biology              | bioinformatics data such as protein interactions or<br/>metabolic pathways                             |\n| business             | business- or economy-related data such as financial<br/>transactions, stock market, business processes |\n| document             | document collections, bibliometrics, and information re-<br/>trieved from texts                        |\n| eye_tracking         | data recorded during eye-tracking experiments                                                          |\n| infrastructure       | infrastructure networks such as computer, communica-<br/>tion, power, or road networks                 |\n| media                | data related to movies, TV, music, news and the like                                                   |\n| social               | social networks, social media, and other data from social<br/>life                                     |\n| software_engineering | information related software such as components, source<br/>code, developers, documentation, etc.      |\n| sports               | sports-related data such as performance data or results                                                |\n| generic              | no specific application suggested                                                                      |\n\n## Animation（动画）\n\n### 一般布局（General-Purpose Layout）\n\n一般可以分为 online 和 offline 两种大类，online 的表示只考虑过去的 time step，来计算当前的布局；而 offline 则考虑了过去跟未来的，能够维持更好的 mental map。\n\n#### Online Problem\n\n一开始这个问题始于 交互，因为在进行交互的时候，过去的时间片段已知，而未来的时间片段仍然是未知的。\n\n-   【MISUE K., EADES P., LAI W., SUGIYAMA K.: Layout adjustment and the mental map. Journal of Visual Languages & Computing 6, 2 (1995), 183–210. 】：**解决图编辑以及节点重叠的问题：让力引导算法要保持节点之间初始的垂直和水平位置的顺序。**\n-   【BRANDES U., WAGNER D.: A Bayesian paradigm for dynamic graph layout. In Graph Drawing (1997), GD, Springer, pp. 236–247.】：**用贝叶斯决策理论（Bayesian decision theory）来描述问题：在出初始布局上考虑可读性（readability model）以及考虑后面的布局与初始布局之间的差距，即稳定性（stability model）**\n-   【LEE Y.-Y., LIN C.-C., YEN H.-C.: Mental map preserving graph drawing using simulated annealing. In Proceedings of the 2006 Asia-Pacific Symposium on Information Visualisation (2006), APVis, Australian Computer Society, Inc., pp. 179–188】：**将这个问题考虑成一个优化问题，模拟退火算法，针对有权图。**\n-   【GOROCHOWSKI T. E., DI BERNARDO M., GRIERSON C. S.: Using aging to visually uncover evolutionary processes on networks. IEEE Transactions on Visualization and Computer Graphics 18, 8 (2012), 1343–1352.】：**引入节点年龄（node age）的概念来保持布局**\n-   【FRISHMAN Y., TAL A.: Online dynamic graph drawing. IEEE Transactions on Visualization and Computer Graphics 14, 4 (2008), 727–740】**利用了 GPU 进行了加速布局计算**\n-   HAYASHI A., MATSUBAYASHI T., HOSHIDE T., UCHIYAMA T.: Initial positioning method for online and real-time dynamic graph drawing of time varying data. In Proceedings of the 17th International Conference on Information Visualisation (2013), IV, pp. 435–444.】：**调研了初始节点位置对布局算法的影响**\n\n#### Offline Problem\n\n首先需要明白一个 super-graph 的概念，存在时间越长的边，会在 super-graph 中拥有更高的权重。\n\n![image-20181115111357623](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115111357623.png)\n\n-   【DIEHL S., GÖRG C., KERREN A.: Preserving the mental map using foresighted layout. In Proceedings of the 3rd Joint Eurographics–IEEE TCVG Conference on Visualiza- tion (2001), VisSym, Eurographics Association, pp. 175–184.】：**提出了 foresighted layout 算法，将不活跃的节点聚集在一起，然后再构建 super-graph。**\n-   【DIEHL S., GÖRG C.: Graphs, they are changing – dynamic graph drawing for a sequence of graphs. In Graph Draw- ing, GD. Springer-Verlag, 2002, pp. 23–31.】：**引入了 Tolerance 的概念，允许一定程度的偏移，可以为每一帧的布局继续用力引导做优化**\n-   【ERTEN C., HARDING P. J., KOBOUROV S. G., WAMPLER K., YEE G.: GraphAEL: Graph animations with evolving layouts graph drawing. In Graph Drawing, GD. Springer, 2004, pp. 98–110.】：**相同的节点用虚拟边相连，并忽略来自不同帧的相同节点之间的斥力。**\n-   【BAUR M., SCHANK T.: Dynamic Graph Drawing in Visone. Tech. rep., Fakultät für Informatik, Universität Karlsruhe, 2008.】：**引入了能量因子（energy factors）的概念，相同的节点之间的位置距离越远，能量越高，目标是最小化能量。**\n-   【FENG K.-C., WANG C., SHEN H.-W., LEE T.-Y.: Coherent time-varying graph drawing with multifocus+context interaction. IEEE Transactions on Visualization and Computer Graphics 18, 8 (2012), 1330–1342.】：**可以选择多个焦点，聚焦的焦点以及他们的邻域都会被放大。**\n\n#### Transition Problem\n\n因为动画过程中，经常会在同一时间内发生太多的变化，用户难以追踪。\n\n-   【HUANG M. L., EADES P., WANG J.: On-line animated visualization of huge graphs using a modified spring algorithm. Journal of Visual Languages & Computing 9, 6 (1998), 623–645.】：**当聚焦到一个节点上的时候，这个节点会被转到中间，然后节点再消失和出现。**\n\n-   【FRIEDRICH C., EADES P.: The Marey graph animation tool demo. In Graph Drawing (2001), GD, Springer, pp. 396–406.】：**将整个过程分成四个阶段：1. 需要消失节点和边消失掉；2. 布局进行转换；3. 单独的那些节点被转换到新的位置上；4. 新增节点和边**\n\n-   【FRIEDRICH C., HOULE M. E.: Graph drawing in motion II. In Graph Drawing (2002), GD, Springer, pp. 220–231.】：**对上述的工作进行了扩展，节点进行了聚类，然后再一起运动**\n\n-   【NESBITT K. V., FRIEDRICH C.: Applying gestalt princi- ples to animated visualizations of network data. In Proceedings of the 6th International Conference on Information Visualisation (2002), IV, IEEE, pp. 737–743.】：**推荐用 Gestalt laws 来捕获/组织运动过程**\n\n-   【LOUBIER E., DOUSSET B.: Temporal and relational data representation by graph morphing. Safety and Reliability for Managing Risk 14, 02 (2008), 2008–16.】：（**对不起没读懂，大概讲的是在变化为上一帧布局变换到下一帧的时候，先对齐到 super-graph，以维护 mental map**）a super-graph layout is computed with nodes in the same time step attracted to a specific position; for the transition between two time steps, the graph is first morphed to the super-graph to recalibrate the mental map, before the super-graph is further transformed into the layout of the next time-step.\n\n-   【HURTER C., ERSOY O., FABRIKANT S., KLEIN T., TELEA A.: Bundled visualization of dynamic graph and trail data. IEEE Transactions on Visualization and Computer Graph- ics (2013).】：**假如节点位置固定，则可以利用 edge bundling 的方法来展示边的变化。**\n\n    ![Nov-15-2018 15-09-00](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/Nov-15-2018 15-09-00.gif)\n\n-   【BACH B., PIETRIGA E., FEKETE J.-D.: GraphDiaries: Animated transitions and temporal navigation for dynamic networks. IEEE Transactions on Visualization and Computer Graphics 20, 5 (2014), 740–754.】：**类似上面的，但是会高亮那些移除的活着新增的元素。**\n\n    ![Nov-15-2018 15-24-12](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/Nov-15-2018 15-24-12.gif)\n\n### 特殊目的布局（special-purpose layout）\n\n#### Compound Graph（复合图）\n\n动态复合图的布局，需要在不同时刻追踪聚类，不仅要保持布局稳定，也要保持聚类的稳定。\n\n-   【FRISHMAN Y., TAL A.: Dynamic drawing of clustered graphs. In Proceedings of the 2004 IEEE Symposium on Infor- mation Visualization (2004), InfoVis, IEEE, pp. 191–198.】：一种 online 的方法，在聚类外面绘制盒子，保证节点在该范围内。（下图上面是不加该方法的布局，下图是加入了文章的方法）\n\n    ![image-20181115153232857](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115153232857.png)\n\n-   【[KG06] KUMAR G., GARLAND M.: Visual exploration of com- plex time-varying graphs. IEEE Transactions on Visualization and Computer Graphics 12, 5 (2006), 805–812.】：针对 3D 图，画上气泡来表达复合的结构。\n\n    ![image-20181115153635432](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115153635432.png)\n\n-   【POHL M., BIRKE P.: Interactive exploration of large dynamic networks. In Proceedings of the 10th Inter- national Conference on Visual Information Systems (2008), VISUAL, Springer-Verlag, pp. 56–67.】：是对 foresighted layout 的一种扩展，做了一个个嵌套的盒子。\n\n    ![image-20181115155535509](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115155535509.png)\n\n-   【REITZ F., POHL M., DIEHL S.: Focused animation of dynamic compound digraphs. In Proceedings of the 13th Interna- tional Conference on Information Visualisation (2009), IV, IEEE Computer Society, pp. 679–684】：**利用层次结构，折叠不变的结构，使得动画更加清楚。**\n\n-   【LIN Y.-R., SUN J., CAO N., LIU S.: ContexTour: Contextual contour visual analysis on dynamic multi-relational clustering. In Proceedings of the 2010 SIAM International Con- ference on Data Mining (2010), SDM, pp. 418–429.】：**用不同颜色的 contour map 来表示不同的聚类。**\n\n    ![image-20181115161137542](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115161137542.png)\n\n-   【MASHIMA D., KOBOUROV S., HU Y.: Visualizing dynamic data with maps. IEEE Transactions on Visualization and Computer Graphics 18, 9 (2012), 1424–1437.】【HU Y., KOBOUROV S. G., VEERAMONI S.: Embed- ding, clustering and coloring for dynamic maps. In Proceedings of the 2012 IEEE Pacific Visualization Symposium (2012), Paci- ficVis, IEEE Computer Society, pp. 33–40.】：**是对上述算法的拓展，用空间填充的方法来绘制。**\n\n    ![image-20181115161453296](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115161453296.png)\n\n-   【ABELLO J., HADLAK S., SCHUMANN H., SCHULZ H.-J.: A modular degree-of-interest specification for the vi- sual analysis of large dynamic networks. IEEE Transactions on Visualization and Computer Graphics 20, 3 (2013), 337–350.】：**当用户分析图的某一部分的细节时，利用 DOI 方法对其他部分进行聚类。**\n\n    ![image-20181115161728559](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115161728559.png)\n\n#### Other\n\n针对 planar graph 和 acyclic graph，不再细述。\n\n---\n\n## Timeline（时间到空间的映射）\n\n能提供整体的视角，但因为每个图的空间都缩小了，会降低可读性。在这种方法下，scalability 时主要挑战。\n\n### 基于节点链接的方法（Node-Link-Based）\n\n#### Juxtaposed（并列）\n\n存在的问题：\n\n1. 相邻两帧之间差距不大，不便观察\n2. 难以追踪某个特定节点\n3. 每幅图都太小，以至于会有杂乱\n\n![image-20181115173957261](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181115173957261.png)\n\n-   【GREILICH M., BURCH M., DIEHL S.: Visualizing the evolution of compound digraphs with TimeArcTrees. Computer Graphics Forum 28, 3 (2009), 975–982.】：**将节点摆放在水平线上，以便追踪，但可读性比较差，如上图最左边。**\n-   【BURCH M., VEHLOW C., BECK F., DIEHL S., WEISKOPF D.: Parallel Edge Splatting for scalable dynamic graph visualization. IEEE Transactions on Visualization and Computer Graphics 17, 12 (2011), 2344–2353.】：**提出了一种新方法：Parallel Edge Splatting，如 上图中间，它将垂直排列的图人为的分成二部图，这个二部图中边的方向都是从左向右的。**\n-   【BURCH M., BECK F., WEISKOPF D.: Radial Edge Splatting for visualizing dynamic directed graphs. In Proceed- ings of the 4th International Conference on Information Visu- alization Theory and Applications (2012), IVAPP, SciTePress, pp. 603–612】：**是对 Parallel Edge Splatting 的一种圆形的拓展。**\n-   【BURCH M., FRITZ M., BECK F., DIEHL S.: Time- SpiderTrees: A novel visual metaphor for dynamic compound graphs. In Proceedings of the IEEE Symposium on Visual Lan- guages and Human-Centric Computing (2010), VL/HCC, IEEE, pp. 168–175.】：**将 node-link 方法转换到嵌套的圆形中，如上图右边，但并不会画出所有的边，只会画一部分。**\n-   【FARRUGIA M., HURLEY N., QUIGLEY A.: Exploring temporal ego networks using small multiples and tree-ring layouts. In Proceedings of the 4th International Conference on Ad- vances in Computer-Human Interactions (2011), ACHI, pp. 79– 88.】**使用了一种相似的布局方法来表达 ego-centered 的动态图**\n\n#### Superimposed（重叠的）\n\n重叠的画法，需要节点在相同的位置，并且不同时间的边应该有不同的样式。将多个 2D 的图堆叠起来就会形成 3D，但这些堆叠的图层是离散的，故而只能说成是 2.5D。\n\n-   【DWYER T., EADES P.: Visualising a fund manager flow graph with columns and worms. In Proceedings of the 6th In- ternational Conference on Information Visualisation (2002), IV, IEEE, pp. 147–152.】：**在不可见的 2D 平面上放置 3D 圆柱体。**\n\n    ![image-20181116091643871](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116091643871.png)\n\n-   【BRANDES U., CORMAN S. R.: Visual unrolling of network evolution and the analysis of dynamic discourse. In- formation Visualization 2, 1 (2003), 40–50.】：**跟上者类似，放置 3D 的圆柱体代表节点，用一些半透明的平面来表达图层，下图左。**\n\n    ![image-20181116091729780](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116091729780.png)\n\n-   【ERTEN C., KOBOUROV S. G., LE V., NAVABI A.: Si- multaneous graph drawing: Layout algorithms and visualization schemes. In Graph Drawing (2004), GD, Springer, pp. 437–449.】：**如上图右，允许节点有不同的位置，他们使用了一种改进的李引导算法，使得节点大致保持同一位置，以保留 mental map。**\n\n-   【GROH G., HANSTEIN H., WÖRNDL W.: Interactively visualizing dynamic social networks with DySoN. In Proceedings of the 2009 Workshop on Visual Interfaces to the Social and the Semantic Web (2009), VISSW.】：**拓展上述方法，将上图右边的虚拟的虚线，以管状进行绘制。**\n\n    ![image-20181116100226178](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116100226178.png)\n\n#### Integrated（集成）\n\n在集成图里面，时间轴会被加入到节点链接图里面，那么，在不破坏布局的情况下，不同时间片段的图就不可能被单独抽离。\n\n![image-20181116103251163](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116103251163.png)\n\n-   【REITZ F.: A framework for an ego-centered and time-aware visualization of relations in arbitrary data reposito- ries. arXiv preprint arXiv:1009.5183 (2010).】：**在 ego networks 上，将时间轴编码到边上，边的权重演变被编码成分段的颜色，故而每条边都是一个独立的时间轴，上图左。**\n-   【SHI L., WANG C., WEN Z.: Dynamic network visualization in 1.5D. In Proceedings of the 2011 IEEE Pa- cific Visualization Symposium (2011), PacificVis, pp. 179–186.】：**针对 ego network，将中心节点变成时间轴，每当新的边出现的时候，将它们按照时间书序依次连接到中心的时间轴上，上图中。**\n-   【VAN DEN ELZEN S., HOLTEN D., BLAAS J., VAN WIJK J.: Dynamic network visualization with extended massive sequence views. IEEE Transactions on Visualization and Computer Graphics (2013).】：**针对边代表瞬时事件的图（也即这些事件并不会持续一段时间），提出 Extended Massive Sequence Views，事件被绘制在水平线上，节点则被排列在垂直线上，如上图右。**\n\n### 基于矩阵的方法（Matrix-Based）\n\n#### 单元内部的时间轴（Intra-Cell Timelines）\n\n每一个单元格都会抱憾一条独立的时间轴。有很多不同的时间轴表达方法，如下图所示。\n\n![image-20181116131911711](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116131911711.png)\n\n-   【BURCH M., SCHMIDT B., WEISKOPF D.: A matrix-based visualization for exploring dynamic compound digraphs. In Proceedings of the 17th International Conference Information Visualisation (2013), IV, IEEE, pp. 66–73.】&【YI J. S., ELMQVIST N., LEE S.: TimeMatrix: Analyzing temporal social networks using interactive matrix-based visualizations. International Journal of Human-Computer In- teraction 26, 11-12 (2010), 1031–1051.】：**直接放置了一条水平的 bar chart，如上图左。**\n\n-   【BURCH M., SCHMIDT B., WEISKOPF D.: A matrix-based visualization for exploring dynamic compound digraphs. In Proceedings of the 17th International Conference Information Visualisation (2013), IV, IEEE, pp. 66–73.】：**在矩阵边上放置层次结构，从而来表达一个动态的复合图。**\n\n    ![image-20181116132732275](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116132732275.png)\n\n-   【YI J. S., ELMQVIST N., LEE S.: TimeMatrix: Analyzing temporal social networks using interactive matrix-based visualizations. International Journal of Human-Computer In- teraction 26, 11-12 (2010), 1031–1051.】：**节点是聚合后的时间轴，不同的边类型就用不同的颜色进行编码。**\n\n-   【BRANDES U., NICK B.: Asymmetric relations in longitudinal social networks. IEEE Transactions on Visualization and Computer Graphics 17, 12 (2011), 2283–2290.】：**利用叫做 Gestaltlines 的表达方法，使用了堆叠的线条，线条的角度，左面长度和右面长度可以来编码三种不同的指标，如上上图的中间部分。**\n\n-   【STEIN K., WEGENER R., SCHLIEDER C.: Pixel-oriented visualization of change in social networks. In Proceedings of the 2010 International Conference on Advances in So- cial Networks Analysis and Mining (2010), ASONAM, IEEE, pp. 233–240.】：**建议了一种 pixel-based 的方法（基于像素图），将时间轴折叠成为像素图。每一个像素（或者说一个单元）表达时间上的一个点，用来编码当前时间片段的边的权重。文章还提到了几种折叠时间轴的方法：row-by-row, column-by-column, diagonal, etc.**\n\n    ![image-20181116134654857](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116134654857.png)\n\n#### 分层矩阵（Layered Matrixed）\n\n![image-20181116134937923](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116134937923.png)\n\n-   【BURCH M., DIEHL S.: TimeRadarTrees: Visualizing dynamic compound digraphs. Computer Graphics Forum 27, 3 (2008), 823–830.】&【BURCH M., HÖFERLIN M., WEISKOPF D.: Layered TimeRadarTrees. In Proceedings of the 15th International Conference on Information Visualisation (2011), IV, IEEE, pp. 18– 25.】：**将边和边之间的关系以环形编码到圆上，如下图左边的大圆，红色部分表示有边链接到该节点，小圆则表示有边从该节点出去。圆形的径向则是时间轴，也即上图第二图所示（radially distributtd）**\n\n    ![image-20181116141532045](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116141532045.png)\n\n-   【VEHLOW C., BURCH M., SCHMAUDER H., WEISKOPF D.: Radial layered matrix visualization of dynamic graphs. In Proceedings of the 17th International Conference Information Visualisation (2013), IV, pp. 51–58.】：**弯折矩阵变成圆环，每一个圆环都代表一个时刻，上上图 radially layered。**\n-   【BACH B., PIETRIGA E., FEKETE J.-D.: Visualizing dynamic networks with matrix cubes. In Procceedings of the SICCHI Conference on Human Factors in Computing Systems (2014), CHI.】**将 2D 的图堆叠成 3D 的，上上图 stacked。**\n\n---\n\n## Hybrid (Animation, Timeline)（对动画跟时间轴的混合）\n\n-   【HADLAK S., SCHULZ H.-J., SCHUMANN H.: In situ exploration of large dynamic networks. IEEE Transactions on Visualization and Computer Graphics 17, 12 (2011), 2334–2343.】：**将一些小的可视化集成到更大的可视化中，通过这样的方法可以将动画集成到时间轴中；**\n-   【SALLABERRY A., MUELDER C., MA K.-L.: Clustering, visualizing, and navigating for large dynamic graphs. In Graph Drawing (2012), GD, pp. 487–498.】：**使用了一种基于时间轴的，但是也同样集成了通过节点链接图来表示的聚类演化动画。**\n-   【BECK F., BURCH M., VEHLOW C., DIEHL S., WEISKOPF D.: Rapid serial visual presentation in dynamic graph visualization. In Proceedings of the 2012 IEEE Sym- posium on Visual Languages and Human-Centric Comput- ing (2012), VL/HCC, IEEE, pp. 185–192.】：**将很长序列的图利用 Parallel Edge Splatting 的技术，通过移动时间轴来演示动画。**\n-   【RUFIANGE S., MCGUFFIN M. J.: DiffAni: Visualizing dynamic graphs with a hybrid of difference maps and animation. IEEE Transactions on Visualization and Computer Graphics 19, 12 (2013), 2556–2565. 】：**能够让用户将一部分时间轴集成为动画。**\n\n---\n\n## Research Challenges\n\n在文章最后，作者讲了一些 reseach challenges，对寻找科研问题比较有帮助，可以列举一下（不再细述 evaluation 部分）\n\n-   **Visual Scalability**：增加需要展示的数据，却仍要保留可读性，考虑三个维度，节点数量，边的密度以及时间。\n-   **Hybrids**：混合 animation 跟 timeline，在静态图中已经很好的混合了节点链接跟矩阵。\n-   **Extended Data Dimensions**：静态图变到动态图是加入了时间这个维度，那么在其他场景下， 是否还能加入其他的维度。已经有的是加入节点的层次关系，形成复合图。值得被研究的内容还有：动态的多属性图，带有不确定信息的动态图，有地理位置的图。\n-   **Interaction**：navigation（导航），这个工作已经很多年没有人聚焦。在动态图中，用户不仅要在空间中进行导航，也需要在时间上进行导航。当然交互也可以用来集成多个模型（DiffAni）或者用来过滤数据。标注/编辑动态图都未进行研究。\n-   **Application**：文学作品中的人物分析，金融和生物医药传染网络，眼部追踪数据。\n","tags":["Visualization","Graph Visualization","Dynamic Graph"]},{"title":"十分钟了解MobX","url":"/blog/2018/09/14/2018-09-14 十分钟了解MobX/","content":"\n参考：[Ten minute introduction to MobX and React](https://mobx.js.org/getting-started.html)\n\nMobx 是一种简单，可扩展且经过实战考验的状态管理解决方案。 本教程将在十分钟内教你 MobX 的所有重要概念。 MobX 是一个独立的库，但大多数人都将它与 React 一起使用，本教程重点介绍了这种组合。\n\n## 核心理念\n\n状态是每个应用程序的核心，许多状态管理解决方案试图限制可以修改状态的方式，例如通过使状态不可变。\n\nMobX 要让状态管理变得简单起来，它解决了根本问题：不允许产生前后不一致的状态。实现这一目标的策略很简单：能从应用的状态（state）中导出的任何派生值（derivation）都是自动导出的。\n\n![](https://mobx.js.org/getting-started-assets/overview.png)\n\n1. 首先有一个应用的**状态（state）**，可以是任何 objects，arrays，promitives，references 等等能够构建你的程序的东西。这些值是你的应用程序的元数据（data cells）\n2. 其次是**派生值（derivations）**，可以是任何能自动从你的状态（state）中计算得到的值。\n3. **反应（reaction）**和**derivations**很像，不一样的是，reaction 是一个动作，它用于制动执行一些任务，通常是一些 I/O 相关的任务，它们能够确保在合理的时间时，DOM 能够自动更新或者网络请求能够自动执行。\n4. **动作（actions）**，只有 actions 能够去改变 state，MobX 确保所有 state 的变化都是通过 action 进行，并且会自动地、同步地被传递给 derivation 和 reaction。\n\n## 一个简单的例子：todo store\n\n下面是一个简单的 TodoStore，维护了一系列待办事项，还没引入 MobX。\n\n```javascript\nclass TodoStore {\n    todos = []\n\n    get completedTodosCount() {\n        return this.todos.filter((todo) => todo.completed === true).length\n    }\n\n    report() {\n        if (this.todos.length === 0) return \"<none>\"\n        return (\n            `Next todo: \"${this.todos[0].task}\". ` +\n            `Progress: ${this.completedTodosCount}/${this.todos.length}`\n        )\n    }\n\n    addTodo(task) {\n        this.todos.push({\n            task: task,\n            completed: false,\n            assignee: null,\n        })\n    }\n}\n\nconst todoStore = new TodoStore()\n```\n\n上面我们创建了一个带有 todo 集合的 todoStore 实例。为了确保我们看到更改的效果，我们在每次更改后调用 todoStore.report 并记录它。 请注意，report 有意始终仅打印第一个任务。 它使这个例子有点人为，但正如你将在下面看到的，它很好地证明了 MobX 的依赖性跟踪是动态的。\n\n```javascript\ntodoStore.addTodo(\"read MobX tutorial\")\nconsole.log(todoStore.report()) // Next todo: \"read MobX tutorial\". Progress: 0/1\n\ntodoStore.addTodo(\"try MobX\")\nconsole.log(todoStore.report()) // Next todo: \"read MobX tutorial\". Progress: 0/2\n\ntodoStore.todos[0].completed = true\nconsole.log(todoStore.report()) // Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[1].task = \"try MobX in own project\"\nconsole.log(todoStore.report()) // Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[0].task = \"grok MobX tutorial\"\nconsole.log(todoStore.report()) // Next todo: \"grok MobX tutorial\". Progress: 1/2\n\nconsole.log(todoStore.completedTodosCount) // 1\n```\n\n## Becoming reactive\n\n到目前为止，这段代码并没有什么特别之处。 但是，如果我们不显式地调用 report，我们可以在每次状态更改时自动调用它吗？我们希望确保打印最新的报告，但却不想自己来组织这件事情。\n\n幸运的是，这正是 MobX 可以做的，它可以自动执行依赖于 state 的代码。这样我们的 report 就会自动更新，就像电子表格中的图表一样。为了实现这一点，TodoStore 必须变得可观察，以便 MobX 可以跟踪正在进行的所有更改。\n\n```javascript\nclass ObservableTodoStore {\n    @observable todos = []\n    @observable pendingRequests = 0\n\n    constructor() {\n        mobx.autorun(() => console.log(this.report))\n    }\n\n    @computed get completedTodosCount() {\n        return this.todos.filter((todo) => todo.completed === true).length\n    }\n\n    @computed get report() {\n        if (this.todos.length === 0) return \"<none>\"\n        return (\n            `Next todo: \"${this.todos[0].task}\". ` +\n            `Progress: ${this.completedTodosCount}/${this.todos.length}`\n        )\n    }\n\n    addTodo(task) {\n        this.todos.push({\n            task: task,\n            completed: false,\n            assignee: null,\n        })\n    }\n}\n\nconst observableTodoStore = new ObservableTodoStore()\n```\n\n我们将一些属性标记为@observable，以便在这些值发生变化时通知 MobX。用@computed 修饰计算过程，以标记这些计算过程是从状态派生而来。\n\n到此为止，我们还没用过`pendingRequests`和`assignee`。在构造函数中，我们创建了一个小函数，它自动打印报告。 由于 report 依赖于已被修饰为 observable 的 todos 状态，因此它会及时打印报告：\n\n```javascript\nobservableTodoStore.addTodo(\"read MobX tutorial\") // Next todo: \"read MobX tutorial\". Progress: 0/1\nobservableTodoStore.addTodo(\"try MobX\") // Next todo: \"read MobX tutorial\". Progress: 0/2\nobservableTodoStore.todos[0].completed = true // Next todo: \"read MobX tutorial\". Progress: 1/2\nobservableTodoStore.todos[1].task = \"try MobX in own project\"\nobservableTodoStore.todos[0].task = \"grok MobX tutorial\" // Next todo: \"grok MobX tutorial\". Progress: 1/2\n```\n\n我们可以看到，`report`这个 reaction，依赖于`this.todos.length, this.todos[0].task, this.completedTodosCount`，只有当这三个值发生改变时，才会自动调用`report`。而我们看到上面的第四行代码，其只改变了`todos[1].task`，并没有改变`report`所依赖的任何 state 或 reaction，故而没有调用`report`。\n\n## Making React reactive\n\nmobx-react 能够使得 React 的组件自动进行渲染，从而使得组件与其依赖的状态能够同步。\n\n下面的代码定义了一些 React 组件，唯一不同的地方就是用了 MobX 的@observer 装饰器，它使得每个组件能够在其相关的数据改变的时候重新渲染。这时我们不再需要`setState`，也不需要进行状态提升之类。\n\n```javascript\n@observer\nclass TodoList extends React.Component {\n    render() {\n        const store = this.props.store\n        return (\n            <div>\n                {store.report}\n                <ul>\n                    {store.todos.map((todo, idx) => (\n                        <TodoView todo={todo} key={idx} />\n                    ))}\n                </ul>\n                {store.pendingRequests > 0 ? (\n                    <marquee>Loading...</marquee>\n                ) : null}\n                <button onClick={this.onNewTodo}>New Todo</button>\n                <small> (double-click a todo to edit)</small>\n                <RenderCounter />\n            </div>\n        )\n    }\n\n    onNewTodo = () => {\n        this.props.store.addTodo(prompt(\"Enter a new todo:\", \"coffee plz\"))\n    }\n}\n\n@observer\nclass TodoView extends React.Component {\n    render() {\n        const todo = this.props.todo\n        return (\n            <li onDoubleClick={this.onRename}>\n                <input\n                    type=\"checkbox\"\n                    checked={todo.completed}\n                    onChange={this.onToggleCompleted}\n                />\n                {todo.task}\n                {todo.assignee ? <small>{todo.assignee.name}</small> : null}\n                <RenderCounter />\n            </li>\n        )\n    }\n\n    onToggleCompleted = () => {\n        const todo = this.props.todo\n        todo.completed = !todo.completed\n    }\n\n    onRename = () => {\n        const todo = this.props.todo\n        todo.task = prompt(\"Task name\", todo.task) || todo.task\n    }\n}\n\nReactDOM.render(\n    <TodoList store={observableTodoStore} />,\n    document.getElementById(\"reactjs-app\")\n)\n```\n\n我们看到，`TodoList`组件依赖于前面的`observableTodoStore.todos, observableTodoStore.pendingRequests`，故而当`observableTodoStore`中的`todos, pendingRequests `发生任何改变时，都会引起`TodoList`的重新渲染。\n\n在运行下面的代码时，回顾一下上面`observableTodoStore`的结果：\n\n```javascript\nobservableTodoStore.todos = [\n    {\n        task: \"grok MobX tutorial\",\n        completed: true,\n        assignee: null,\n    },\n    {\n        task: \"try MobX in own project\",\n        complted: false,\n        assignee: null,\n    },\n]\n\nobservableTodooStore.pendingRequests = 0\n```\n\n我们来运行一下下面的代码：\n\n```javascript\nconst store = observableTodoStore\nstore.todos[0].completed = !store.todos[0].completed\nstore.todos[1].task = \"Random todo \" + Math.random()\nstore.todos.push({ task: \"Find a fine cheese\", completed: true })\n// etc etc.. add your own statements here...\n```\n\n一开始，初始界面是：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-9-14/8517669.jpg)\n\n当运行完第二行时：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-9-14/62090457.jpg)\n\n第三行：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-9-14/88221181.jpg)\n\n第四行：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-9-14/27215063.jpg)\n\n## Working with references\n\n在之前，所有可观察的对象，都是原始类型的值：字符串，boolean 值，数值等。但当我们依赖的状态只是一个对其他对象的引用的话，该如何？下面的代码展示了该如何监听一个对象。\n\n```javascript\nvar peopleStore = mobx.observable([{ name: \"Michel\" }, { name: \"Me\" }])\nobservableTodoStore.todos[0].assignee = peopleStore[0]\nobservableTodoStore.todos[1].assignee = peopleStore[1]\npeopleStore[0].name = \"Michel Weststrate\"\n```\n","tags":["FrontEnd","React"]},{"title":"Structure-aware Fisheye Views for Efficient Large Graph Exploration","url":"/blog/2018/09/05/2018-09-05 Structure-aware Fisheye Views for Efficient Large Graph Exploration/","content":"\n![image-20181116171253691](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116171253691.png)\n\n-   论文原标题： Structure-aware Fisheye Views for Efficient Large Graph Exploration\n\n## 一、介绍\n\n图对于描述关系数据很通用，已经应用于很多领域，复杂的图的布局会有视觉混乱。\n\n交互则是用于减轻这个问题的通用方法之一。包括，平移缩放（pan-and-zoom）配合概览+细节（overview+detail）技术。介绍了概览细节技术的缺点，有可能会打破有趣的结构，比如长路径，聚类或者一些中等规模的结构（空间连续性问题）。\n\n可更换的技术是：焦点上下文技术（focus+context）。最常见的就是鱼眼，能够放大感兴趣区域。\n\n鱼眼技术的缺点。基于几何的鱼眼技术，比如图鱼眼（graphical）双曲线浏览（ hyperbolic browser）在缩放的时候会忽视图的结构从而带来畸变。拓扑鱼眼寻求解决这个问题（通过 coarsen graph 得到图的 hierarchy，从而保留图结构的方法），然而这个方法并不一定通用。其他还有一些方法并没有通过放大来增加可读性，而是通过一些比如防止节点重叠的方法。但这种方法不支持缩放。一些将链接渲染成曲线的方法则会阻碍图探索。\n\n文章推出了一套框架，可以产生结构相关的鱼眼。其可视化设计由 Cohe 导出：\n\n1. 最小化结构的扭曲；\n2. 提升感兴趣区域的可读性；\n3. 在交互的时候要维护连续性。\n\n文章的关键技术是将鱼眼的缩放问题转化成一个优化问题，目标是通过保留边的方向，从而提供可交互的，光滑的，跟结构相关的缩放。如此，文章提出的方法就可以最小化局部结构的扭曲从而提升空间连续性。并且，通过引入美学限制（比如最小化节点重合）来提升图布局的可读性。还有，文章的方法允许用户交互式的（通过画圈，或者画一个层次结构）在鱼眼交互的时候来指定保留特定的结构。\n\n另一方面，作者设计了一个任务导向的鱼眼透镜：\n\n1. 多焦点透镜：在多个焦点附近高亮结构\n2. 聚类透镜：可以维持一个子结构\n3. 路径透镜：可以聚焦到一个用户指定的路径上\n\n文章的方法基于 GPU，能够支持最多 15K 的节点数量。并且定量的跟以前的方法进行了比较。\n\n贡献：\n\n1. 提出了一个统一的框架，能够生成用于探索大图的结构相关的鱼眼视图。\n2. 设计了一组任务导向的鱼眼透镜，适用于不同的可视化任务。\n3. 利用基于 GPU 的方法进行实现，并进行了一次评估，一个 user study，以及两个 case study。\n\n## 二、相关工作\n\n### 图探索技术\n\npan-and-zoom，fisheye views，semantic zooming，dynamic layout\n\n### 高质量图布局技术\n\nstress-based methods：将几何限制转换成优化问题。早期的工作专注于方向的限制。但是这个优化问题往往是 NP 问题。Dig-CoLa 方法则有效的解决了有限制的布局的优化问题，通过将限制集成为压力优化（stress majorization）。\n\n## 三、背景\n\n图$\\lbrace V, E\\rbrace​$，节点的位置：$X=\\lbrace x_1, \\cdots, x_n \\rbrace​$，其中$x_i \\in R^2​$。\n\n### 几何鱼眼\n\ngraphical fisheye，hyperbolic fisheye，iSphere\n\n上述的鱼眼基本都是跟几何变换相关，但是忽视了边的链接。会造成结构的扭曲，如封面图 b 和 c。\n\n### Edge Vector-based Stress Majorization（布局方面）\n\n$$\narg\\min_X\\sum_{i<j}w_{ij}(x_i-x_j-e_{ij}d_{ij})^2\n$$\n\ne 为边的目标方向，d 为边的目标长度。在这种布局方法的启发下，作者期望通过改变边的朝向跟长度，来产生一个结构相关的并且能够光滑过渡的鱼眼交互。\n\n## 四、结构相关的鱼眼（structure-aware fisheye）\n\n$$\narg\\min_{Z^t}\\sum_{(i, j) \\in E} \\omega_{ij}^s||z_i^t-z_j^t-e_{ij}^sd_{ij}^s||^2 \\\\\\\n+\\sum_{(i, j) \\in \\Omega} \\omega_{ij}^r||z_i^t-z_j^t-e_{ij}^rd_{ij}^r||^2 \\\\\\\n+\\sum_{i \\in \\lbrace 1\\ldots n \\rbrace} \\omega_i^t||z_i^t-z_i^{t-1}||^2 \\\\\\\n$$\n\n其中，$Z^t$指第 t 次迭代的节点位置，$\\omega_{ij}^s, \\omega_{ij}^r, \\omega_i^t$是归一化的权重，$\\Omega$是在焦点区域内的边的集合。$e_{ij}^s$和$d_{ij}^s$则提供了结构的限制，$e_{ij}^r$和$d_{ij}^r$则提供了可读性的限制。最后一项则表达了时序上的连续性也就是光滑过渡。\n\n值得注意的是，$\\Omega$并不只是那些可见的边，其包含了所以点对之间的关系，即便两个点之间没有边相连，因为需要使没有边相连的点相互远离。\n\n### 结构相关的限制\n\n$$\ne_{ij}^s=\\frac{x_i-x_j}{||x_i-x_j||}, d_{ij}^s=||x'_i-x'_j||\n$$\n\n$X'$表示的是用鱼眼透镜估计的目标位置。保持了方向的一致性。\n\n**形状限制**：上述的限制只保证了边方向的限制，只会让局部结构保持的比较好，而较大的结构会被扭曲，如下图，a 是初始图，b 是经过 graphical fisheye 的产出，c 是加入了边方向限制，d 则是加入了形状限制。\n\n![image-20181116171318315](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116171318315.png)\n\n为了保留初始的结构，文章需要用户提供一组连接的边，称为$E_s$，比如上图 c 中的其中一圈蓝边，那么算法就能更好的估计$d_{ij}^s$。在缩放的时候，有些边变长，有些边变短。我们需要平衡这种变换。\n\n$$\n\\min_{\\rho} \\sum_{(i, j) \\in E_s}(\\rho d_{ij}-d'_{ij})^2\n$$\n\n这里估计出了一个平均畸变率$\\rho$，使得上图 c 产生的结构的边长$d'$和$\\rho d_{ij}$之间的差距最少。\n\n由此可以计算得到这个畸变率，那么对所有边长都乘上这个畸变率，就能进行统一变换，再加上上面的边方向的保持，从而保持原结构。\n\n$$\nd_{ij}^s=\\rho d_{ij}\n$$\n\n### 可读性限制\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/53259428.jpg)\n\n**不重叠的节点**：\n\n$$\nd_{ij}^r=r_i+r_j+\\varepsilon, e_{ij}^r=e_{ij}^s\n$$\n\n$r_i$和$r_j$是节点包围盒的半径，$\\varepsilon$则是节点分离系数（设为屏幕尺寸的 1%）。当然这中间还包括了那些不出现的虚拟边（也就是没有相连的两个节点之间也要分离）\n\n**最大化边的夹角**：\n\nPurchase 的可读性研究证明，边的相交很能影响可读性。完全解决边相交的问题不可能，特别是大图。最近的研究表明最大化夹角能够提升路径追踪任务的能力。\n\n$$\ne_{ij}^r=e_{ij}^s\\oplus\\frac{\\pi - \\alpha}{2}, e_{lk}^r=e_{lk}^s\\ominus\\frac{\\pi - \\alpha}{2}\n$$\n\n其中$\\alpha$是两条边的夹角，$\\oplus$表示顺时针旋转，$\\ominus$表示逆时针旋转。\n\n## 五、任务导向的鱼眼透镜\n\n**多焦点透镜**：在上面的基础上，加入了多焦点的透镜，效果如下图 c，b 是对照组。\n\n**聚类透镜**：用户可以制定一个凸包从而可以放大该区域包含的聚类，如图 d，红色的聚类是放大聚类，用灰色背景高亮起来。\n\n**路径透镜**：用户简单的挑选两个节点，算法找到最短路径，然后沿着这条路径定义焦点区域，关于这个焦点区域的半径：屏幕尺寸的$\\sqrt{m}/28$，其中$m$是放大系数。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/77703149.jpg)\n\n## 六、结果和评估\n\n### 定量比较\n\n对照组：\n\n-   **graphical fisheye**(**GF**, M. Sarkar and M. H. Brown. Graphical fisheye views of graphs. In Proc. SIGCHI conference on Human Factors in Computing Systems, pp. 83–91, 1992. doi: 10.1145/142750.142763)\n\n-   **hyperbolic fisheye**(**HF**, T. Munzner. Exploring large graphs in 3d hyperbolic space. IEEE Computer Graphics and Applications, 18(4):18–23, 1998. doi: 10.1109/38.689657)\n\n-   **iSphere**(F. Du, N. Cao, Y.-R. Lin, P. Xu, and H. Tong. isphere: Focus+ context sphere visualization for interactive large graph exploration. In Proc.SIGCHI conference on Human Factors in Computing Systems, pp. 2916–2927, 2017. doi: 10.1145/3025453.3025628)\n\n考虑因素：\n\n-   边方向保留\n-   节点重叠\n-   形状保留\n\n其中，比较双曲线鱼眼的时候，用了 iSphere 这篇文章的实现来进行比较，而 iSphere 在放大之后会把非焦聚区域放在球体的背面，无法比较前两项指标。\n\n一共比较了六组方法：GF HF ISphere 以及 GF+ours，HF+ours，ISphere+ours。前面三者都是直接变换，而后面三者则是一个优化问题。\n\n**边方向保留**：用 Edge Orientation Offset(EOO)，边方向偏差来定义边方向偏差。\n\n$$\nEOO(Z)=1-\\frac{1}{|E|}\\sum_{(i,j) \\in E}||\\langle \\frac{x_i-x_j}{||x_i-x_j||}, \\frac{z_i-z_j}{||z_i-z_j||} \\rangle||\n$$\n\n也就是：1-所有边的初始矢量和变换后的边矢量之间的绝对内积（夹角的 cos 值的绝对值）的平均值。即 EOO 越小，边方向保留的越好。\n\n这里只考虑了边方向的变化，而未考虑边长度。它也就揭示了结构的保存完好程度。\n\n下图 a 表示了 EOO，三种应用了文章方法的技术表现明显优于未应用的。\n\n**节点不重叠**：比较了初始输入跟输出之间的节点重叠数量的差别。下图 b 表示了重叠的节点的数量，能看到文章的方法效果不错。\n\n![image-20181116171403266](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116171403266.png)\n\n**形状保留**：利用 Eades 提出的基于形状的美学指标。给定一组节点组成一个图，将该组节点的 k 最近邻的集合构成的图叫做它的 shape graph。那么，通过 mean Jaccard similarity 来比较缩放前后，某个图的 shape graph 的相似度，就可以看出其是否保留形状。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/71304701.jpg)\n\n下图展示了不同的透镜下的结果（初始布局是利用一个限制了某些形状的，并且聚类之间不重叠的限制的压力模型），a 是初始图，b 是 graphical fisheye，c 是 hyperbolic fisheye，d 是 iShpere，e 是线性放大，f 是文章方法结合 graphical fisheye，g 是文章方法结合 hyperbolic fisheye，h 是文章方法结合 iSphere。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/27496642.jpg)\n\n### Lab Stydy\n\n为了验证文章的 structure-aware fisheye 是否能够有效提升图探索效率，文章设计了这个 lab study。比较了五个技术：\n\n-   pan-and-zoom(P&Z)\n-   graphical fisheye(GF)\n-   hyperbolic fisheye(HF)\n-   iSphere\n-   文章方法+graphical fisheye(Ours+GF)，因为这个表现适中，没有很好也不是很坏。\n\n因为传统的方法并没有考虑可读性的限制，于是在这里只是用了边方向限制作为比较。\n\n#### 实验条件\n\n**任务**：DU 在 iSphere 这篇文章中已经做过节点、边、路径探索的实验了，而本文的方法保持了边的方向，明显可以在探索节点和边的时候表现更好，并且这一点已经被 pivot 实验确认了。故而本文的任务聚焦到一个对探索大规模图的比较重要的“路径探索”上。这里主要采用了 Xu 在 A user study on curved edges in graph visualization 中使用的找到两个随机选择的节点之间的最短路径的方法。根据 pivot 实验，这个任务太复杂，于是限制最短路径的长度应该在 3-5 之间。\n\n**数据集**：**图规模**和**聚类结构**是两个影响用户表现的主要因素。聚类结构可以通过模块度（modularity）来进行度量，越高说明聚类越清晰。因为 iSphere 证明了在小图下，前面几种方法差别不大。并且在大规模图，低、高模块度的情况下，iSphere 都能表现的更好，而 HF 则表现的明显更差。作者根据 iShpere 的方法生成哼了 1024 节点 0.6 模块度的图作为数据集。并且选取了 3 作为平均节点度数，这样使得任务不会太难。然后用 stress majorization 来产生最初布局。在这个数据集中，作者与计算了 725 个节点对，其中 90%的最短路径小于 5。\n\n**系统实现**：系统界面支持选择机制来帮助用户探索，用户右击节点，高亮该节点和连接边。\n\n**参与者跟设施**：40 名，24 男 16 女，22-29 岁（平均 24 岁），实验放在桌面电脑上进行，有鼠标键盘，24 寸显示器 1920 1080 分辨率，144hz 刷新率（真有钱）。节点连接图白色背景，节点为一个黑点，边则是黑线，而窗口大小则是 150mm 150mm。下图是初始布局和五种不同技术放大后的效果。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/11209567.jpg)\n\n**过程**：在一开始，为参与者介绍五种技术。然后会有两条练习来熟悉五种技术：跟正式测试一样，也是找到两个随机选择的节点之间的最短变。\n\n之后每个人要经过 15 条测试（每个技术 3 条）。15 条测试以及 5 种技术都是随机的以防止偏见。每个 trial 都有 60s 时间限制。每个人大概会花 15 分钟。\n\n**假设**：\n\n1. 用直线渲染的技术（GF, P&Z, Ours+GF）会比曲线（HF，iSphere）来的高效。\n2. 鱼眼技术（GF，HF，iSphere 和 Ours+GF）则会比没有 context 的技术（P&Z）更高效。\n3. 低畸变率（Ours+GF，P&Z）会比高畸变率（GF，HF，iSphere）更高效。\n\n**分析**：每个人物都记录了完成时间和错误（用户记录的最短路径长度与真实最短路径长度之间的误差），每个人每种技术进行了 3 次，故而可以计算平均时间和错误。\n\n**结果**：根据图所示，在时间方面，Ours+GF 会比其他所有技术都更快，这支持了假设 1，但只是部分支持假设 2，毕竟 Ours+GF 和 P&Z 之间有大幅重叠。而在误差方面，有大规模的置信区间，也就说明了结果并不明确。尽管这样，Ours+GF 的平均值还是最低的。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/8710039.jpg)\n\n#### 讨论\n\n**Hyperbolic vs. Pan&Zoom**：被试提到：“双曲线鱼眼会导致挤压跟变形，有些边甚至会有很大的曲率，而平移缩放则保持了一个稳定的布局以便进行路径探索，尽管丢失了一部分上下文”。\n\n**iSphere**：虽然 iSphere 文章本身说明了该技术比其他的技术在路径探索任务上更好，但是本文却只显示了这个技术略微比 HF 要好，却比其他的技术要差。被试提到，“iShpere 在放大的时候，容易丢失一些远离的节点”，因为 iShpere 只渲染了焦点区域内的节点。有一些被试则没有感知到 iSpher 带来的畸变，这让他们觉得 iShpere 的交互像是在旋转一个球体，就跟平移缩放一样。\n\n**Graphical fisheye**：相比于 HF 和 IS，GF 用了直线边，因此更短时间就完成了任务，然而 GF 的畸变导致了整体结构的破坏，于是它的错误率是最高的。被试提到：“GF 的交互不够直观，而且它的畸变也是相对无法理解”\n\n**Our fisheye**：虽然文章的方法基于 GF，然而却得到了最好的表现。被试提到：“这个结构相关的鱼眼结合了双曲线和缩放平移的优点，直线边则有助于进行路径探索，而且即便会比较小，并且它的交互会显得更快，因为点击一个节点会放大感兴趣全区域而不用进行缩放平移”。\n\n### 案例研究\n\n#### 探索 ego-network\n\n用了 ego-facebook 的数据集，4039 个用户，88234 条关系，已聚类为 16 个聚类。压力模型进行布局，引入了聚类不重叠的限制。但是边跟节点仍然非常密集，使得很难比较相互远离的节点。可以见到，光是利用传统的 polyfocal 的鱼眼，会产生很高的畸变，第四张图 b。而本文的方法则可以避免这些问题，如图 c，可以见到两个来自不同聚类的节点备选了出来，这两个节点都和本聚类有一些连接，也跟红色、粉色聚类紧密相关。图 d 则表明一些青色的异常节点跟红色聚类之间紧密连接。\n\n#### 美国主要城市的探索\n\n![image-20181116171419003](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/image-20181116171419003.png)\n\n134 个节点代表美国城市，338 边则表达了城市之间是相邻的关系。图 b 利用了聚类透镜，放大了淡蓝色区域。于是节点之间的重叠降低，可以看清这些节点的 label。\n\n而为了寻找华盛顿 DC 和堪萨斯之间的最短路径，路径透镜则能够放大最短路径周围的区域，良好的展示两个城市之间的关系。\n\n在上面两个案例研究中，关于结构限制、可读性限制以及时序一致性限制都已经包含在所有的 case study 里面了。而关于时序一致性可以看视频。\n\n## 七、总结跟未来工作\n\n因为本文的工作都是基于节点的二维坐标系，而不是图结构。那么一些跟焦点节点相关的子结构展示的不是很清晰，特别是有些节点跟这个节点之间的欧氏距离比较大。并且作者期望将该方法用于地图，3D 面片之类的。\n","tags":["Visualization","Graph Visualization","Large Graph","Fisheye"]},{"title":"杂谈：国庆川西自驾游计划","url":"/blog/2018/08/22/2018-08-22 国庆川西自驾游计划/","content":"\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-8-28/72977502.jpg)\n\n行程总计 1500 公里，川西小环线\n\n#### 预算：6000 左右\n\n1. 来回火车：1500 以内\n2. 1-6 号 6 晚住宿：1500 以内\n3. 7 日饮食：1000 以内\n4. 租车费用+油费：1500 左右\n5. 门票：500 以内\n\n### 第一天：杭州-成都（火车）\n\n杭州东-成都东：07:42-22:10，14 小时 28 分，二等座 637.5 元\n\n前往租车地点，取车，休息\n\n### 第二天：成都市-卧龙-四姑娘山-甲居藏寨\n\n-   路程：360 公里，预计行驶时间 7.5 小时\n\n#### 1. 成都-卧龙大熊猫苑：2 小时\n\n-   蓉昌高速+G350：115 公里，2 小时。\n\n#### 2. 卧龙中华大熊猫苑神树坪基地：1 小时（视情况而定）\n\n-   进山费 15。\n\n-   卧龙中华大熊猫苑神树坪基地：门票 90，在游客中心买票，可以开车到景区门口。电瓶车自愿，没必要。\n\n-   在此游玩一小时。吃饭\n\n    ![](http://n2-q.mafengwo.net/s11/M00/BC/CC/wKgBEFsdWoWAdxVkADQdu1k7dG874.jpeg?imageMogr2%2Fthumbnail%2F%21690x450r%2Fgravity%2FCenter%2Fcrop%2F%21690x450%2Fquality%2F90%7Cwatermark%2F1%2Fimage%2FaHR0cDovL2I0LXEubWFmZW5nd28ubmV0L3MxMS9NMDAvNDQvOUIvd0tnQkVGc1A1UnlBRHY3cEFBQUhaWlVQUmxROTkwLnBuZw%3D%3D%2Fgravity%2FSouthEast%2Fdx%2F10%2Fdy%2F11)\n\n#### 3. 卧龙中华大熊猫基地-四姑娘山猫鼻梁：2 小时\n\n-   G350：94 公里，2 小时。\n\n-   在此观赏落日，半小时。\n\n    ![](http://n4-q.mafengwo.net/s8/M00/71/9B/wKgBpVUSXaKAeO5OAAsNrCUctVs97.jpeg?imageMogr2%2Fthumbnail%2F%21690x450r%2Fgravity%2FCenter%2Fcrop%2F%21690x450%2Fquality%2F90%7Cwatermark%2F1%2Fimage%2FaHR0cDovL2I0LXEubWFmZW5nd28ubmV0L3MxMS9NMDAvNDQvOUIvd0tnQkVGc1A1UnlBRHY3cEFBQUhaWlVQUmxROTkwLnBuZw%3D%3D%2Fgravity%2FSouthEast%2Fdx%2F10%2Fdy%2F11)\n\n#### 4. 猫鼻梁-四姑娘山：半小时\n\n-   G350：15 公里，半小时\n-   在此住宿\n\n#### 5. 四姑娘山\n\n-   视情况而定\n-   门票 80，观光车 70\n\n![](http://b2-q.mafengwo.net/s6/M00/0A/C9/wKgB4lOhaMmAH1eUAAH9XcvoEGI22.jpeg?imageMogr2%2Fthumbnail%2F%21690x450r%2Fgravity%2FCenter%2Fcrop%2F%21690x450%2Fquality%2F90%7Cwatermark%2F1%2Fimage%2FaHR0cDovL2I0LXEubWFmZW5nd28ubmV0L3MxMS9NMDAvNDQvOUIvd0tnQkVGc1A1UnlBRHY3cEFBQUhaWlVQUmxROTkwLnBuZw%3D%3D%2Fgravity%2FSouthEast%2Fdx%2F10%2Fdy%2F11)\n\n#### 6. 四姑娘山双桥沟-甲居藏寨：3.5 小时\n\n-   G350：136 公里\n\n#### 7. 甲居藏寨：住宿\n\n### 第三天：甲居藏寨-观音桥镇-色达五明佛学院-翁达\n\n-   路程：424 公里，预计行驶时间 8 小时\n\n#### 1. 甲居藏寨：1 小时\n\n在甲居藏寨游玩 1 小时，甲居藏寨是中国最美六大乡村古镇。\n\n![](https://dimg20.c-ctrip.com/images/fd/tg/g4/M05/FE/C1/CggYHFbSUKqAGWteAAREHSSdBvc475_C_1600_1200_Mtg_7.jpg)\n\n#### 2. 甲居藏寨-观音桥镇：4 小时（179 公里）\n\n#### 3. 观音桥镇\n\n-   中饭\n\n#### 4. 观音桥镇-色达五明佛学院：3 小时\n\n-   成那线（G350）：183 公里\n\n#### 5. 色达五明佛学院：直至夜色降临\n\n-   天葬可能看不到了\n\n#### 6. 色达五明佛学院佛学院-翁达镇：1 小时\n\n-   G317(成那线)：62 公里，夜晚行驶预计 1-2 小时\n\n### 第四天：翁达镇-道孚县-龙灯草原-塔公草原-新都桥\n\n-   G350+S215：275 公里，5 小时\n\n#### 1. 翁达镇-道孚县：2.5 小时\n\n-   成那线+G350：133 公里\n\n#### 2. 道孚县：1 小时\n\n-   吃中饭\n\n#### 3. 道孚县-新都桥：2.5 小时\n\n-   G350+S215：142 公里\n-   中途会遇到两大草原\n\n![](https://youimg1.c-ctrip.com/target/fd/tg/g4/M08/A0/EE/CggYHlZLC_WAFEynABBKJT-O4VU606_R_671_10000_Q90.jpg)\n\n### 第五天：新都桥镇-折多山-海螺沟\n\n-   路程：150 公里，预计行驶时间 4.5 小时\n\n#### 1. 新都桥：时间视情况而定\n\n-   在新都桥镇歇脚吃饭\n-   号称“摄影天堂”\n-   十里长廊\n\n![](http://p3-q.mafengwo.net/s9/M00/0F/B7/wKgBs1fH7ReAdPbFAATZFfqf7lc40.jpeg?imageView2%2F2%2Fw%2F1360%2Fq%2F90)\n\n#### 2. 新都桥-折多山观雪台：1 小时\n\n-   G318：42 公里\n\n#### 3. 折多山观雪台（逗留半小时）\n\n-   折多山的盘山公路九曲十八弯，注意驾驶安全，折多山比较拼人品，天气不好就是条路。。。\n\n![](http://n1-q.mafengwo.net/s11/M00/00/0F/wKgBEFsxq1CAGkp_AADrFcY3kQQ19.jpeg?imageMogr2%2Fthumbnail%2F%21690x450r%2Fgravity%2FCenter%2Fcrop%2F%21690x450%2Fquality%2F90%7Cwatermark%2F1%2Fimage%2FaHR0cDovL2I0LXEubWFmZW5nd28ubmV0L3MxMS9NMDAvNDQvOUIvd0tnQkVGc1A1UnlBRHY3cEFBQUhaWlVQUmxROTkwLnBuZw%3D%3D%2Fgravity%2FSouthEast%2Fdx%2F10%2Fdy%2F11)\n\n#### 4. 折多山-海螺沟（磨西古镇）：3.5 小时\n\n-   G317：108 公里\n\n#### 5. 磨西古镇+海螺沟\n\n-   在磨西古镇吃饭后，入住海螺沟景区，第二天起来看日出\n\n### 第六天：海螺沟-成都\n\n-   路程：300 公里，预计行驶时间 5 小时\n\n#### 1. 海螺沟：玩到不想玩为止\n\n-   票价：90\n-   海螺沟国家森林公园以其大型低海拔的现代冰川著称于世，冰川长达 14.7 公里，风光壮观。 景区融原始森林、珍稀动植物、温泉、瀑布于一体，可近距离接触冰湖、冰洞、冰裂隙、冰阶梯等多种景观。 游玩海螺沟的主要目的是泡温泉（二号营地）和看冰川（三号营地）。 二号营地有海螺沟内名气最大的热水沟沸泉，目前已建有 10 个大小不等的露天温泉池和一个的露天温泉游泳池。\n-   Tips: 入口设在磨西镇，购票进入后，便可乘坐观光车前行。 景区观光车无强制必买，但整个行程几十公里，不坐观光车基本不可能。观光车发车时间 07:30-13:00，12:50 停止售票，坐满一车发一班，间隔不超过 40 分钟发车。 游览海螺沟最好在冬春季节，夏秋季冰川会因为温度缘故有一定回缩，且夏秋季阴雨天较多，不便于观看日照金山景观。 各营地海拔及间距：磨西镇（海拔 1600 米）-15 公里-—号营地（海拔 1940 米）-8 公里-二号营地（海拔 2660 米）-7.5 公里-三号营地（海拔 2980 米）-3.5 公里-索道站-四号营地（海拔 3600 米）\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-8-22/38545632.jpg)\n\n#### 2. 海螺沟-成都：5 小时\n\n-   雅康高速、成渝高速：300 公里\n\n### 第七天：成都吃吃吃+回杭州\n\n回杭州的火车可以考虑：\n\n1. 成都-武汉+武汉-杭州：\n    1. D368，10:55 成都东-武汉 20:28（9 小时 33 分）二等座  ¥379.5，09 月 08 日 08:30 开售\n    2. 轨道交通 4 号线，武汉站-武昌站\n    3. Z45，22:40 武昌-07:03 杭州（8 小时 23 分）硬卧 ¥214，软卧 ¥325，09 月 08 日 12:30 开售\n2. 成都-重庆+重庆-杭州：\n    1. G8503，11:20 成都东-重庆北 13:04（1 小时 44 分）二等座￥ 154，09 月 08 日 08:30 开售\n    2. Z258，14:32 重庆北-杭州东 07:59（17 小时 27 分）硬卧￥ 388，软卧￥ 598，09 月 08 日 11:00 开售\n3. 成都-杭州：D2264，09:05 成都东-杭州东 22:24（13 小时 19 分）二等座￥ 628.5，09 月 08 日 08:30 开售\n4. 成都-杭州：D2224，07:35 成都东-杭州东 21:58（14 小时 23 分）二等座￥ 628.5，09 月 08 日 08:30 开售\n5. 成都-汉中+汉中-杭州\n    1. 成都-汉中，高铁/动车，09 月 08 日 08:30 开售\n        1. G2214，16:00 成都东-汉中 18:31，二等座￥ 167\n        2. D1942，16:39 成都东-汉中 19:20，二等座￥ 167\n        3. G2212，16:57 成都东-汉中 19:27，二等座￥ 167\n    2. 105 路，1 小时，到汉中城固机场\n    3. **长龙航空**GJ8780，21:20-23:20 至萧山机场，￥ 930\n","tags":["Travel"]},{"title":"CS229：13-SVM（四）非线性决策边界","url":"/blog/2018/07/25/2018-07-25 13-SVM（四）非线性决策边界/","content":"\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-7-25/83102162.jpg)\n\n当数据中存在异常点时，比如上述的情况，导致原先可以用直线 a 分割的数据现在不得不用 b 来进行，以保证完美的分割。由此我们引出了**非线性决策边界**（_non-linear decision boundaries_）来解决这样的问题。\n\n观察原 SVM 问题的目标：\n\n$$\n\\min_{w, b} \\frac{1}{2}||w|^2 \\\\\\\n\\text{ s.t. }y^{(i)} \\cdot (w^T \\cdot x^{(i)}+b) \\geq 1, i=1,\\ldots,m\n$$\n\n我们为原公式增加惩罚项，对不同的数据点增加不同的惩罚，使得所有样本能够更好地分割：\n\n$$\n\\min_{w, b} \\frac{1}{2}||w|^2+c\\sum_{i=1}^m\\xi_i, \\xi_i\\geq0\n$$\n\n使得\n\n$$\ny^{(i)} \\cdot (w^T \\cdot x^{(i)}+b) \\geq 1-\\xi_i, i=1,\\ldots,m\n$$\n\n注意到，我们之前认为$ y^{(i)} \\cdot (w^T \\cdot x^{(i)}+b) \\geq 1 $是分类正确的，在这里我们允许一部分样本小于 1，也就是说明我们允许了一部分样本分类错误。\n\n构建拉格朗日算子：\n\n$$\n{\\cal L}(w, b, \\xi, \\alpha, \\gamma) = \\frac{1}{2}||w|^2+c\\sum_i\\xi_i-\\sum_i^m\\alpha_i(y^{(i)} (w^T \\cdot x^{(i)}+b)-1+\\xi_i)-\\sum_i^m\\gamma_i\\xi_i\n$$\n\n对偶：\n\n$$\n\\max W(\\alpha) = \\sum_{i=1}\\alpha_i-\\frac{1}{2}\\sum_{i=1}\\sum_{j=1}\\alpha_i\\alpha_jy_iy_j\\langle x_i \\cdot x_j \\rangle\n$$\n\n跟原先的 SVM 问题的唯一区别在于其限制条件为：\n\n$$\n\\sum_{i=1}^my^{(i)}\\alpha_i=0 \\\\\\\n0 \\leq \\alpha_i \\leq c\n$$\n\n其收敛条件：\n\n-   对于大部分数据点：\n\n    $$\n    \\alpha_i=0 \\Rightarrow y^{(i)} (w^T \\cdot x^{(i)}+b) \\geq 1\n    $$\n\n-   对于异常点：\n\n    $$\n    \\alpha_i = c\n    $$\n\n-   对于最近点：\n\n    $$\n    0<\\alpha_i<c\n    $$\n\n### 坐标上升法（Coordinate Ascent）\n\n考虑优化问题：\n\n$$\n\\max W(\\alpha_1, \\alpha_2, ..., \\alpha_m)\n$$\n\n不考虑约束条件，\n\n重复 {\n\n​ For i = 1 to m:\n\n$$\n\\alpha_i := \\arg \\max_{\\hat{\\alpha}_i} W(\\alpha_1,\\ldots,{\\hat{\\alpha}}_i,\\ldots,\\alpha_m)\n$$\n\n} 直到收敛；\n\n这个算法，可以认为是执行了以下这个过程（以 m=2 为例）：\n\n![坐标上升法，不断沿着坐标轴方向前进](http://s3.sinaimg.cn/middle/b09d46024e1a2f5cf49c2&690)\n\n### 顺序最小优化算法（Sequential minimal optimization, SMO）\n\n顺序最小优化算法的基本理念就是在坐标上升法的基础上，改成一次性优化其中两个$\\alpha$，而固定其他的$m-2$个$\\alpha$。\n\n假如我们更新$\\alpha_1, \\alpha_2$：\n\n因为在之前我们提到:\n\n$$\n\\sum_i^m \\alpha_iy^{(i)}=0\n$$\n\n于是有：\n\n$$\n\\alpha_1 y^{(1)}+\\alpha_2 y^{(2)} = -\\sum_{i=3}^m\\alpha_iy^{(i)}= \\zeta\n$$\n\n那么\n\n$$\n\\alpha_1=\\frac{\\zeta-\\alpha_2y^{(2)}}{y^{(1)}}\n$$\n\n$$\nW(\\alpha_1, \\alpha_2, ..., \\alpha_m) = W(\\frac{\\zeta-\\alpha_2y^{(2)}}{y^{(1)}}, \\alpha_2, ..., \\alpha_m)\n$$\n\n在非线性决策边界优化问题中，其实$W$是一个关于$\\alpha_i$的二次函数，固定其他$\\alpha$之后，$W$函数就可以被简化为：\n\n$$\na\\alpha_2^2+b \\alpha_2 + c\n$$\n\n很容易就能求解。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：12-SVM（三）核函数","url":"/blog/2018/07/22/2018-07-22 12-SVM（三）核函数/","content":"\n在 SVM(二)中，我们看到了如下的表示形式：\n\n$$\nW(\\alpha)=\\sum_{i=1}\\alpha_i-\\frac{1}{2}\\sum_{i=1}\\sum_{j=1}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j)\n$$\n\n这里，内积$(x_i \\cdot x_j)$就是最简单的核函数的形式。一般核函数会被写成$\\langle x^{(i)}, x^{(j)} \\rangle$的形式。\n\n有时候，我们会将一些特征转换到高维空间上，就像我们在之前的过拟合&局部加权回归中提到的，比如特征$x$表示的是房屋面积，我们需要预测房子是否会在 6 个月内被卖出，我们有时候会将这个特征映射成如下的形式：\n\n$$\nx \\rightarrow \\begin{bmatrix}\nx \\\\\\\nx^2 \\\\\\\nx^3 \\\\\\\nx^4\n\\end{bmatrix} = \\phi(x)\n$$\n\n原先的特征的内积形式$\\langle x^{(i)}, x^{(j)} \\rangle$会被写成$\\langle \\phi(x^{(i)}), \\phi(x^{(j)}) \\rangle$，而且往往$\\phi(x)$会有很高的维度。因为在很多情况下，计算$\\phi(x)$会有很高的代价，或者表示$\\phi(x)$需要很高的代价，但是光是计算内核则可能代价较小。\n\n比如：假如有两个输入：$x, z \\in \\Bbb R^n$，核函数被定义为：\n\n$$\n\\begin{align}\nk(x, z) = (x^T z)^2 &= (\\sum_{i=1}^nx_iz_i)(\\sum_{j=1}^nx_jz_j) \\\\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^n(x_ix_j)(z_iz_j) \\\\\\\n&= \\phi(x)^T\\phi(z)\n\\end{align}\n$$\n\n假如需要表示成高维向量，那么$\\phi(x)$是一个$n \\times n$维的向量，如果$n = 3$：\n\n$$\n\\phi(x) = \\begin{bmatrix}\nx_1x_1 \\\\\\\nx_1x_2 \\\\\\\nx_1x_3 \\\\\\\nx_2x_1 \\\\\\\n\\vdots \\\\\\\nx_3x_3\n\\end{bmatrix}\n$$\n\n所以，计算$\\phi(x)$的时间复杂度就达到了$O(n^2)$，而计算核函数仅仅需要计算$x^Tz$，复杂度为$O(n)$。\n\n接下去我们为这个核函数增加常数项：\n\n$$\nk(x,z)=(x^Tz+c)^2\n$$\n\n那么：\n\n$$\n\\phi(x) = \\begin{bmatrix}\nx_1x_1 \\\\\\\nx_1x_2 \\\\\\\nx_1x_3 \\\\\\\nx_2x_1 \\\\\\\n\\vdots \\\\\\\nx_3x_3 \\\\\\\n\\sqrt{2c}x_1 \\\\\\\n\\sqrt{2c}x_2 \\\\\\\n\\sqrt{2c}x_3 \\\\\\\nc\n\\end{bmatrix}\n$$\n\n更一般的：\n\n$$\nk(x, z)=(x^Tz+c)^d\n$$\n\n有了核函数，即可替换 SVM 中的内积$\\langle x^{(i)}, x^{(j)} \\rangle$，比如常用的高斯核：\n\n$$\nk(x,z)=\\exp(-\\frac{||x-z||^2}{2\\sigma^2})\n$$\n\n有了核函数，相当于把数据从原始空间转换到了高位空间，很多数据，在一维空间往往是线性不可分的，但是到了高维空间会变成可分的：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-7-23/7489488.jpg)\n\n## 核函数的合法性\n\n如何判断一个核函数是合法的呢？判断依据是：是否存在函数$\\phi$，使得$k(x,z)$能够被写成$\\langle \\phi(x), \\phi(z) \\rangle$。\n\n> **定理**：如果核函数合法，那么其对应的核矩阵（kernel matrix）是半正定的。\n\n核矩阵指的是矩阵$K \\in \\Bbb R^{m\\times m}$，其中$K_{ij}=k(x^{(i)}, x^{(j)})$。半正定的意思是，对于任意向量$z$，都存在$z^TKz \\geq 0$，证明如下：\n\n$$\n\\begin{align}\nz^TKz &= \\sum_i\\sum_jz_iK_{ij}z_j \\\\\\\n&= \\sum_i\\sum_jz_i\\phi_(x^{(i)})^T\\phi_(x^{(j)})z_j \\\\\\\n&= \\sum_i\\sum_jz_i\\cdot \\sum_k\\phi_(x^{(i)})_k\\underbrace{\\phi_(x^{(j)})_k}_{向量第k项} \\cdot z_j \\\\\\\n&= \\sum_k\\sum_i\\sum_jz_i\\cdot \\phi_(x^{(i)})_k\\phi_(x^{(j)})_k \\cdot z_j \\\\\\\n&= \\sum_k(\\sum_iz_i\\phi(x^{(i)}))^2 \\geq 0\n\\end{align}\n$$\n\n事实上，上面的定理的逆命题也一样成立，总结起来：\n\n> **Merce 定理**：给定核函数$k(x, z)$，那么$k(x, z)$合法（也即$\\exists \\phi, k(x,z)=\\phi(x)^T\\phi(z)$），当且仅当，对所有的$\\lbrace x^{(1)}, \\ldots, x^{(m)} \\rbrace$，核矩阵$K \\in \\Bbb R^{m\\times m}$是一个对称的半正定矩阵。\n","tags":["Course Notes","Machine Learning"]},{"title":"记一个Promise问题","url":"/blog/2018/07/08/2018-07-08 记一个Promise问题/","content":"\n我们来观察以下四段代码的区别：\n\n```javascript\n// 1 setTimeout throw\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(function () {\n    throw new Error(\"test\");\n  }, 0);\n});\np1.catch(function (error) {\n  console.log(\"Catch1: \", error);\n});\n// Uncaught Error: test\n\n// 2 setTimeout reject\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(function () {\n    reject(new Error(\"test\"));\n  }, 0);\n});\np2.catch(function (error) {\n  console.log(\"Catch2: \", error);\n});\n// Catch2:  Error: test\n\n// 3 throw\nconst p3 = new Promise(function (resolve, reject) {\n  throw new Error(\"test\");\n});\np3.catch(function (error) {\n  console.log(\"Catch3: \", error);\n});\n// Catch3:  Error: test\n\n// 4 reject\nconst p4 = new Promise(function (resolve, reject) {\n  reject(new Error(\"test\"));\n});\np4.catch(function (error) {\n  console.log(\"Catch4: \", error);\n});\n// Catch4:  Error: test\n```\n\n`then`和`catch`返回新的`Promise`对象，`finally`返回本身。\n\n`all`的`then`，`catch`的调用优先级低于`all`的元素本身的`then`，`catch`。\n\n以下两者代码的区别：(定义 Promise 的时候会执行其中的代码)\n\n```javascript\nconst f = () => console.log(\"now\");\nPromise.resolve().then(f);\nconsole.log(\"next\");\n// next\n// now\n\nconst f = () => console.log(\"now\");\n(() => new Promise((resolve) => resolve(f())))();\nconsole.log(\"next\");\n// now\n// next\n```\n","tags":["FrontEnd","JavaScript"]},{"title":"CS229：11-SVM（二）最优间隔分类器","url":"/blog/2018/07/03/2018-07-03 11-SVM（二）最优间隔分类器/","content":"\n**最优间隔分类器**（_Optimal Margin Classifier_）。其目标是使得最小几何间隔最大化（SVM（一）概念）：\n\n$$\n\\text{目标(1):} \\\\\\\n\\max_{w, b} \\gamma \\\\\\\n\\text{ s.t. } y^{(i)} \\cdot ((\\frac{w}{||w||})^T \\cdot x^{(i)}+\\frac{b}{||w||}) \\geq \\gamma, i=1,\\ldots,n\n$$\n\n我们知道，$\\hat{\\gamma} = \\frac{\\gamma}{||w||}$，所以上面的目标可以等同于：\n\n$$\n\\text{目标(2):} \\\\\\\n\\max_{w, b} \\frac{\\hat{\\gamma}}{||w||} \\\\\\\n\\text{ s.t. }y^{(i)} \\cdot (w^T \\cdot x^{(i)}+b) \\geq \\hat{\\gamma}, i=1,\\ldots,n\n$$\n\n为了最大化上述值，我们有两种策略。\n\n1. 增大$\\hat{\\gamma}$\n2. 减小$||w||$\n\n针对第一种可能，我们要证明其无效性。假如，我们增大$\\hat{\\gamma}$到${\\hat{\\gamma}}_1 := \\lambda {\\hat{\\gamma}}$，因为$\\hat{\\gamma}=y(w^Tx+b)$，可以视作$w_1:=\\lambda w, b_1 = \\lambda b$。所以，此时\n\n$$\n\\frac{\\hat{\\gamma_1}}{||w_1||}=\\frac{\\lambda \\hat{\\gamma}}{||\\lambda w||} = \\frac{\\hat{\\gamma}}{||w||} \\\\\\\n$$\n\n没有发生任何改变，所以第一条策略不可行。于是，我们可以固定$\\hat{\\gamma}=1$\n\n此时，上述目标(2)可以表述成：\n\n$$\n\\text{目标(3):} \\\\\\\n\\min_{w, b} \\frac{1}{2}||w||^2 \\\\\\\n\\text{ s.t. }y^{(i)} \\cdot (w^T \\cdot x^{(i)}+b) \\geq 1, i=1,\\ldots,n\n$$\n\n因为最小化$||w||$和最小化$\\frac{1}{2}||w||^2$是一致的。\n\n## 拉格朗日乘子法（Lagrange Multiplier）\n\n为了解决上述的**凸优化问题**，我们引入拉格朗日乘子法*Lagrange Multiplier*来解决这个问题。\n\n我们首先来看看**凸优化问题**的定义：\n\n$$\n\\min_wf(w) \\\\\\\n\\text{s.t. }g_i(w) \\leq 0, h_i(w) =0\n$$\n\n构建拉格朗日乘子：\n\n$$\n{\\cal L}(w, \\alpha, \\beta) = f(w)+\\sum_i\\alpha_ig_i(w)+\\sum_i\\beta_ih_i(w)\n$$\n\n定义：\n\n$$\n\\theta_p(w) = \\max_{\\alpha_i>0, \\beta}{\\cal L}(w, \\alpha, \\beta)\n$$\n\n观察$\\theta_p(w)$：\n\n1. 如果$g_i(w)>0$，那么$\\theta_p(w)=+\\infty$（因为$\\alpha$可以取任意大值）。\n2. 如果$h_i(w) \\neq 0$，那么$\\theta_p(w)=+\\infty$（因为$\\beta$可以取$+\\infty/-\\infty$）。\n\n所以，在满足约束的情况下，$\\theta_p(w)=f(w)$，$\\min_w \\theta_p(w)=\\min_w f(w)$，因为使得${\\cal L}(w, \\alpha, \\beta)$最大的方法，就是其他所有项全是 0。那么，可以得出这样的结论：\n\n$$\n\\theta_p(w)=\\begin{cases}\nf(w), &\\text{满足约束} \\\\\\\n\\infty, &\\text{不满足约束}\n\\end{cases}\n$$\n\n因此，在满足条件的情况下，$\\min_w\\theta_p(w)$等价于$min_wf(w)$。\n\n我们将最优间隔分类器的目标重新表示一下：\n\n$$\np^\\ast =\\min_{w, b}\\max_\\alpha {\\cal L(w, \\alpha, b)} \\\\\\\n{\\cal L}(w, \\alpha, b) = \\frac{1}{2}||w||^2+\\sum_i\\alpha_i(1-y^{(i)}(w^T x^{(i)}+b))\n$$\n\n其中，直接忽略了$h_i(w)=0$的约束，而$g_i(w,b)=1-y^{(i)}(w^Tx^{(i)}+b) \\leq 0, f(w)=\\frac{1}{2}||w||^2$\n\n## 对偶问题（Dual Problem）\n\n一般来说，将原始问题转化成对偶问题来求解。一是因为对偶问题往往比较容易求解，二是因为对偶问题引入了核函数，方便推广到非线性分类的情况。\n\n我们看到，之前的原始问题，是\n\n$$\np^\\ast =\\min_{w, b}\\max_\\alpha {\\cal L}(w, \\alpha, b)\n$$\n\n那么，定义其对偶问题：\n\n$$\nl^\\ast =\\max_\\alpha\\min_{w,b}{\\cal L}(w, \\alpha, b)\n$$\n\n接下去，我们求解对偶问题：\n\n先求解$\\min_{w,b}{\\cal L}(w, \\alpha, b)$：\n\n分别求偏导，使其等于 0，导出最小值：\n\n$$\n\\begin{align}\n& \\nabla_w{\\cal L}(w, \\alpha, b) =w-\\sum_{i=1}\\alpha_iy^{(i)}x^{(i)}=0 \\\\\\\n& \\nabla_b{\\cal L}(w, \\alpha, b) =\\sum_{i=1}\\alpha_iy^{(i)}=0\n\\end{align}\n$$\n\n得到：\n\n$$\nw =\\sum_{i=1}\\alpha_iy^{(i)}x^{(i)} \\\\\\\n\\sum_{i=1}\\alpha_iy^{(i)} = 0\n$$\n\n代入${\\cal L}(w, \\alpha, b)$，就可以得到最小值：\n\n$$\n\\begin{align}\n{\\cal L}(w, \\alpha, b) &= \\frac{1}{2}||w||^2+\\sum_i\\alpha_i(1-y^{(i)}(w^T x^{(i)}+b)) \\\\\\\n\\min_{w, b}{\\cal L}(w, \\alpha, b) &=\\underbrace{\\sum_{i=1}\\alpha_i-\\frac{1}{2}\\sum_{i=1}\\sum_{j=1}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j)}_{W(\\alpha)}\n\\end{align}\n$$\n\n于是，我们的对偶问题简化到了对$W(\\alpha)$最大化：\n\n$$\n\\max_\\alpha W(\\alpha) \\\\\\\n\\text{s.t. }\\alpha_i \\geq 0, \\sum_iy_i\\alpha_i=0\n$$\n\n假设，我们解得的对偶问题的解为：$\\alpha^\\ast =[\\alpha_1^\\ast ,\\alpha_2^\\ast , \\ldots, \\alpha_m^\\ast ]$，那么最终原始问题的解可以表示成：\n\n$$\nw^\\ast =\\sum_{i=1}\\alpha_i^\\ast y^{(i)}x^{(i)}\n$$\n\n在原始问题中，还有$b$未得到解决。我们先来观察一下约束项：\n\n$$\ng_i(w,b)=1-y{(i)}(w^Tx^{(i)}+b) \\leq 0\n$$\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-7-4/9336603.jpg)\n\n我们知道，在数据中，只有少数的几个数据点，他们的函数距离为 1（最小），也即$g_i(w,b)=0$，如图所示。\n\n在整个数据集中，只有这些数据点对约束超平面起了作用，这些数据点被称为支持向量（_support vector_），其对应的$\\alpha_i^\\ast  \\neq 0$，而其他不是支持向量的数据点，没有对约束超平面起作用，其$\\alpha_i^\\ast =0$。\n\n此时，我们已经得到了$w^\\ast $，而$b^\\ast $的计算如下，找到一个数据点，其$\\alpha_j^\\ast \\neq 0$(也就是支持向量，其函数间隔为 1)，我们就能得到：\n\n$$\ny^{(j)}(w^{*T}x^{(j)}+b^\\ast )=1\n\\Rightarrow\nb^\\ast =y^{(j)}-\\sum_{i=1}\\alpha_i^\\ast y^{(i)}(x^{(i)} \\cdot x^{(j)})\n$$\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：10-SVM（一）概念","url":"/blog/2018/07/02/2018-07-02 10-SVM（一）概念/","content":"\n_SVM_，指的是支持向量机（_support vector machines_）。\n\n支持向量机，假设数据是线性可分的，那么我们就能找到一个超平面，将数据分成两类。但是一旦线性可分，我们就可能找到无数的超平面，都可以将数据分成两类：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-7-3/83131877.jpg)\n\n但是很明显，上图中虽然*a, c*都对数据进行了有效的分割。但很明显，都不如*b*分割的好。\n\n我们可以用“间隔”这个概念来定义这个超平面（在二维上是线）对数据的分割优劣。在分类正确的情况下，间隔越大，我们认为对数据的分类越好。\n\n我们的目标是得到数据的分类：$y \\in \\lbrace -1, +1 \\rbrace$。\n\n这个超平面，则可以表示成$w^Tx+b$，其中$w=[\\theta_1, \\ldots, \\theta_n]^T, b=\\theta_0$。这个超平面可以表达成一个$n+1$维向量。\n\n判别函数：\n\n$$\ng(z)=\\begin{cases}\n+1, & \\text{如果$z\\geq0$} \\\\\\\n-1, & \\text{otherwise}\n\\end{cases}\n$$\n\n假设则可以表示成：$h_{w,b}(x)=g(w^Tx+b)$\n\n## 间隔\n\n### 函数间隔（functional margin）\n\n某个超平面$(w,b)$和训练样本$(x^{(i)}, y^{(i)})$之间的函数间隔被表示成：\n\n$$\n\\hat{\\gamma}^{(i)}=y^{(i)}(w^Tx^{(i)}+b)\n$$\n\n于是，我们可以知道：\n\n1. 当$y^{(i)}=1$，于是我们想获得更大的函数间隔（这是我们的目标），就需要使得$w^Tx^{(i)}+b \\gg 0$\n2. 相反，当$y^{(i)}=-1$，我们想获得更大的函数间隔，就需要使得$w^Tx^{(i)}+b \\ll 0$\n\n并且，很明显，只有当函数间隔$\\hat{\\gamma}>0$时，分类结果是正确的。\n\n最后，超平面与数据集$\\lbrace (x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \\ldots \\rbrace$之间的函数间隔，被定义为所有函数间隔中的最小值：\n\n$$\n\\hat{\\gamma}=\\min_i\\hat{\\gamma}^{(i)}\n$$\n\n### 几何间隔（geometric margin）\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-7-3/34659777.jpg)\n\n从点$(x^{(i)}, y^{(i)})$出发，对超平面做垂线，得到点 D，我们知道他们之间的距离，就是该超平面到数据点$(x^{(i)}, y^{(i)})$的几何间隔。\n\n经过推导，D 的坐标可以表示为：\n\n$$\nx^{(i)}-\\gamma^{(i)}\\frac{w}{||w||}\n$$\n\n又因为，D 在超平面$w^Tx+b=0$上，所以：\n\n$$\n\\begin{align}\n& w^T(x^{(i)}-\\gamma^{(i)}\\frac{w}{||w||})+b=0 \\\\\\\n& \\Rightarrow w^Tx^{(i)}+b=\\gamma^{(i)} \\cdot \\frac{w^Tw}{||w||}=\\gamma^{(i)} \\cdot ||w|| \\\\\\\n& \\Rightarrow \\gamma^{(i)}=(\\frac{w}{||w||})^T \\cdot x^{(i)}+\\frac{b}{||w||}\n\\end{align}\n$$\n\n加上正负分类的判断：\n\n$$\n\\gamma^{(i)}=y^{(i)} \\cdot ((\\frac{w}{||w||})^T \\cdot x^{(i)}+\\frac{b}{||w||})\n$$\n\n我们可以看到，几何间隔跟函数间隔之间存在如下的关系：\n\n$$\n\\hat{\\gamma}^{(i)} = \\frac{\\gamma^{(i)}}{||w||}\n$$\n\n同样的，超平面与数据集$\\lbrace (x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \\ldots \\rbrace$之间的几何间隔，被定义为所有几何间隔中的最小值：\n\n$$\n\\gamma=\\min_i\\gamma^{(i)}\n$$\n\n最后，我们导出**最优间隔分类器**（_Optimal Margin Classifier_）问题：选择$w, b$，最大化$\\gamma$，同时满足$\\forall(x^{(i)}, y^{(i)})$，$ y^{(i)} \\cdot ((\\frac{w}{||w||})^T \\cdot x^{(i)}+\\frac{b}{||w||}) \\geq \\gamma$（所有数据点的几何间隔都大于该最小几何间隔）。\n\n目前为止，已经是 SVM 问题的一个简化版本。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：09-生成学习算法的例子","url":"/blog/2018/06/29/2018-06-29 09-生成学习算法的例子/","content":"\n## 例一：高斯判别分析和 logistic 函数\n\n我们来看一个例子，对于一个高斯判别分析问题，根据贝叶斯：\n\n$$\n\\begin{align}\np(y=1|x) &= \\frac{p(x|y=1)p(y=1)}{p(x)} \\\\\\\n&= \\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)+p(x|y=1)p(y=1)}\n\\end{align}\n$$\n\n在这里，我们提出几个假设：\n\n1. $p(y)$是均匀分布的，也就是$p(y=1)=p(y=0)$\n2. $x$的条件概率分布（$p(x|y=0)$和$p(x|y=1)$）满足高斯分布。\n\n考虑二维的情况：\n\n![image-20180630164349595](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-30-084350.png)\n\n蓝色数据表达的是$p(x|y=0)$的分布，红色数据表达的是$p(x|y=1)$的分布，两条蓝色和红色的曲线分别是它们的概率密度曲线。\n\n而灰色的曲线则表示了$p(y=1|x)$的概率密度曲线。\n\n假设$p(x|y=0) \\sim N(\\mu_0, \\sigma_0)$，$p(x|y=1) \\sim N(\\mu_1, \\sigma_1)$，而$p(y)$均匀分布那么：\n\n$$\n\\begin{align}\np(y=1|x) &= \\frac{N(\\mu_0,\\sigma_0)}{N(\\mu_0,\\sigma_0)+N(\\mu_1,\\sigma_1)} \\\\\\\n&= \\cdots \\\\\\\n&= \\frac{1}{1+\\frac{\\sigma_0}{\\sigma_1}exp(2\\sigma_1^2(x-\\mu_0)^2-2\\sigma_0^2(x-\\mu_1)^2}\n\\end{align}\n$$\n\n事实上，这条曲线跟我们之前见过的*logistic*曲线非常像，特别是当我们假设$\\sigma_0=\\sigma_1$的时候，就是一条*logistic*曲线。\n\n我们有如下的推广结论：\n\n$$\n{\\begin{cases}\np(x|y=1) \\sim Exp Family(\\eta_1) \\\\\\\np(x|y=0) \\sim Exp Family(\\eta_0)\n\\end{cases}} \\Rightarrow p(y=1|x)是logistic函数\n$$\n\n但这个命题的逆命题并不成立，故而我们知道，*logistic*所需要的假设更少（无需假设$x$的条件概率分布），鲁棒性更强。而生成函数因为对数据的分布做出了假设，所以需要的数据量会少于*logstic*回归，我们需要在两者之间进行权衡。\n\n## 例二：垃圾邮件分类（1）\n\n这里我们会用朴素贝叶斯（Naive Bayes）来解决垃圾邮件分类问题（$y\\in \\lbrace 0, 1 \\rbrace$）。\n\n首先对邮件进行建模，生成特征向量如下：\n\n$$\nx=\n\\begin{bmatrix}\n0 \\\\\\\n0 \\\\\\\n0 \\\\\\\n\\vdots \\\\\\\n1 \\\\\\\n\\vdots\n\\end{bmatrix}\n\\begin{matrix}\na \\\\\\\nadvark \\\\\\\nausworth \\\\\\\n\\vdots \\\\\\\nbuy \\\\\\\n\\vdots\n\\end{matrix}\n$$\n\n这是一个类似于词频向量的特征向量，我们有一个 50000 个词的词典，如果邮件中出现了某个词汇，那么其在向量中对应的位置就会被标记为 1，否则为 0。\n\n我们的目标是获取，垃圾邮件和非垃圾邮件的特征分别是怎么样的，也即$p(x|y)$。$x={\\lbrace 0, 1 \\rbrace}^n, y \\in \\lbrace 0, 1 \\rbrace$，这里我们的词典中词汇数量是 50000，所以$n=50000$，特征向量$x$会有$2^{50000}$种可能，需要$2^{50000}-1$个参数。\n\n我们假设$x_i|y$之间相互独立(虽然假设各个单词的出现概率相互独立不是很合理，但是即便这样，朴素贝叶斯的效果依旧不错)，根据朴素贝叶斯，我们得到：\n\n$$\np(x_1, x_2, \\ldots, x_{50000}|y)=p(x_1|y)p(x_2|y) \\cdots p(x_{50000}|y)\n$$\n\n单独观察$p(x_j|y=1)​$：\n\n$$\np(x_j|y=1) = p(x_j=1|y=1)^{x_j}p(x_j=0|y=1)^{1-x_j}\n$$\n\n给定三个参数：\n\n$$\n\\begin{align}\n\\phi_{j|y=1} &= p(x_j=1|y=1) \\\\\\\n\\phi_{j|y=0} &= p(x_j=1|y=0) \\\\\\\n\\phi_y &= p(y = 1)\n\\end{align}\n$$\n\n故：\n\n$$\n\\begin{align}\np(x_j|y=1) &= \\phi_{j|y=1}^{x_j}(\\phi_y - \\phi_{j|y=1})^{1-x_j}\\\\\\\np(x_j|y=0) &= \\phi_{j|y=0}^{x_j}(1-\\phi_y + \\phi_{j|y=0})^{1-x_j} \\\\\\\np(x_j|y) &= p(x_j|y=1)^yp(x_j|y=0)^{1-y} \\\\\\\np(y) &= \\phi_y^y(1-\\phi_y)^{1-y}\n\\end{align}\n$$\n\n按照上个博客生成学习算法的概念中所述，我们会选用联合概率分布的极大似然来导出最优解：\n\n$$\nl(\\phi_y,\\phi_{j|y=1},\\phi_{j|y=0}=\\prod_{i=1}^mp(x^{(i)},y^{(i)})=\\prod_{i=1}^mp(x^{(i)}|y^{(i)})p(y^{(i)})\n$$\n\n可以解得：\n\n$$\n\\begin{align}\n\\phi_{j|y=1} &= \\frac{\\sum_{i=1}^m1\\lbrace x_j{(i)}=1, y^{(i)}=1 \\rbrace}{\\sum_{i=1}^m1\\lbrace y^{(i)}=1 \\rbrace}  = \\frac{统计所有包含词语j的垃圾邮件的数量}{垃圾邮件的总数}\\\\\\\n\\phi_{j|y=0} &= \\frac{\\sum_{i=1}^m1\\lbrace x_j{(i)}=1, y^{(i)}=0 \\rbrace}{\\sum_{i=1}^m1\\lbrace y^{(i)}=0 \\rbrace} = \\frac{统计所有包含词语j的非垃圾邮件的数量}{非垃圾邮件的总数} \\\\\\\n\\phi_y &= \\frac{\\sum_{i=1}^m1\\lbrace y^{(i)}=1 \\rbrace}{m} = \\frac{垃圾邮件的数量}{邮件的总数}\n\\end{align}\n$$\n\n通过以上的公式，我们已经可以完全推得$p(x_1, x_2, \\ldots, x_{50000}|y)$。\n\n### Laplace 平滑\n\n假设，训练集中，我们重来没有碰到过\"_NIPS_\"这个词汇，假设我们词典中包含这个词，位置是 30000，也就是说：\n\n$$\n\\begin{align}\np(x_{30000}=1|y=1) &= 0\\\\\\\np(x_{30000}=0|y=1) &= 0\n\\end{align} \\\\\\\n\\Downarrow \\\\\\\np(x|y=1) =\\prod_{i=1}^{50000}p(x_i|y=1)=0 \\\\\\\np(x|y=0) =\\prod_{i=1}^{50000}p(x_i|y=0)=0\n$$\n\n故而在分类垃圾邮件时：\n\n$$\n\\begin{align}\np(y=1|x) &= \\frac{p(x|y=1)p(y=1)}{p(x)} \\\\\\\n&=\\frac{p(x|y=1)p(y=1)}{p(x|y=0)p(y=0)+p(x|y=1)p(y=1)} \\\\\\\n&= \\frac{0}{0+0}\n\\end{align}\n$$\n\n所以，我们提出$p(x_{30000}=1|y=1) = 0$这样的假设不够好。\n\n*Laplace*平滑就是来帮助解决这个问题的。\n\n举例而言，在计算：\n\n$$\n\\phi_y=p(y=1)=\\frac{\\text{numof(1)}}{\\text{numof(0)}+\\text{numof(1)}}\n$$\n\n其中，$\\text{numof(1)}$表示的是，被分类为 1 的训练集中数据个数。\n\n在*Laplace*平滑中，我们会采取如下策略:\n\n$$\n\\phi_y=p(y=1)=\\frac{\\text{numof(1)}+1}{\\text{numof(0)}+1+\\text{numof(1)}+1}\n$$\n\n比如，A 球队在之前的五场比赛里面都输了，我们预测下一场比赛赢的概率：\n\n$$\np(y=1)=\\frac{0+1}{0+1+5+1}=\\frac{1}{7}\n$$\n\n而不是简单的认为（没有*Laplace*平滑）是 0。\n\n推广而言，在多分类问题中，$y\\in\\lbrace1, \\ldots, k \\rbrace$，那么：\n\n$$\np(y=j) = \\frac{\\sum_{i=1}^m1\\lbrace y^{(i)} = j \\rbrace+1}{m+k}\n$$\n\n## 例三：垃圾邮件分类（2）\n\n之前的垃圾分类模型里面，我们对邮件提取的特征向量是：\n\n$$\nx=[1,0,0,\\ldots,1,\\ldots]^T\n$$\n\n这种模型，我们称之为多元伯努利事件模型（Multivariate Bernoulli Event Model）。\n\n现在，我们换一种特征向量提取方式，将邮件的特征向量表示为：\n\n$$\nx=[x_1,x_2,\\ldots,x_j,\\ldots]^T\n$$\n\n$x_j$表示词汇$j$在邮件中出现的次数。上述的特征向量也就是词频向量了。这种模型，我们称为多项式事件模型（Multinomial Event Model）。\n\n对联合概率分布$p(x,y)$进行极大似然估计，得到如下的参数：\n\n$$\n\\begin{align}\n\\phi_{k|y=1} &= p(x_j=k|y=1) = \\frac{C_{x=k}+1}{C_{y=1}+n} \\\\\\\n\\phi_{k|y=0} &=p(x_j=k|y=0) = \\frac{C_{x=k}+1}{C_{y=0}+n} \\\\\\\n\\phi_{y} &= p(y=1) = \\frac{C_{y=1}+1}{C_{y=1}+1+C_{y=0}+1}\n\\end{align}\n$$\n\n其中：\n\n$n$表示词典中词汇的数量，也就是特征向量的长度；\n\n$$\nC_{x=k}=\\sum_{i=1}^m(1\\lbrace y^{(i)}=1 \\rbrace \\sum_{j=1}^{n_i}1 \\lbrace x_j^{(i)} = k \\rbrace)\n$$\n\n表示在训练集中，所有垃圾邮件中词汇$k$出现的次数（并不是邮件的次数，而是词汇的次数）；\n\n$$\nC_{y=1}=\\sum_{i=1}^n(1\\lbrace y^{(i)} = 1 \\rbrace \\cdot n_i)\n$$\n\n表示训练集中垃圾邮件的所有词汇总长；\n\n$$\nC_{y=0}=\\sum_{i=1}^n(1\\lbrace y^{(i)} = 0 \\rbrace \\cdot n_i)\n$$\n\n表示训练集中非垃圾邮件的所有词汇总长；\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：08-生成学习算法的概念","url":"/blog/2018/06/29/2018-06-29 08-生成学习算法的概念/","content":"\n生成学习算法，英文为*Generative Learning Algorithm*。\n\n我们之前看到的都是判别学习算法（_Discriminative Learning Algorithm_）。判别学习算法可以分成两种：\n\n1. 学得$p(y|x)$，比如之前的线性模型\n2. 学得一个假设$h_\\theta (x) = \\lbrace 0, 1 \\rbrace$，比如二分类问题\n\n上面都是根据特征$x$，来对输出$y$进行建模，也许$y$是一个连续的值，也可能是离散的，比如类别。\n\n那么，生成学习算法（_Generative Learning Algorithm_）刚好跟判别学习算法（_Discriminative Learning Algorithm_）相反，其用输出$y$对$x$进行建模，也就是：**学得$p(x|y)$**。\n\n**详细解释**：\n\n对于一个二分类或多分类问题，生成学习算法，在给定样本所述的类别的条件下，会对其样本特征建立一个概率模型。举例而言，在给定癌症是良性或者是恶性的条件下，生成模型会对该癌症的特征的概率分布进行建模。\n\n根据朴素贝叶斯，\n\n$$\np(y=1|x)=\\frac{p(x|y=1) p(y=1)}{p(x)}\n$$\n\n因为给定了$x$，所以$p(x)$可以视作 1，也即\n\n$$\np(y=1|x)=p(x|y=1) p(y=1)\n$$\n\n## 高斯判别算法\n\n_Gaussian Discriminant Algorithm_\n\n对特征满足高斯分布的二分类问题进行建模。\n\n假设$x \\in \\Bbb R^n$，且$p(x|y)$满足高斯分布，因为$x$往往是一个特征向量，故而这里的高斯分布是一个多元高斯分布（_multivariate Gaussian）_。\n\n> 多元高斯分布，$z \\sim N(\\mu, \\Sigma)$。\n>\n> $$\n> p(z)=\\frac{1}{\\sqrt{(2\\pi)^n|\\Sigma|}}exp(-\\frac{1}{2}(z-\\mu)^T\\Sigma^{-1}(z-\\mu))\n> $$\n>\n> $z$是一个$n$维向量，$\\mu$则是均值向量，$\\Sigma$是协方差矩阵：$E[(z-\\mu)(z-\\mu)^T]$。\n\n对于一个二分类判别问题，正则响应函数为$\\phi$，那么\n\n$$\np(y)=\\phi^y(1-\\phi)^{1-y}\n$$\n\n且\n\n$$\np(x|y=0) \\sim N(\\mu_0, \\Sigma) \\\\\\\np(x|y=1) \\sim N(\\mu_1, \\Sigma)\n$$\n\n(这里假设了，对于$y=0$和$y=1$，是两个不同均值，但协方差矩阵相同的多元高斯分布，所以这也是该模型的限制之一)\n\n我们写出对数似然函数：\n\n$$\n\\begin{align}\nl(\\phi, \\mu_0, \\mu_1, \\Sigma) &= log\\prod_{i=1}^mp(x^{(i)}, (y^{(i)})) \\\\\\\n&= log\\prod_{i=1}^mp(x^{(i)}| (y^{(i)}))p(y^{(i)})\n\\end{align}\n$$\n\n对比一下之前二分类问题中的对数似然估计函数：\n\n$$\nl(\\theta) = \\sum_{i=1}^mlog(P(y^{(i)}|x^{(i)};\\theta))\n$$\n\n这里，我们使用了联合概率（_joint likelihood_）: $p(x^{(i)}, (y^{(i)}))$，而在之前的判别模型里，我们用的是条件概率（_conditional likelihood_）: $P(y^{(i)}|x^{(i)};\\theta)$。因为，在判别模型中，特征$x$是给定的，所以用条件概率来进行极大似然估计；而在生成模型中，特征$x$不给定，所以需要用联合概率来进行极大似然估计。\n\n然后，我们进行极大似然估计，得到：\n\n$$\n\\phi=\\frac{1}{m}\\sum_{i=1}^my^{(i)}=\\frac{1}{m}\\sum_{i=1}^m 1\\lbrace y^{(i)} = 1 \\rbrace\n$$\n\n也就是分类标签为 1 的训练样本的比例。\n\n再看$\\mu_0, \\mu_1$：\n\n$$\n\\mu_0=\\underbrace{\\sum_{i=1}^m 1\\lbrace y^{(i)} = 0 \\rbrace \\cdot x^{(i)}}_{(1)} /\\underbrace{ \\sum_{i=1}^m 1\\lbrace y^{(i)} = 0 \\rbrace}_{(2)} \\\\\\\n\\mu_1=\\sum_{i=1}^m 1\\lbrace y^{(i)} = 1 \\rbrace \\cdot x^{(i)} / \\sum_{i=1}^m 1\\lbrace y^{(i)} = 1 \\rbrace\n$$\n\n式(1)表达了分类为 0 的样本中，特征$x$的和；式(2)表达了分类为 0 的样本个数；故而$\\mu_0$表达了样本中，分类为 0 的样本的特征的均值。同理得到$\\mu_1$。\n\n我们再次回顾上面的高斯判别算法，事实上，高斯判别算法，假设了特征$x$满足了多元高斯分布，利用极大似然估计，对不同类别的特征$x$的分布进行了建模。\n\n下节课我们将会探讨其他的关于生成学习算法的案例。\n","tags":["Course Notes","Machine Learning"]},{"title":"Reﬁnery, Visual Exploration of Large, Heterogeneous Networks through Associative Browsing","url":"/blog/2018/06/28/2018-06-28 Reﬁnery, Visual Exploration of Large, HeterogeneousNetworks through Associative Browsing/","content":"\n-   论文原文：Reﬁnery, Visual Exploration of Large, HeterogeneousNetworks through Associative Browsing\n-   作者：S. Kairam, N. H. Riche, S. Drucker, R. Fernandez, and J. Heer\n-   发表刊物/会议：2015 EuroVis\n\n![image-20180628165322984](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-28-085323.png)\n\n## 介绍\n\n对数据进行探索有两大类策略：_analytical_（分析）和*browsing*（浏览）。前者是对特定的事实进行分析探索，后者则是适合信息搜寻任务。*HCI*的研究者们发现，_orienteering_（原意是定向运动）也是常见的探索策略，指的是向已知的信息目标进行导航。_associative browsing_（关联浏览）则表示想要导航的信息目标是特定的某个主题或者是一个广泛的知识领域。\n\n本文的可视化系统称为*Refinery*，用以支持通过*associative browsing*关联浏览的方式进行大规模异构网络的探索。\n\n**贡献**：\n\n1. 确定了支持关联浏览的可视化系统的设计准则和策略\n2. 制作了*Refinery*系统，通过关联浏览支持高效自底向上的异构网络探索\n3. 一种新的基于随机游走的图算法，用以扩展异构网络的*DOI(degree-of-interest)*可视化\n\n## 设计准则\n\n通过回顾了一些之前的用以信息查询探索的可视化系统，作者提出了四个设计目标：\n\n**G1**. 支持对异构动态集合的浏览。\n\n**G2**. 在表达搜索意图时，平衡简洁性和表达性（表达性指的是提供给用户足够的选择，简洁性则是使得用户能够简单的来评估这些选择，以防产生选择障碍）\n\n**G3**. 通过连续迭代的过程优化用户的搜索意图（交互式的对话窗口来帮助用户优化搜索意图）\n\n**G4**. 提供多种上下文线索以支持用户识别数据，发现规律。\n\n## 系统介绍\n\n作者通过一个 case 来介绍了系统的各个面板。\n\nMae 最近参加了一个关于人机交互中的伦理学研究的会议，她想起会上有一个有趣的演讲，但是忘记了作者是谁。她只记得这篇文章赢得了 Honorable Mention。她想要找到这篇论文以及相关的论文。\n\n##### Free-Text Search\n\nMae 在这里输入了关键词*ethics*，会返回一些相关的匹配结果（下图 a）。然后她继续输入了*Honorable Mention*。\n\n![image-20180628162048090](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-28-082048.png)\n\n##### Sidebar\n\n*Sidebar*会列举所有的关键词，然后并提供 upvote 和 downvote 功能以便用户优化查询（上图 b）。Mae“upvote”了关键词*Design*，“downvote”了关键词*End of Life*和*E-Government*。\n\n##### Graph View\n\n![image-20180628163354240](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-28-083354.png)\n\n在图视图中，与 Mae 选择的关键词相关的节点以及他们之间的连接被可视化出来。在图视图中，Mae 找到了一篇题为*Categorised Ethical Guidelines for Large Scale Mobile HCI*的文章，并阅读了摘要。她认为这篇文章已经十分接近她想要找的那篇文章，就将这篇文章添加到查询关键字中，这时，*CHI2013: Ethics in HCI*出现在图视图中，Mae 将这个节点也添加进查询中。\n\n##### List View\n\n![image-20180628163728991](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-28-083729.png)\n\n切换到列表视图后，Mae 最终找到了她想要的那篇文章*Benevolent Deception in Human Computer Interaction*。\n\n### 随机游走模型\n\n作者将整个网络建模为一个基于随机游走的概率图模型，边表示从一个节点到另一个节点的概率。\n\n$$\np(e_{i\\rightarrow j})=\\frac{w(e_{i\\rightarrow j})}{p_H+(1-p_H)\\sum_{e\\in e_i}w(e)}\n$$\n\n$p_H$是在这个节点停止的概率。在只有一个查询节点时，计算这个节点到达其他节点的概率，并以这个概率作为相关系数。在多节点查询时，根据 upvote 和 downvote 的信息对每个查询节点产生的相关系数进行组合。\n","tags":["Visualization","Graph Visualization","Large Graph"]},{"title":"HiPiler Visual Exploration of Large Genome Interaction Matrices with Interactive Small Multiples","url":"/blog/2018/06/26/2018-06-26 HiPiler, Visual Exploration of Large Genome Interaction Matrices with Interactive Small Multiples/","content":"\n-   论文原文：HiPiler: Visual Exploration of Large Genome Interaction Matrices with Interactive Small Multiples\n-   作者：Fritz Lekschas, Benjamin Bach, Peter Kerpedjiev, Nils Gehlenborg, and Hanspeter Pfister\n-   发表刊物/会议：2017 InfoVis\n\n![image-20180627173553094](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-093553.png)\n\n> 图 1：系统界面。矩阵视图（1）包含概述（1A）和详细（1B）矩阵。 片段视图（2）将矩阵的区域呈现为交互式的 small multiples。 在这个例子中，片段以 t-SNE（2C）排列，一堆片段会以其平均模式进行显示（2A）。 查看操作菜单位于底部（1C 和 2B）。\n\n## 个人评述\n\n1. 结合了 small multiple 和 overview+detail 的方法来探索大矩阵，对大规模数据可视化很有借鉴意义。\n2. 文章整体领域性特别强，就很注重讲故事的能力，并且整篇文章的讲故事能力也很强。\n\n启发：\n\n1. 这对大规模图可视化其实有一个很好的借鉴意义，但相比于文中的有序矩阵，图的无序性会让其在拓扑空间的上下文很难展示在平面上。\n\n    overview->detail->small multiple 的方法，是大规模数据可视化的一个重要模式。但在图可视化中，这几个部分都还很具有挑战性。\n\n2. 结合领域知识，使整片文章的 motivation 非常充足，或许也给我们一个思路，在结合领域的基础上进行科研，但又要跳出领域知识，比如这篇文章并没有把自己局限在生物领域，在其他领域，只要满足其矩阵有序的基本假设，都可以应用这个方法。\n\n## 介绍\n\n生物学家对基因序列是如何折叠的研究非常感兴趣，可以帮助理解细胞的功能、疾病的产生等。\n\n基因组之间存在相互作用（_interacting_），两两之间相互作用则会形成一个基因组相互作用矩阵（_genome interaction matrix_），最多能达到三百万 × 三百万。里面会包含一些重复出现的图案/模式（称为*ROI*, _regions of interest_）。\n\n-   **挑战**：\n\n1. 算法识别的结果不是很可信，并且没有*ground-truth*去评估这些算法是否准确。\n2. 成千上万的小*ROI*的探索和比较，还没有工具能够支持。\n\n-   **贡献**：\n\n1. 对算法检测到的团进行可视化评估\n2. 大规模图案集合的分类、聚合、异常点检测\n3. 在多个矩阵之间比较*ROI*（比如，在不同数据集，实验条件，抽取算法等等），_下文中也会称之为 Snippet_\n4. 对其他的基因属性和图案之间的相关性进行分析\n\n![image-20180627173831533](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-093832.png)\n\n> 图 2：*snippets*方法，将大矩阵（1）分解成小片段（2），并使用不同的布局，排列和样式探索这些片段（3），同时保持全局上下文。 矩阵内的小方块表示片段位置。\n\n## 背景\n\n-   **Hi-C 矩阵分析**：*HI-C*是一种捕获基因序列片段之间相互交联的方法。基因序列片段如果在空间上如果比较接近的话，会相互交联，如下图。每次检查数百万个不同细胞，会产生基因序列片段之间的平均接触概率矩阵。矩阵非常稀疏，并呈现这样的规律：空间邻近的基因序列片段更容易相互交联。\n\n    矩阵元素的颜色深浅编码了基因片段之间的接触概率。\n\n    ![image-20180627154141291](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-074141.png)\n\n    > 图 3：Hi-C 方法：由于 DNA(1)在细胞核(2)中并非随意进行组织的，某些序列会进行紧密交联(3)。在经过数亿个细胞计数之后(4)，会得到一个多达 300 万个单元的相互交联矩阵(5)，深色表示交联次数更多\n\n-   **专家采访**：主要围绕了以下三方面展开，\n\n1. 基因折叠相关研究的长期目标\n\n    更好地理解基因组对基因调控等过程的作用。\n\n2. 工作的流程和策略\n\n3. 当前的挑战\n\n    - 不同 ROI 相距甚远，普通工具容易导致上下文的丢失。\n    - 很多图案之间差异细微\n    - 数据噪音的存在，并非所有的图案都跟生物特征有关（有些仅仅是因为空间限制引发了交联）\n\n-   **常见的 Hi-C 矩阵图案**：\n\n    下图显示了一些常见的图案：\n\n    ![image-20180627161019379](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-081019.png)\n\n    > 图 4：放大尺寸后的交联矩阵中的频繁图案的示例。上方的矩阵是下方矩阵的一个示意。交联矩阵是对称的，所以下面的三角用灰度来显示，以突出那些用橙色标记的图案。\n\n-   **分析任务**：\n\n    **T1**. 搜索已知的图案\n    **T2**. 发现新的图案\n    **T3**. 对某个图案实例进行研究\n    **T4**. 比较单个图案类型中包含的多个实例\n    **T5**. 将图案和其他生物特征进行关联\n    **T6**. 比较矩阵中不同的*ROI*\n\n## 相关工作\n\n围绕了：\n\n1. 基因交联矩阵可视化\n2. 大矩阵可视化\n3. 分而治之的挖掘方法\n\n## HiPiler 的设计\n\n![image-20180627173447375](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-093448.png)\n\n> 图 5：HiPiler 的可视化和交互的概览\n\n**关键目标**：利用*smal multiple*的方法来对大矩阵的多个*ROI*进行探索。（如何提取*ROI*不是本文工作）\n\n*Hipler*的设计过程是被以下几个问题所驱动的：\n\n1. 如何有意义的限制*ROI*的显示数量？\n2. 用什么交互来支持有效的排列？\n3. 如何链接这些*ROI*和整个大矩阵？\n\n### 数据模型\n\n这里假设了矩阵的行和列的排序是固定的，由基因序列给出。\n\n### 设计\n\n跟计算生物学家之间讨论，研究了不同的可视化设计，并最终决定使用矩阵来进行可视化。\n\n#### 片段隐喻（Snipptet Metaphor）\n\n解决任务**T1，T2，T3，T5**。用来展示*ROI*的的矩阵数据，附加的一些可视化设计可以编码类别信息和有序数据：类别信息会被编码成颜色放在底下，有序数据则可以被编码成边框的颜色和粗细。\n\n![image-20180627170413058](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-090413.png)\n\n> 图 6：片段*snippet*被绘制为热力图（1），显示其*ROI*的矩阵数据。 分类属性可以用颜色标签可视化（2）。 与片段相关的有序数据可以通过边框的宽度和颜色（3）显示。 例如，较高的值被绘制为黑色粗边框。\n\n#### 片段布局（Snippet Layout ）\n\n解决任务**T4**。通过降维的方式，允许进行一维排序（1D），二维的布局（2D）以及多维的聚类（MD）。\n\n![image-20180627171216301](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-091216.png)\n\n> 图 7：片段*snippet*可以沿着各种不同的尺寸排列。 对于单个属性，片段在支持读取方向和希尔伯特曲线（1）的 1D 中布置。 选择两个属性创建散点图（2）。 对于两个以上的属性，HiPiler 应用了降维算法（3），如 t-SNE [33]。\n\n#### 聚合（Aggregation）\n\n**解决任务 T4，T6**。利用了打桩（_piling_）来隐喻多个*snippet*的聚合。聚类后，每个片段每列取平均值划为一行的形式显示在上方，可以 hover 查看具体图案。集合封面可以显示集合的平均值或者方差。\n\n![image-20180627171531688](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-091532.png)\n\n> 图 8：HiPiler 显示一堆片段的平均值（1A）或方差（1B）的封面矩阵。 此外，每个片段都显示为一维预览，显示片段列的水平聚合（2）。 将鼠标光标移到预览上可显示相关矩阵。 检查堆（3B）的时候暂时隐藏所有其他片段（3B）。\n\n#### 关联（Linking）\n\n解决**T5，T6**。将细节视图中的*snippet*关联到大矩阵中，因为在基因序列上的邻近信息对分析很重要。通过颜色标记来标记*snippet*在矩阵中的位置，不在矩阵视窗中的那些*snippet*则会被淡出。\n\n![image-20180627172331496](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-27-092332.png)\n\n> 图 9：当在片段上进行悬停，该片段的位置会在交联矩阵（1A）和矩阵细节（1B）进行高亮显示。其他的颜色表示另外选择的矩阵。\n\n### 交互技术\n\n如图 5.5 所示，用户可以通过拖拽、lasso、刷选等方式来创建堆，双击以分散堆。缩放的时候，片段也会对窗口进行自适应。\n\n## 评估\n\n评估通过 USAGE SCENARIOS 和 USER EVALUATION 展开。\n\n其中 USER EVALUATION 不同于之前的 USER STUDY，仅仅是让生物学家来使用这个系统，然后反馈意见。\n","tags":["Visualization","Matrix"]},{"title":"Wavelet-based Visual Analysis of Dynamic Networks","url":"/blog/2018/06/24/2018-06-24 Wavelet-based Visual Analysis of Dynamic Networks/","content":"\n-   论文原文：Wavelet-based Visual Analysis of Dynamic Networks\n-   作者：Alcebiades Dal Col, Paola Valdivia, Fabiano Petronetto, Fabio Dias, Claudio T. Silva, Senior Member\n-   发表刊物/会议：2017 TVCG\n-   ps: 语法错误这么多的文章不知道是怎么发出来的，大概是真的实力强劲\n\n## 个人评述\n\n作者主要提出了一种利用小波变换的结果，对动态图进行可视化的方法。有几点亮点：\n\n1. 动态图转化成静态图的方法：通过在时序上相邻的两个图之间增加时序边的方法，将一系列动态图组合成一整个图，再对该图进行小波变换\n2. 小波变换对突变的检测：利用小波变换的高频部分来检测动态图中存在的突变。\n3. 制定的四个目标，基本上包含了动态图可视化中所存在的任务：\n    - **目标 1**：将网络当做整体来进行分析\n    - **目标 2**：对每个节点的分析。\n    - **目标 3**：重要节点的辨认。\n    - **目标 4**：相似节点的辨认。\n4. 详尽的 usage scenario，甚至可能可以当做模板\n\n为了阅读这篇文章，我花了一段时间补习了傅里叶变换、小波变换、谱图理论的相关背景知识，但读这篇文章的理论部分还是有点困难，想了很久。\n\n接下去说说它的不足：\n\n1. 可视化设计简单：其几个视图的设计都异常简洁（或许其简洁也是其亮点），可视化设计方面没有太大的创新\n2. 文章上下文背景知识的补充不足：经常出现不明所以的结论，没有任何铺垫，比如：为何小波变换后，高频部分比较突出的节点可以视作突变节点？\n3. Motivation 的不足：可能多讲一些动态图可视化背景来引出 4 种目标会更好\n\n启发：\n\n1. 图嵌入算法对于动态图可视化的帮助：很多向量化的方法事实上同时捕捉到了全局和局部的特征，比谱图理论（小波变换）更容易解释，反而对动态图可视化更有帮助\n2. 小波变换对于异常检测的意义：对突变的检测是否精准，有待验证。\n\n## 介绍\n\n动态网络介绍+谱图小波理论的优势（模式挖掘，噪声移除，信息压缩）\n\n本文的工作：用图小波来对动态网络进行可视分析，特别是对局部特征变换的分析。\n\n贡献：\n\n1. 基于小波变换的动态网络探索方法，识别动态网络中不规律的、微妙的以及突现的拓扑信号变化；\n2. 一个交互式的可视分析工具，引导用户了解动态网络中的模式和现象，并降低探索整体和局部间探索的隔阂\n3. usage scenario\n\n这篇文章是上一篇做静态图的文章的引申。\n\n## 谱图理论\n\n这一部分，可以见我的另一篇博客，我将这部分做了单独的阐释：[图的小波变换](https://jackieanxis.github.io/blog-others/2018/06/19/%E5%9B%BE%E7%9A%84%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/)\n\n## 图小波对动态图进行可视分析\n\n主要涉及两个问题：\n\n1. 如何定义节点的信号\n2. 对一组时间序列内的小波分析结果进行了表示\n\n### 动态图模型\n\n作者将一系列的动态图相互串联（两个邻时刻同样的点之间，用临时的边进行链接，如图中的蓝边），以形成一整个图，从而应用图小波变换对其进行分析。\n\n但并不是串联所有的动态图，作者在这里定义了一个时间窗口，在时间窗口内的图会被串联起来（比如 5 分钟）\n\n![image-20180624215039214](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-135039.png)\n\n### 节点信号和边权重\n\n节点信号的定义和边权重的定义都对分析有着重要影响。\n\n比如：\n\n-   在对纽约市的出租车的场景分析中，节点表示了一个区域，而节点的信号则对应这个区域的出租车接客数量，网络中的边则是两个区域之间的乘客上下，边权重则是接送的乘客数量。\n-   而在另一个场景分析中，作者将人转换成节点，节点信号则是一段时间内这个人的人际交往数量，也就是该节点的度数。\n\n总而言之，如果自己定义信号，用图小波变换进行可视分析则是对节点的某个特征在拓扑空间和时间上的分布进行的分析。如果没有定义，那么就是对这个节点的拓扑信息进行了分析。\n\n还可以控制那些不同时间片段的图之间的连接边的权重，用来控制分析过程中时间的影响。\n\n### 节点分类\n\n每个节点都用一个特征向量（feature vector，并非 eigenvector）来进行分类，这个特征向量事实上就是小波系数$FV_j=(S_f(j), W_f(s_r,j), \\ldots, W_f(s_1, j))$。\n\n减少噪声：每个时间片中的孤立节点会被分配为 0 类。\n\n分类方法：机械扭矩。类似于将特征向量的各个值放在跷跷板上，看这个跷跷板往哪边偏，来判定这个特征向量主要是低频的还是高频的。\n\n![image-20180624223752644](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-143752.png)\n\n分类的这种方法，比直接解释系数容易的多。一共分成五类：\n\n[-1, -0.3), [0.3, -0.05], [-0.05, 0.05), [0.05, 0.3), [0.3, 1]，编码从深蓝到红色。![image-20180624225101805](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-145102.png)\n\n红色的节点，代表了信号的突变（时间和空间邻域上），但作者并未解释为什么高频代表了突变。\n\n### 可视化\n\n宗旨是为了能够发现动态网络中的 pattern 以及这些 pattern 是如何随时间演变的。\n\n-   **目标 1**：将网络当做整体来进行分析\n-   **目标 2**：对每个节点的分析。\n-   **目标 3**：重要节点的辨认。\n-   **目标 4**：相似节点的辨认。\n\n四个界面：\n\n![image-20180625001348008](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-161348.png)\n\n-   Netowok Analyzer：对网络整体变化的一个概览\n-   Time Slice View: 对某个时间片段的详细分析\n-   Node Ranking：识别某个时间片段的相关节点\n-   Node Time Series：对某个节点进行详细分析\n\n#### Network Analyzer\n\n每个时间片段被编码成一个圆，圆的垂直位置由包含的节点的信号值总和给出，节点颜色则是最大类的颜色。需要明白的是，这里的最大类并不是说当前时间片段包含节点最多的类，而是相对于该类在其他时间包含的节点数而言最大。\n\n#### Time Slice View\n\n对某个给定的时间片的节点，做了力引导。之后花了篇幅讲解了这个视图的有效性。\n\n![image-20180625001408755](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-161409.png)\n\n#### Node Ranking\n\n对节点与该时间片段的相关性来排序。被标记为红色或者橙色的节点，才会认为这种节点和当前时间片会相关。\n\n#### Node Time Series\n\n展示了某个特定节点随着时间的变化。\n","tags":["Visualization","Graph Visualization","Graph Embedding","Dynamic Graph"]},{"title":"杂谈：【转】傅里叶分析之掐死教程（完整版）","url":"/blog/2018/06/19/2018-06-19 傅里叶分析/","content":"\n> 作 者：韩 昊\n>\n> 知 乎：Heinrich\n>\n> 微 博：@花生油工人\n>\n> 知乎专栏：与时间无关的故事\n>\n> 谨以此文献给大连海事大学的吴楠老师，柳晓鸣老师，王新年老师以及张晶泊老师。\n>\n> **转载的同学请保留上面这句话，谢谢。如果还能保留文章来源就更感激不尽了。**\n>\n> 文章来源：[https://zhuanlan.zhihu.com/p/19763358](https://zhuanlan.zhihu.com/p/19763358)\n\n——更新于 2014.6.6，想直接看更新的同学可以直接跳到第四章————\n\n我保证这篇文章和你以前看过的所有文章都不同，这是 12 年还在果壳的时候写的，但是当时没有来得及写完就出国了……于是拖了两年，嗯，我是拖延症患者……\n\n这篇文章的核心思想就是：\n\n**要让读者在不看任何数学公式的情况下理解傅里叶分析。**\n\n傅里叶分析不仅仅是一个数学工具，更是一种可以彻底颠覆一个人以前世界观的思维模式。但不幸的是，傅里叶分析的公式看起来太复杂了，所以很多大一新生上来就懵圈并从此对它深恶痛绝。老实说，这么有意思的东西居然成了大学里的杀手课程，不得不归咎于编教材的人实在是太严肃了。（您把教材写得好玩一点会死吗？会死吗？）所以我一直想写一个有意思的文章来解释傅里叶分析，有可能的话高中生都能看懂的那种。所以，不管读到这里的您从事何种工作，我保证您都能看懂，并且一定将体会到通过傅里叶分析看到世界另一个样子时的快感。至于对于已经有一定基础的朋友，也希望不要看到会的地方就急忙往后翻，仔细读一定会有新的发现。\n\n————以上是定场诗————\n\n下面进入正题：\n\n抱歉，还是要啰嗦一句：其实学习本来就不是易事，我写这篇文章的初衷也是希望大家学习起来更加轻松，充满乐趣。但是千万！千万不要把这篇文章收藏起来，或是存下地址，心里想着：以后有时间再看。这样的例子太多了，也许几年后你都没有再打开这个页面。无论如何，耐下心，读下去。这篇文章要比读课本要轻松、开心得多……\n\np.s.本文无论是 cos 还是 sin，都统一用“正弦波”（Sine Wave）一词来代表简谐波。\n\n## 一、什么是频域\n\n从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。但如果我告诉你，用另一种方法来观察世界的话，你会发现世界是永恒不变的，你会不会觉得我疯了？我没有疯，这个静止的世界就叫做频域。\n\n先举一个**公式上并非很恰当**，但意义上再贴切不过的例子：\n\n在你的理解中，一段音乐是什么呢？\n\n![image-20190103095039179](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095039179.png)\n\n这是我们对音乐最普遍的理解，一个随着时间变化的震动。但我相信对于乐器小能手们来说，音乐更直观的理解是这样的：\n\n![image-20190103095054980](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095054980.png)\n\n好的！下课，同学们再见。\n\n是的，其实这一段写到这里已经可以结束了。上图是音乐在时域的样子，而下图则是音乐在频域的样子。所以频域这一概念对大家都从不陌生，只是从来没意识到而已。\n\n现在我们可以回过头来重新看看一开始那句痴人说梦般的话：世界是永恒的。\n\n将以上两图简化：\n\n时域：\n\n![image-20190103095104598](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095104598.png)\n\n频域：\n\n![image-20190103095115241](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095115241.png)\n\n在时域，我们观察到钢琴的琴弦一会上一会下的摆动，就如同一支股票的走势；而在频域，只有那一个永恒的音符。\n\n所以\n\n**你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。**\n\n抱歉，这不是一句鸡汤文，而是黑板上确凿的公式：傅里叶同学告诉我们，任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。在第一个例子里我们可以理解为，利用对不同琴键不同力度，不同时间点的敲击，可以组合出任何一首乐曲。\n\n而贯穿时域与频域的方法之一，就是传中说的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)，我们从简单的开始谈起。\n\n## 二、傅里叶级数(Fourier Series)的频谱\n\n还是举个栗子并且有图有真相才好理解。\n\n如果我说我能用前面说的正弦曲线波叠加出一个带 90 度角的矩形波来，你会相信吗？你不会，就像当年的我一样。但是看看下图：\n\n![image-20190103095128711](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095128711.png)\n\n第一幅图是一个郁闷的正弦波$cos(x)$\n\n第二幅图是 2 个卖萌的正弦波的叠加\n\n第三幅图是 4 个发春的正弦波的叠加\n\n第四幅图是 10 个便秘的正弦波的叠加\n\n随着正弦波数量逐渐的增长，他们最终会叠加成一个标准的矩形，大家从中体会到了什么道理？\n\n（只要努力，弯的都能掰直！）\n\n随着叠加的递增，所有正弦波中上升的部分逐渐让原本缓慢增加的曲线不断变陡，而所有正弦波中下降的部分又抵消了上升到最高处时继续上升的部分使其变为水平线。一个矩形就这么叠加而成了。但是要多少个正弦波叠加起来才能形成一个标准 90 度角的矩形波呢？不幸的告诉大家，答案是无穷多个。（上帝：我能让你们猜着我？）\n\n不仅仅是矩形，你能想到的任何波形都是可以如此方法用正弦波叠加起来的。这是没\n有接触过傅里叶分析的人在直觉上的第一个难点，但是一旦接受了这样的设定，游戏就开始有意思起来了。\n\n还是上图的正弦波累加成矩形波，我们换一个角度来看看：\n\n![image-20190103095847952](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095847952.png)\n\n在这几幅图中，最前面黑色的线就是所有正弦波叠加而成的总和，也就是越来越接近矩形波的那个图形。而后面依不同颜色排列而成的正弦波就是组合为矩形波的各个分量。这些正弦波按照频率从低到高从前向后排列开来，而每一个波的振幅都是不同的。一定有细心的读者发现了，每两个正弦波之间都还有一条直线，那并不是分割线，而是振幅为 0 的正弦波！也就是说，为了组成特殊的曲线，有些正弦波成分是不需要的。\n\n这里，不同频率的正弦波我们成为频率分量。\n\n好了，关键的地方来了！！\n\n如果我们把第一个频率最低的频率分量看作“1”，我们就有了构建频域的最基本单元。\n\n对于我们最常见的有理数轴，数字“1”就是有理数轴的基本单元。\n\n时域的基本单元就是“1 秒”，如果我们将一个角频率为$\\omega_0$的正弦波$cos(\\omega_0t)$看作基础，那么频域的基本单元就是$\\omega_0$。\n\n有了“1”，还要有“0”才能构成世界，那么频域的“0”是什么呢？$cos(0t)$就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0 频率也被称为直流分量，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。\n\n接下来，让我们回到初中，回忆一下已经死去的八戒，啊不，已经死去的老师是怎么定义正弦波的吧。\n\n![image-20190103095900752](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095900752.png)\n\n正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆\n\n![img](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/Fourier_series_square_wave_circles_animation.gif)\n\n点出去的朋友不要被 wiki 拐跑了，wiki 写的哪有这里的文章这么没节操是不是。\n\n介绍完了频域的基本组成单元，我们就可以看一看一个矩形波，在频域里的另一个模样了：\n\n![image-20190103095911726](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095911726.png)\n\n这是什么奇怪的东西？\n\n这就是矩形波在频域的样子，是不是完全认不出来了？教科书一般就给到这里然后留给了读者无穷的遐想，以及无穷的吐槽，其实教科书只要补一张图就足够了：频域图像，也就是俗称的频谱，就是——\n\n![image-20190103095920257](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095920257.png)\n\n再清楚一点：\n\n![image-20190103095927661](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103095927661.png)\n\n可以发现，在频谱中，偶数项的振幅都是 0，也就对应了图中的彩色直线。振幅为 0 的正弦波。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/Fourier_series_and_transform.gif)\n\n老实说，在我学傅里叶变换时，维基的这个图还没有出现，那时我就想到了这种表达方法，而且，后面还会加入维基没有表示出来的另一个谱——相位谱。\n\n但是在讲相位谱之前，我们先回顾一下刚刚的这个例子究竟意味着什么。记得前面说过的那句“世界是静止的”吗？估计好多人对这句话都已经吐槽半天了。想象一下，世界上每一个看似混乱的表象，实际都是一条时间轴上不规则的曲线，但实际这些曲线都是由这些无穷无尽的正弦波组成。我们看似不规律的事情反而是规律的正弦波在时域上的投影，而正弦波又是一个旋转的圆在直线上的投影。那么你的脑海中会产生一个什么画面呢？\n\n我们眼中的世界就像皮影戏的大幕布，幕布的后面有无数的齿轮，大齿轮带动小齿轮，小齿轮再带动更小的。在最外面的小齿轮上有一个小人——那就是我们自己。我们只看到这个小人毫无规律的在幕布前表演，却无法预测他下一步会去哪。而幕布后面的齿轮却永远一直那样不停的旋转，永不停歇。这样说来有些宿命论的感觉。说实话，这种对人生的描绘是我一个朋友在我们都是高中生的时候感叹的，当时想想似懂非懂，直到有一天我学到了傅里叶级数……\n\n## 三、傅里叶级数（Fourier Series）的相位谱\n\n上一章的关键词是：从侧面看。这一章的关键词是：从下面看。\n\n在这一章最开始，我想先回答很多人的一个问题：傅里叶分析究竟是干什么用的？这段相对比较枯燥，已经知道了的同学可以直接跳到下一个分割线。\n\n先说一个最直接的用途。无论听广播还是看电视，我们一定对一个词不陌生——频道。频道频道，就是频率的通道，不同的频道就是将不同的频率作为一个通道来进行信息传输。下面大家尝试一件事：\n\n先在纸上画一个$sin(x)$，不一定标准，意思差不多就行。不是很难吧。\n\n好，接下去画一个$sin(3x)+sin(5x)$的图形。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-19/13949915.jpg)\n\n别说标准不标准了，曲线什么时候上升什么时候下降你都不一定画的对吧？\n\n好，画不出来不要紧，我把$sin(3x)+sin(5x)$的曲线给你，但是前提是你不知道这个曲线的方程式，现在需要你把$sin(5x)$给我从图里拿出去，看看剩下的是什么。这基本是不可能做到的。\n\n但是在频域呢？则简单的很，无非就是几条竖线而已。\n\n所以很多在时域看似不可能做到的数学操作，在频域相反很容易。这就是需要傅里叶变换的地方。尤其是从某条曲线中去除一些特定的频率成分，这在工程上称为滤波，是信号处理最重要的概念之一，只有在频域才能轻松的做到。\n\n再说一个更重要，但是稍微复杂一点的用途——求解微分方程。（这段有点难度，看不懂的可以直接跳过这段）微分方程的重要性不用我过多介绍了。各行各业都用的到。但是求解微分方程却是一件相当麻烦的事情。因为除了要计算加减乘除，还要计算微分积分。而傅里叶变换则可以让微分和积分在频域中变为乘法和除法，大学数学瞬间变小学算术有没有。\n\n傅里叶分析当然还有其他更重要的用途，我们随着讲随着提。\n\n————————————————————————————————————\n\n下面我们继续说相位谱：\n\n通过时域到频域的变换，我们得到了一个从侧面看的频谱，但是这个频谱并没有包含时域中全部的信息。因为频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位。基础的正弦波$A sin(\\omega t+\\theta)$中，振幅，频率，相位缺一不可，不同相位决定了波的位置，所以对于频域分析，仅仅有频谱（振幅谱）是不够的，我们还需要一个相位谱。那么这个相位谱在哪呢？我们看下图，这次为了避免图片太混论，我们用 7 个波叠加的图。\n\n![image-20190103100013714](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103100013714.png)\n\n鉴于正弦波是周期的，我们需要设定一个用来标记正弦波位置的东西。在图中就是那些小红点。小红点是距离频率轴最近的波峰，而这个波峰所处的位置离频率轴有多远呢？为了看的更清楚，我们将红色的点投影到下平面，投影点我们用粉色点来表示。当然，这些粉色的点只标注了波峰距离频率轴的距离，并不是相位。\n\n![image-20190103100025377](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103100025377.png)\n\n这里需要纠正一个概念：时间差并不是相位差。如果将全部周期看作$2\\pi$或者 360 度的话，相位差则是时间差在一个周期中所占的比例。我们将时间差除周期再乘$2\\pi$，就得到了相位差。\n\n在完整的立体图中，我们将投影得到的时间差依次除以所在频率的周期，就得到了最下面的相位谱。所以，频谱是从侧面看，相位谱是从下面看。下次偷看女生裙底被发现的话，可以告诉她：“对不起，我只是想看看你的相位谱。”\n\n注意到，相位谱中的相位除了 0，就是$\\pi$。因为$cos(t+\\pi)=-cos(t)$，所以实际上相位为$\\pi$的波只是上下翻转了而已。对于周期方波的傅里叶级数，这样的相位谱已经是很简单的了。另外值得注意的是，由于$cos(t+2\\pi)=cos(t)$，所以相位差是周期的，$\\pi$和$3\\pi$，$5\\pi$，$7\\pi$都是相同的相位。人为定义相位谱的值域为$(-\\pi,\\pi]$，所以图中的相位差均为$\\pi$。\n\n最后来一张大集合：\n\n![image-20190103100035862](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103100035862.png)\n\n## **四、傅里叶变换（Fourier Transformation）**\n\n相信通过前面三章，大家对频域以及傅里叶级数都有了一个全新的认识。但是文章在一开始关于钢琴琴谱的例子我曾说过，这个栗子是一个公式错误，但是概念典型的例子。所谓的公式错误在哪里呢？\n\n傅里叶级数的本质是将一个周期的信号分解成无限多分开的（离散的）正弦波，但是宇宙似乎并不是周期的。曾经在学数字信号处理的时候写过一首打油诗：\n\n> 往昔连续非周期，\n>\n> 回忆周期不连续，\n>\n> 任你 ZT、DFT，\n>\n> 还原不回去。\n\n（请无视我渣一样的文学水平……）\n\n在这个世界上，有的事情一期一会，永不再来，并且时间始终不曾停息地将那些刻骨铭心的往昔连续的标记在时间点上。但是这些事情往往又成为了我们格外宝贵的回忆，在我们大脑里隔一段时间就会周期性的蹦出来一下，可惜这些回忆都是零散的片段，往往只有最幸福的回忆，而平淡的回忆则逐渐被我们忘却。因为，往昔是一个连续的非周期信号，而回忆是一个周期离散信号。\n\n是否有一种数学工具将连续非周期信号变换为周期离散信号呢？抱歉，真没有。\n\n比如傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。这句话比较绕嘴，实在看着费事可以干脆回忆第一章的图片。\n\n而在我们接下去要讲的傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。\n\n算了，还是上一张图方便大家理解吧：\n\n![image-20190103100050393](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103100050393.png)\n\n或者我们也可以换一个角度理解：傅里叶变换实际上是对一个周期无限大的函数进行傅里叶变换。\n\n所以说，钢琴谱其实并非一个连续的频谱，而是很多在时间上离散的频率，但是这样的一个贴切的比喻真的是很难找出第二个来了。\n\n因此在傅里叶变换在频域上就从离散谱变成了连续谱。那么连续谱是什么样子呢？\n\n**你见过大海么？**\n\n为了方便大家对比，我们这次从另一个角度来看频谱，还是傅里叶级数中用到最多的那幅图，我们从频率较高的方向看。\n\n![image-20190103123022065](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123022065.png)\n\n以上是离散谱，那么连续谱是什么样子呢？\n\n尽情的发挥你的想象，想象这些离散的正弦波离得越来越近，逐渐变得连续……\n\n直到变得像波涛起伏的大海：\n\n![image-20190103123030296](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123030296.png)\n\n很抱歉，为了能让这些波浪更清晰的看到，我没有选用正确的计算参数，而是选择了一些让图片更美观的参数，不然这图看起来就像屎一样了。\n\n不过通过这样两幅图去比较，大家应该可以理解如何从离散谱变成了连续谱的了吧？原来离散谱的叠加，变成了连续谱的累积。所以在计算上也从求和符号变成了积分符号。\n\n不过，这个故事还没有讲完，接下去，我保证让你看到一幅比上图更美丽壮观的图片，但是这里需要介绍到一个数学工具才能然故事继续，这个工具就是——\n\n## 五、宇宙耍帅第一公式：欧拉公式\n\n虚数$i$这个概念大家在高中就接触过，但那时我们只知道它是-1 的平方根，可是它真正的意义是什么呢?\n\n![image-20190103123039569](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123039569.png)\n\n这里有一条数轴，在数轴上有一个红色的线段，它的长度是 1。当它乘以 3 的时候，它的长度发生了变化，变成了蓝色的线段，而当它乘以-1 的时候，就变成了绿色的线段，或者说线段在数轴上围绕原点旋转了 180 度。\n\n我们知道乘-1 其实就是乘了两次$i$使线段旋转了 180 度，那么乘一次$i$呢——答案很简单——旋转了 90 度。\n\n![image-20190103123046729](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123046729.png)\n\n同时，我们获得了一个垂直的虚数轴。实数轴与虚数轴共同构成了一个复数的平面，也称复平面。这样我们就了解到，乘虚数 i 的一个功能——旋转。\n\n现在，就有请宇宙第一耍帅公式欧拉公式隆重登场——\n\n$$\ne^{ix}=cosx+isinx\n$$\n\n这个公式在数学领域的意义要远大于傅里叶分析，但是称它为宇宙第一耍帅公式是因为它的特殊形式——当 x 等于$\\pi$的时候。\n\n$$\ne^{i\\pi}+1=0\n$$\n\n经常有理工科的学生为了跟妹子表现自己的学术功底，用这个公式来给妹子解释数学之美：”石榴姐你看，这个公式里既有自然底数 e，自然数 1 和 0，虚数$i$还有圆周率$\\pi$，它是这么简洁，这么美丽啊！“但是姑娘们心里往往只有一句话：”臭屌丝……“\n\n这个公式关键的作用，是将正弦波统一成了简单的指数形式。我们来看看图像上的涵义：\n\n![image-20190103123058098](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123058098.png)\n\n欧拉公式所描绘的，是一个随着时间变化，在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。\n\n关于复数更深的理解，大家可以参考：\n\n[复数的物理意义是什么？](http://www.zhihu.com/question/23234701/answer/26017000)\n\n这里不需要讲的太复杂，足够让大家理解后面的内容就可以了。\n\n## **六、指数形式的傅里叶变换**\n\n有了欧拉公式的帮助，我们便知道：**正弦波的叠加**，也可以理解为**螺旋线的叠加**在实数空间的投影。而螺旋线的叠加如果用一个形象的栗子来理解是什么呢？\n\n**光波**\n\n高中时我们就学过，自然光是由不同颜色的光叠加而成的，而最著名的实验就是牛顿师傅的三棱镜实验：\n\n![image-20190103123107601](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103123107601.png)\n\n所以其实我们在很早就接触到了光的频谱，只是并没有了解频谱更重要的意义。\n\n但不同的是，傅里叶变换出来的频谱不仅仅是可见光这样频率范围有限的叠加，而是频率从 0 到无穷所有频率的组合。\n\n这里，我们可以用两种方法来理解正弦波：\n\n第一种前面已经讲过了，就是螺旋线在实轴的投影。\n\n另一种需要借助欧拉公式的另一种形式去理解：\n\n将以上两式相加再除 2，得到：\n\n这个式子可以怎么理解呢？\n\n我们刚才讲过，$e^{it}$可以理解为一条逆时针旋转的螺旋线，那么$e^{-it}$则可以理解为一条顺时针旋转的螺旋线。而$cos(t)$则是这两条旋转方向不同的螺旋线叠加的一半，因为这两条螺旋线的虚数部分相互抵消掉了！\n\n举个例子的话，就是极化方向不同的两束光波，磁场抵消，电场加倍。\n\n这里，逆时针旋转的我们称为正频率，而顺时针旋转的我们称为负频率（注意不是复频率）。\n\n好了，刚才我们已经看到了大海——连续的傅里叶变换频谱，现在想一想，连续的螺旋线会是什么样子：\n\n想象一下再往下翻：\n\n|\n\n|\n\n|\n\n|\n\n|\n\n|\n\n|\n\n|\n\n|\n\n![image-20190103101451033](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103101451033.png)\n\n是不是很漂亮？\n\n你猜猜，这个图形在时域是什么样子？\n\n![image-20190103101458758](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103101458758.png)\n\n哈哈，是不是觉得被狠狠扇了一个耳光。数学就是这么一个把简单的问题搞得很复杂的东西。\n\n顺便说一句，那个像大海螺一样的图，为了方便观看，我仅仅展示了其中正频率的部分，负频率的部分没有显示出来。\n\n如果你认真去看，海螺图上的每一条螺旋线都是可以清楚的看到的，每一条螺旋线都有着不同的振幅（旋转半径），频率（旋转周期）以及相位。而将所有螺旋线连成平面，就是这幅海螺图了。\n\n好了，讲到这里，相信大家对傅里叶变换以及傅里叶级数都有了一个形象的理解了，我们最后用一张图来总结一下：\n\n![image-20190103101506672](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/20190103/image-20190103101506672.png)\n\n好了，傅里叶的故事终于讲完了，下面来讲讲我的故事：\n\n这篇文章第一次被写下来的地方你们绝对猜不到在哪，是在一张高数考试的卷子上。当时为了刷分，我重修了高数（上），但是后来时间紧压根没复习，所以我就抱着裸考的心态去了考场。但是到了考场我突然意识到，无论如何我都不会比上次考的更好了，所以干脆写一些自己对于数学的想法吧。于是用了一个小时左右的时间在试卷上洋洋洒洒写了本文的第一草稿。\n\n你们猜我的了多少分？\n\n6 分\n\n没错，就是这个数字。而这 6 分的成绩是因为最后我实在无聊，把选择题全部填上了 C，应该是中了两道，得到了这宝贵的 6 分。说真的，我很希望那张卷子还在，但是应该不太可能了。\n\n那么你们猜猜我第一次信号与系统考了多少分呢？\n\n45 分\n\n没错，刚刚够参加补考的。但是我心一横没去考，决定重修。因为那个学期在忙其他事情，学习真的就抛在脑后了。但是我知道这是一门很重要的课，无论如何我要吃透它。说真的，信号与系统这门课几乎是大部分工科课程的基础，尤其是通信专业。\n\n在重修的过程中，我仔细分析了每一个公式，试图给这个公式以一个直观的理解。虽然我知道对于研究数学的人来说，这样的学习方法完全没有前途可言，因为随着概念愈加抽象，维度越来越高，这种图像或者模型理解法将完全丧失作用。但是对于一个工科生来说，足够了。\n\n后来来了德国，这边学校要求我重修信号与系统时，我彻底无语了。但是没办法，德国人有时对中国人就是有种藐视，觉得你的教育不靠谱。所以没办法，再来一遍吧。\n\n这次，我考了满分，而及格率只有一半。\n\n老实说，数学工具对于工科生和对于理科生来说，意义是完全不同的。工科生只要理解了，会用，会查，就足够了。但是很多高校却将这些重要的数学课程教给数学系的老师去教。这样就出现一个问题，数学老师讲得天花乱坠，又是推理又是证明，但是学生心里就只有一句话：学这货到底干嘛用的？\n\n缺少了目标的教育是彻底的失败。\n\n在开始学习一门数学工具的时候，学生完全不知道这个工具的作用，现实涵义。而教材上有只有晦涩难懂，定语就二十几个字的概念以及看了就眼晕的公式。能学出兴趣来就怪了！\n\n好在我很幸运，遇到了大连海事大学的吴楠老师。他的课全程来看是两条线索，一条从上而下，一条从下而上。先讲本门课程的意义，然后指出这门课程中会遇到哪样的问题，让学生知道自己学习的某种知识在现实中扮演的角色。然后再从基础讲起，梳理知识树，直到延伸到另一条线索中提出的问题，完美的衔接在一起！\n\n这样的教学模式，我想才是大学里应该出现的。\n\n最后，写给所有给我点赞并留言的同学。真的谢谢大家的支持，也很抱歉不能一一回复。因为知乎专栏的留言要逐次加载，为了看到最后一条要点很多次加载。当然我都坚持看完了，只是没办法一一回复。\n\n本文只是介绍了一种对傅里叶分析新颖的理解方法，对于求学，还是要踏踏实实弄清楚公式和概念，学习，真的没有捷径。但至少通过本文，我希望可以让这条漫长的路变得有意思一些。\n\n最后，祝大家都能在学习中找到乐趣。…\n","tags":["Math"]},{"title":"杂谈：拉普拉斯矩阵和代数连通度","url":"/blog/2018/06/19/2018-06-19 拉普拉斯矩阵和代数连通度/","content":"\n## 拉普拉斯矩阵\n\n首先考虑图的关联矩阵（incidence matrix），$C=C(G)$。其中每一列表示的是图的节点，每一行表示的图的一条边。\n\n![image-20180623194254598](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-114255.png)\n\n然后我们将这个关联矩阵可以写成：\n\n$$\nC=\\begin{bmatrix}e_0^T\\\\\\ e_1^T\\\\\\ \\vdots\\\\\\ e_{m-1}^T\\end{bmatrix}\n$$\n\n其中，$e_k$是一个边向量，表达了从节点 i 到节点 j 的一条边$[\\cdots, \\underbrace{1}_i, \\cdots, \\underbrace{-1}_j, \\cdots]$，其余位置都为 0。所以：\n\n$$\nC^TC=\\sum_{k=0}^{m-1}e_k \\cdot e_k^T\n$$\n\n![image-20180623195155250](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-115155.png)\n\n考虑上方这个矩阵，我们会发现它的对角线上，$ii$这个位置和$jj$这个位置，会都为 1，其实表达了在该图中，节点 i 和 j 位置的度数为 1。而其余两个位置$ij$和$ji$则表达了该位置存在一条边。此时，该矩阵损失了方向信息。\n\n当对这一系列矩阵求和，我们就得到了图的拉普拉斯矩阵，对角线表达了节点的度数，而非对角线部分则是边的信息。\n\n当然，在有权图中，上面的关联矩阵，就不应该表示成 1 和-1，而应该是边的权重的平方根。\n\n那么，拉普拉斯矩阵就可以定义成：\n\n假设一个无向正权图$G=(V,E)$，其邻接矩阵表示成$A$，每个元素代表边的权重。其度矩阵表示成$D$，是一个对角矩阵，对角线的元素则是每个节点所带的连接边的权重和（$d_{ij}=\\sum_kw_{ik}$），这里不考虑自环。那么拉普拉斯矩阵（Laplacian）就是$L=D-A$。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-19/21849016.jpg)\n\n## 弹簧模型\n\n![image-20180623222642725](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-142643.png)\n\n首先，假设一组固定的杆子，他们上面套上了一些可以滑动的滑块，这些滑块的质量都是$m$，滑块之间互相用弹簧链接。\n\n当某个滑块$i$上升到$x_i$的位置时，该滑块受到的弹簧拉力应该是：$-k(x_i-x_{i-1})-k(x_i-x_{i+1})=-k(-x_{i-1}+2x_i-x_{i+1})$。根据牛顿第一定律，滑块受到的拉力又应该是$m_ia_i=m_i\\frac{d^2}{dt^2}x_i(t)$\n\n![image-20180623223323008](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-143323.png)\n\n将所有滑块在时刻$t$的位置写成向量形式：\n\n$$\n\\vec{x}(t)=\\begin{bmatrix}x_0(t)\\\\\\ x_2(t)\\\\\\ \\vdots\\\\\\ x_{n-1}(t) \\end{bmatrix}\n$$\n\n那么，拉力可以被写成：\n\n$$\n-k\\begin{bmatrix}\n1 & -1 \\\\\\\n-1 & 2 & -1 \\\\\\\n& -1  & 2 & -1 \\\\\\\n& & & \\ddots \\\\\\\n& & & -1 & 2 & -1 \\\\\\\n& & & & -1 & 1\n\\end{bmatrix}\\cdot \\vec{x}\n$$\n\n该矩阵是一个$t \\times n$列的矩阵，该矩阵就可以被看做一个$n$个点互相连接的单链条的图的拉普拉斯矩阵：\n\n![image-20180623232712358](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-152712.png)\n\n最终每个点的位置，会呈现出一种正弦波的变化趋势，事实上，这个变化趋势是由多个正弦或者余弦波的叠加组成，也就是可以通过傅里叶变化，转换为频域上的模式，每一种模式和该拉普拉斯矩阵的特征向量所给定。\n\n## 代数连通性\n\n首先介绍一些拉普拉斯矩阵的特性：\n\n1. 拉普拉斯矩阵是对称的。\n\n2. 拉普拉斯矩阵的特征值都是实数并且非负的，而且对应的特征向量都是实数并且正交的。按照惯例，会对这些特征值进行排序：$\\lambda_{n-1} \\geq \\lambda_{n-2} \\geq \\cdots \\geq \\lambda_0 \\geq 0$\n\n3. 如果$G$有$k$个连通子图，当且仅当：\n\n    $$\n    \\lambda_{n-1} = \\lambda_{n-2} = \\cdots = \\lambda_0 = 0\n    $$\n\n    （这一点也说明了，拉普拉斯矩阵的特征值和图的连通性有一定关联）\n\n4. 对于一个有$n$个点的图$G$，将该图分成正负两部分。\n   ![image-20180624000634025](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-23-160634.png)\n   记：\n    $$\n    \\begin{align}\n    v_+&=\\{\\text{vertices in }+\\}\\\\\\\n    v_-&=\\{\\text{vertices in }-\\}\\\\\\\n    \\vec{x} &= \\begin{bmatrix}x_0\\\\\\ x_1\\\\\\ \\vdots\\\\\\ x_{n-1} \\end{bmatrix}\n    s.t. x_i=\\begin{cases}\n    &+1, &\\text{if i $\\in V_+$} \\\\\\\n    &-1, &\\text{if i $\\in V_-$}\n    \\end{cases}\n    \\end{align}\n    $$\n    那么，连通+-两部分的那些切割边的数量，则可以用$\\frac{1}{4} x^TL(G)x​$表示。\n\n## Courant minimax principle\n\n承接上一节，假如需要最小化正负两部分的切割边，则我们需要$min \\frac{1}{4} x^TL(G)x$\n\n**定理**：给定任意实向量$\\vec{y}$，对$y$进行标准化，使得$y^Ty=n$，且$\\sum_iy_i=0$\n\n那么，使得$\\frac{1}{4} x^TL(G)x$最小的$y$满足以下条件：\n\n$$\n\\frac{1}{4} y^TL(G)y = \\frac{1}{4} n \\vec{q}_1^TL(G)\\vec{q}_1=\\frac{1}{4}n\\lambda_1\n$$\n\n其中，$\\vec{q}_1$和$\\lambda_1$是拉普拉斯矩阵的第二个特征向量和对应的特征值。\n\n于是，$G$的任意一种二分切割方法，最小只能切割出$\\frac{1}{4}n\\lambda_1$条切割边。\n\n假如，我们要找到，拥有最小切割边的分割方式，我们可以：\n\n1. 创建$G$的拉普拉斯矩阵$L(G)$\n\n2. 计算该矩阵的第二个特征向量$(\\lambda_1, \\vec{q}_1)$\n\n3. 用该特征向量的正负来表达$x$，就能得到想要的分割方式。也即：\n    $$\n    x(i) \\leftarrow sign(\\vec{q}_1(i))\n    $$\n","tags":["Graph Mining","Math","Graph"]},{"title":"杂谈：图的小波变换","url":"/blog/2018/06/19/2018-06-19 图的小波变换/","content":"\n> 翻译自论文：Wavelet-based Visual Analysis of Dynamic Networks，2017 TVCG\n\n## 图的傅里叶变换\n\n### **Graph Fourier Transform**\n\n关于傅里叶变换请看：[【转】傅里叶分析之掐死教程（完整版）](https://jackieanxis.github.io/blog-others/2018/06/19/%E5%82%85%E9%87%8C%E5%8F%B6%E5%88%86%E6%9E%90/)\n\n关于拉普拉斯矩阵的一些特性可以看我的另一篇博客：[拉普拉斯矩阵二分法](https://jackieanxis.github.io/blog-others/2018/06/19/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5%E4%BA%8C%E5%88%86%E6%B3%95/)\n\n假设一个无向正权图$G=(V,E)$，其邻接矩阵表示成$A$，每个元素代表边的权重。其度矩阵表示成$D$，是一个对角矩阵，对角线的元素则是每个节点所带的连接边的权重和（$d_{ij}=\\sum_kw_{ik}$），这里不考虑自环。那么拉普拉斯矩阵（Laplacian）就是$L=D-A$。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-19/21849016.jpg)\n\n拉普拉斯矩阵是对称的半正定矩阵。因此有一组标准正交的特征向量$\\{u_i\\}, i \\in \\{1,…,n\\}$，对应一组递增的非负实特征值$\\{\\lambda_i\\},i \\in \\{1,…n\\},0=\\lambda_1<\\lambda_2\\leq\\cdots\\leq\\lambda_n$。小的$\\lambda_i$就对应了傅里叶变换中的低频。\n\n假如给定一个将节点$V$映射成实数$\\Bbb R$的实函数$f$，那么在频率$\\lambda_l$上，$f$对应的傅里叶变换可以定义成：\n\n$$\n\\hat{f}(l)=u_l^T \\cdot f = \\sum_{j=1}^n u_l(j)f(j)\n$$\n\n其中，$u_l(j)$是特征向量$u_l$中$j$位置的值，$f(j)$则是节点$j$的函数值。\n\n对比原连续傅里叶变换从时域转换成频域：\n\n$$\nF(\\omega)=\\int_{-\\infty}^{\\infty}f(t)e^{-i \\omega t}dt\n$$\n\n那么图的傅里叶变换就是从节点转换成对应的拉普拉斯矩阵特征值上。\n\n## 谱图小波变换\n\n### **Spectral Graph Wavelet Transform**\n\n小波变换参考：[形象易懂讲解算法 I——小波变换](https://zhuanlan.zhihu.com/p/22450818)\n\nHammond 于 2011 年提出了这个概念：Wavelets on graphs via spectral graph theory。\n\n图的小波变换公式：\n\n$$\nW_f(s,j)=\\sum_{l=1}^ng(s\\lambda_l)\\hat f(l)u_l(j)\n$$\n\n上述的公式中，$j$还是代表了节点，在解释$s$之前，我们来说明一下函数$g$：\n\n$$\ng(x) = \\begin{cases}\nx^2, &\\text{for $x < 1$} \\\\\\\n-5+11x-6x^2+x^3, &\\text{for $1\\leq x \\leq 2$}\\\\\\\n4x^{-2}, &\\text{for $2 < x$}\n\\end{cases}\n$$\n\n函数形状为：\n\n![image-20180619231116668](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-19-image-20180619231116668.png)\n\n可以得知，当$x$在$[1,2]$之间时，$g(x)$会较大。所以小的$s$值，会对大的$\\lambda_l$（对局部特征描述的更详细）更有效果，而大的$s$则对小的（也就是低频的）$\\lambda_l$（粗糙的描述了节点的局部特征）更有效果。\n\n我们知道，傅里叶变换仅仅将时域转换成频域，但无法知道特定时间的频域（因为它没有时间维度）；小波变换解决的问题就是能够知道特定时间上的频域是如何的，见[形象易懂讲解算法 I——小波变换](https://zhuanlan.zhihu.com/p/22450818)。\n\n以此类比：\n\n图的傅里叶变换中，我们将整个图转换成到了特征值上，用不同特征值的权重来表达了整张图，但无法对每个节点生成其特征值分布。\n\n而通过小波变换，可以获取每个节点上，不同$s$值的分布，也就代表了特征值的分布。\n\n特征值能够描述图的特性，比如特征值中 0 的个数表达了图中连通子图的数量，第二小的非零特征值可以用来描述二分最小切割边数量(代数连通度，algebraic connectivity，见另一篇博客[拉普拉斯矩阵和代数连通度](https://jackieanxis.github.io/blog-others/2018/06/19/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5%E5%92%8C%E4%BB%A3%E6%95%B0%E8%BF%9E%E9%80%9A%E5%BA%A6/)）。\n\n小的特征值（对应大的$s$）对全局的描述更强一些，大的特征值则对局部的描述更详细一些。\n\n通过对$s$的值进行采样，我们可以得到一组$s_{min}=s_1,s_2,\\ldots,s_r=s_{max}$，一般会取$s_{min}=2/\\lambda_n, s_{max}=40/\\lambda_n$，对应的$g(sx)$则被称为小波核（wavelet kernels）,生成的$W_f(s, j)$则被称为小波系数（wavelet coefficients）。\n\n#### 缩放函数 Scaling function\n\n缩放函数（$h(x)$）可以用来生成缩放函数系数（$S_f(j)$）是一种用来稳定的表达低频的傅里叶模式（Fourier modes，也就是相对较小的特征值）的方法。一般会跟上述的小波变换产生的 wavelet coefficients，$W_f(s_1, j), W_f(s_2, j), \\ldots, W_f(s_r,j)$组合，当成 wavelet coeffients，其中这个缩放函数（scaling function）则用于表达低频的傅里叶模式：$\\{S_f(j), W_f(s_r, j), \\ldots, W_f(s_1,j)\\}$\n\n这个缩放函数系数$S_f(j)$：\n\n$$\nS_f(j)=\\sum_{l=1}^nh(\\lambda_l)\\hat{f}(l)u_l(j)\n$$\n\n其中，缩放函数：\n\n$$\nh(x)=\\gamma exp(-(\\frac{10x}{0.3\\lambda_n})^4)\n$$\n\n### 小波系数的解释\n\n小波系数可以解释成在特定频率的原始信号的能量。传统的小波变换中，高频区域对邻域的表达更好一些，所以相邻点之间在高频区域会有较大的差别，但在低频区域的差别更平滑。在网络（或者说图）中，也是一样的。\n\n图的小波变换，能够为每个节点生成一组系数，代表了不同频率的能量。如下图所示，小波变换系数的分布更为平滑的节点，往往是低频节点（指的是低频率的小波系数更为突出的节点，图中浅绿色的节点），而反之，则是高频节点（高频系数更为突出，图中深绿色节点），小波系数分布不是很平滑，相邻的小波系数之间差距可能会较大。\n\n![image-20180624204457467](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-24-124458.png)\n","tags":["Graph Mining","Math","Graph"]},{"title":"JellyLens, Content-Aware Adaptive Lenses","url":"/blog/2018/06/17/2018-06-17 JellyLens- Content-Aware Adaptive Lenses/","content":"\n-   论文原文：JellyLens- Content-Aware Adaptive Lenses\n-   作者：Cyprien Pindat, Emmanuel Pietriga, Olivier Chapuis, Claude Puech\n-   发表刊物/会议：2012 TVCG\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-18/18705982.jpg)\n\n作者提出了 JellyLens，自适应的鱼眼透镜，根据内容来调整透镜形状，提高了焦点区域内容的可见性，又保留了较大部分的上下文区域。并进行了一个 user study 来证明其有效性。\n\n## 整体思路：\n\n1. 引出透镜，表达透镜的益处，然后说明现有透镜的缺点，总结本技术优势和本文贡献点\n2. 介绍相关工作：围绕 2D 的鱼眼，3D 的，以及自适应的鱼眼透镜外加其他领域的类似工作\n3. 方法概述：大概说明一下方法的思路\n4. 详细描述\n5. 评估（user study）\n6. 讨论和未来工作\n\n## INTRODUCTION\n\n数据量的增加，了解这些数据需要多层透镜来进行展示，以便用户对数据进行不同层次粒度的查看。\n\n三种技术：概览+细节，缩放和焦点上下文。其中最有名的焦点上下文就是鱼眼。\n\n现有的鱼眼技术，存在以下缺点：透镜的形状是固定的，因此带来空间问题。\n\n本文使用的 JellyLens，综合了 PathLens 和 AreaLens，前者能够根据焦点区域的特征进行自适应，后者则能够对焦点区与的物体进行重布局和重新缩放。\n\n贡献是：1）对任意形状的透镜进行建模的方法；2）两种基于兴趣区域的几何形状动态生成相关透镜形状的方法（PathLens 和 AreaLens）\n\n## RELATED WORK\n\n分别介绍了：distortion-oriented、magic lens filter、3D 等技术，之后又介绍了一个带有自适应的领域相关的技术。\n\n最后讲了一些图像领域的，content-aware 的工作。\n\n## GENERAL APPROACH\n\nJellyLens 能动态适应感兴趣区域，因此需要它能够采取任意形状的透镜。\n\n分成三步来进行自适应：1. 获取场景中需要感兴趣的对象的几何形状；2. 根据在可视化中的位置以及其附近的感兴趣的区域来确定透镜的形状，其中 PathLens 适合轮廓和路径，AreaLens 适合填充区域；3. 通过透镜渲染区域。\n\n## JELLYLENS MODELING AND RENDERING\n\n本章主要描述如何根据已有形状来建模透镜。\n\n将整个画面分成三个区域：上下文区域（context, $\\cal C$），过渡区域（transition, $\\cal T$）以及焦点区域（focus，$\\cal F$）。\n\n其中上下文区域，不存在扭曲；过渡区域的扭曲，则进行加权平衡；焦点区域的扭曲则用多个区域的组合来形成。\n\n本章最后描述了实现算法：C++和 OpenGL\n\n## ADAPTATION\n\n分别描述了生成 PathLens 和 AreaLens 的形状的算法。\n\n前者用来放大类似路径的对象（比如道路），效果类似于在蜘蛛网上的水滴。\n\n后者则是用来放大一整块填充区域。\n\n### PathLens\n\n在该种透镜下，透镜形状主要受两个因素的影响：离鼠标的距离和离最近的对象的距离（指的是可以被放大的那些对象，比如地图中的高速公路等）。\n\n文中用一个隐式函数来导出：当$f({\\bf x}) = lens({\\bf x - c}) + data({\\bf x})=s$时，就是边界。大概效果如下：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-18/72742188.jpg)\n\n### AreaLens\n\n相比于前者只考虑最近的对象，AreaLens 考虑了所有感兴趣的对象，更适合用来密集区域的块状填充对象。\n\n所有落在兴趣区域的对象都会有影响，而外面的则不影响。\n\n提出了四个设计需求：\n\n1. 放大的对象不能相互重叠\n2. 对象的移动应该平滑\n3. 拓扑信息应该更可能的保留\n4. 上下文区域的对象应该既不被移动也不被放大\n\n为了应对上述四个需求，分别用两种映射来进行：\n\n1. dispersion mapping，用来完成位移，使得被放大的那些对象有足够的空间。\n2. magnification mapping，用来完成放大离鼠标最近的那些对象（被称为放大对象，其余则被称为移动对象）\n\n-   **dispersion mapping**：1. 先对移动对象进行位移，位移向量会考虑所有方法对象，并进行加权；2. 缩小这些对象，保证不重叠\n-   **magnification mapping**：离鼠标越近的放大对象则被放的越大\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-18/33950652.jpg)\n\n## EVALUATION\n\n目标是证明相对固定透镜所拥有的潜在的优点（potential benefits）和缺点（pitfalls）\n\n比较了 AreaLens 和普通鱼眼（圆形，高斯核）\n\n任务是找寻视觉元素\n\n方法是：提出假设，证明不同因素的显著性\n\n最后也做了一个问卷评价\n\n## DISCUSSION AND FUTURE WORK\n\n除了总结工作之外，作者提出了两个 future work：1. 更多的 evaluation；2. 自定义感兴趣的对象\n","tags":["Visualization","Graph Visualization","Fisheye"]},{"title":"杂谈：快慢指针","url":"/blog/2018/06/13/2018-06-13 快慢指针/","content":"\n在做到[leetcode 287 题](https://leetcode.com/problems/find-the-duplicate-number/description/)时，遇到了这个问题：\n\n> Given an array _nums_ containing _n_ + 1 integers where each integer is between 1 and _n_ (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,3,4,2,2]\n> Output: 2\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [3,1,3,4,2]\n> Output: 3\n> ```\n>\n> **Note:**\n>\n> 1. You **must not** modify the array (assume the array is read only).\n> 2. You must use only constant, _O_(1) extra space.\n> 3. Your runtime complexity should be less than _O_(*n*2).\n> 4. There is only one duplicate number in the array, but it could be repeated more than once.\n\n看到了快慢指针这个解，最快能达到$O(N)$的时间复杂度，于是详细分析了一下这题。\n\n一般会用两个指针一起遍历数组，快指针每次移动 2 步，慢指针每次移动 1 步。就跟跑步一样，假如在这个链表当中存在环的话，就快指针总是会追上慢指针，这个时候刚好超过慢指针$n$圈，并且快指针跑过的距离刚好是慢指针的两倍。\n\n我们看图，慢指针从 A 开始，在 B 点进入了环中，经过$n$轮后，在 C 点和快指针相遇了。假设 AB 的长度是$a$，$BC$的长度是$b$，B 的循环的长度是$c$，那么从 B 点走到 C 点需要经过$c-b$\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-13/34029455.jpg)\n\n此时，慢指针走过的距离是$a+nc+b​$，快指针假设是$a+Nc+​$b，因为它们速度差是 2 倍，所以：\n\n$$\n\\begin{align}\n& 2(a+nc+b)=a+Nc+b\\\\\\\n\\Rightarrow & a=(N-2n)c-b\\\\\\\n\\Rightarrow & a=(N-2n-1)c+c-b\\\\\\\n\\Rightarrow & a+xc=(N-2n-1+x)c+c-b\n\\end{align}\n$$\n\n其中，$x$可以是任意大小。\n\n我们来解释一下上述结论：\n\n1. $a+xc$的意义就是，从 A 点出发，在 B 点进入循环，并经过$x$圈又回到 B 点\n2. $(N-2n-1+x)c+c-b$的意思则是：从 C 点继续向后走，走过$c-b$的长度后，回到 B 点，又经过$(N-2n-1+x)$圈回到 B 点\n3. 上述两者相同的意思是，此时指针又会共同指向 B 点，那么我们就找到了进入循环的点。\n\n在题中，我们可以将数组看成一个链表，比如[1,3,4,2,2]可以看成一个$1\\rightarrow3\\rightarrow2\\rightarrow4\\rightarrow2\\cdots$的链表（数组元素表示该元素指向的下一个元素的下标，如果看不懂，读代码就好）。然后我们就可以发现链表会在重复值那里进入循环，于是找到进入循环的点的时候，就可以找到重复值。\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function (nums) {\n    let slow = nums[0],\n        fast = nums[nums[0]],\n        t = nums[0]\n    while (slow != fast) {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    }\n    slow = nums[slow]\n    while (slow != t) {\n        slow = nums[slow]\n        t = nums[t]\n    }\n    return slow\n}\n```\n\n## 关于快慢指针的应用\n\n-   单向链表是否存在循环：只要快指针和慢指针相遇，则一定存在环\n-   寻找无环链表的中位数：当快指针指向链尾时，慢指针指向链中\n-   找链表中环的入口点：如上所述\n-   两个单向无环链表是否相交：将其中一个链表首尾相连，另一个链表开始进行快慢指针遍历，就转化成了第一个问题\n","tags":["Coding","Algorithm"]},{"title":"SchemeLens, A Content-Aware Vector-Based Fisheye Technique for Navigating Large Systems Diagrams","url":"/blog/2018/06/09/2018-06-09 SchemeLens, A Content-Aware Vector-Based Fisheye Technique for Navigating Large Systems Diagrams/","content":"\n-   论文原文：SchemeLens: A Content-Aware Vector-Based Fisheye Technique for Navigating Large Systems Diagrams\n-   作者：[Aurélie Cohé](https://dblp.uni-trier.de/pers/c/Coh=eacute=:Aur=eacute=lie)，[Bastien Liutkus](http://dblp.uni-trier.de/pers/hd/l/Liutkus:Bastien), [Gilles Bailly](https://dblp.uni-trier.de/pers/b/Bailly:Gilles) , [James Egan](https://dblp.uni-trier.de/pers/e/Egan:James)，[Eric Lecolinet](https://dblp.uni-trier.de/pers/l/Lecolinet:Eric)\n-   发表刊物/会议：2016 TVCG\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-10/50334813.jpg)\n\n## 整体套路介绍：\n\n```flow\nst=>start: Abstract\ne=>end: Conclusion\nop1=>operation: Introduction 背景技术，本文技术优点，贡献点\nop2=>operation: Motivation 动机的来源，现有的缺点，设计目标\nop3=>operation: Related Wrok 分模块介绍相关工作\nop4=>operation: Techniques 详细介绍技术，技术的介绍都是由设计目标启发的\nop5=>operation: User Study 两个实验，分别论证有效性和工作原理\nop6=>operation: Discussion 围绕着实验和一些设计原则展开\n\nst->op1->op2->op3->op4->op5->op6->e\n```\n\n## Introduction\n\n第一段：介绍了焦点上下文技术，往往需要在空间和信息之间平衡（对局部增加空间，意味着其他地方的信息损失）\n\n第二段：提出本文所使用的 SchemeLens，及其优点：向量化缩放（保持个体的形态，又不会增加空白空间）和考虑拓扑空间\n\n第三段：提及简单的向量化缩放的缺点（重叠），简单介绍了解决问题的几个原则。\n\n第四段：交互式的鱼眼技术的优点以及贡献\n\n## Motivation\n\n第一段：采访了工程师\n\n第二段：提出一般的系统图纸所存在的缺点\n\n第三段：提出了一些系统图纸所的特点\n\n第四段：三个目标：感兴趣节点的 readability，最小化图纸结构的扭曲，在交互期间图纸结构的稳定性\n\n第五段：详细描述了设计目标\n\n## Related Work\n\n分别描述了：鱼眼透镜，拓扑相关的鱼眼透镜，自适应透镜，导航技术以及感知&可读性的相关工作。\n\n## SchemeLens 技术描述\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-9/95973080.jpg)\n\nSchemelens 综合了三个模块来做焦点上下文：\n\n1. 放大透镜：\n\n    靠近鼠标的聚焦区域，会被几何放大，给定节点的放大率和其到中心的距离负相关。\n\n2. 拓扑透镜：\n\n    \b 在鼠标下面的元素会被放大，然后沿着该元素所在的路径进行放大，测地距离（geodesic distance，也就是拓扑距离）远的放大率低。该机制有利于调节相距比较远的节点。\n\n3. 用户意图：移动鼠标时，只有沿着该路径并且和鼠标移动方向一致的节点会被放大，\n\n### 焦距区域和可读性\n\n#### 自适应的聚焦区域\n\n聚焦区域是放大透镜的聚焦区域和拓扑透镜的聚焦区域的并集。\n\n每个节点自身的放大，都是均匀的。\n\n为了防止距离焦点近的节点放大后有重叠，但又不能让这些节点的位移过大，作者使用了弹簧模型。\n\n**内容感知的缩放**：为了防止大的节点在放大之后变的太大，使用了一个反指数函数。\n\n#### 聚焦区域的大小\n\n放大效果所作用的节点应该被限制在一个合理数量以内。但这个『合理』受到很多因素的影响。\n\n作者采用了限制『测地距离』的方式来限制节点数量。用户可以通过鼠标滚轮或者键盘来控制参数。\n\n### 上下文区域和畸变\n\n使用了三种启发式的目标来控制畸变：**空间稳定性**（spatial steability），**美学属性**（aesthetic properties），**时间稳定性**（temporal stability）\n\n#### 美学规则\n\n作者为整个图创建了一个层次结构：节点，包含这些节点的直线，包含这些直线的子路径。三条美学规则分别是：\n\n1. 对齐。同一直线的节点要对齐（下图左），不同直线但在同一个局部环中的节点也要对齐（下图中），在同一直线上的交点也要对齐（下图右）。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-9/69993075.jpg)\n\n2. 正交。边之间的正交被保留。\n\n3. 边交叉。不能引入新的边交叉。\n\n#### 节点位移\n\n因为放大效应不会放大空白区域，所以空白区域会被填充，反而能提高聚焦区域和上下文区域的连续性。\n\n#### 空间和时间的连续性\n\n如果没有适当的预防措施，焦点的略微变换就会引发节点位置或大小的巨大变动。针对位置和大小，作者采用了两种不同的策略：\n\n1. 位置：弹簧模型能提供时间上的连续性，以平滑交互；\n2. 大小：因为放大作用同时由两种不同的透镜同时产生（放大透镜和拓扑透镜），所以可能（1）即使用户用光标靠近它，节点的大小也可能减小，（2）节点的比例可能在某些边界处突然变化。\n\n#### 捕捉用户意图\n\n这一点是可选的。\n\n当用户将光标沿着路径移动的时候，系统会将焦点沿着移动方向向前偏移一些。因此只有沿着路径的节点会被放大。当用户不沿着路径（光标的移动方向垂直于最近的路径或者光标远离所有路径）则不应用该行为。\n\n### Implement\n\n这一章节详细描述了各部分的实现（放大透镜、拓扑透镜，节点位移以及时空稳定性）\n\n## User Study\n\n第一段讲了两个 user study 的总览，包括目的，结果。\n\n### 实验 1\n\n实验一为了论证有效性\n\n#### Experimental Protocol\n\n1. 参与者和设备\n2. 系统图纸的结构（也就是数据集）\n3. 技术（需要对比的技术，SchemeLens 和传统的鱼眼）\n4. 任务和过程（任务来源于实际工程，找到图纸中存在错误的节点）\n5. 任务难度：用需要探索的路径数量来区分\n6. 设计：主要描述了整个实验的参数：10 个参与者$\\times$2 种技术$\\times$2 个图纸$\\times$3 种难度$\\times$18 条测例\n\n#### Results\n\n1. 完成时间的分析\n2. Subjective preferences：偏好投票\n\n### 实验 2\n\n实验二为了解释 SchemeLens 的自适应能力是如何影响用户表现的。\n\n主要检验两个方面：拓扑自适应和用户意图自适应\n\n将实验分成四组：\n\n1. 没有用户意图自适应的鱼眼\n2. 有用户意图自适应的鱼眼\n3. 没有用户意图自适应的 SchemeLens\n4. 有用户意图自适应的 SchemeLens\n\n#### Experimental Protocol\n\n类似于 Study 1\n\n#### Results\n\n1. 完成时间分析\n2. Memorization：用一个五分 Likert 表来评估用户对图表的记忆\n3. Subjective Preferences\n\n## Discussion\n\n整整一页的篇幅，围绕着以下的内容展开：\n\n第一段：讨论 User Study 1 的结果，传统的鱼眼和本文技术\n\n第二段：讨论拓扑自适应和用户意图自适应的意义\n\n第三段：讨论了对提高记忆的帮助\n\n第四段：可读性的讨论\n\n第五段：空间、时间稳定性，也即结构不要发生太大变化\n\n第六段：空白空间的意义\n\n第七段：scalability\n\n第八段：拓扑规则的影响，也就是之前提到的美学规则。\n\n## Conclusion\n","tags":["Visualization","Graph Visualization","Large Graph","Fisheye"]},{"title":"CS229：07-广义线性模型","url":"/blog/2018/06/09/2018-06-09 07-广义线性模型/","content":"\n广义线性模型，英文名为**Generalized Linear Model**，简称 GLM。\n\n之前，涉及到两种的两种模型：\n\n1. 线性拟合模型，假设了$P(y|x;\\theta)$是高斯分布\n2. 二分类问题，假设了$P(y|x;\\theta)$满足伯努利分布\n\n但以上两者知识一种更广泛的，被称为『指数分布族』（The Exponential Family）的特例。\n\n## 指数分布族\n\n$$\nP(y;\\eta)=b(y)exp(\\eta^TT(y)-a(\\eta))\n$$\n\n可以被表示为以上形式的分布，都是指数分布族的某个特定分布，给定$a, b, T$，就可以定义一个概率分布的集合，以$\\eta$为参数，就可以得到不同的概率分布。\n\n在广义线性模型中，会假设$\\eta=\\theta^Tx$，也就是$\\eta$和特征$x$线性相关。\n\n## 伯努利分布\n\n首先，我们给出$y=1$的概率：\n\n$$\nP(y=1;\\phi)=\\phi\n$$\n\n于是：\n\n$$\n\\begin{align}\nP(y;\\phi)\n\t&= \\phi^y(1-\\phi)^T\\\\\\\n\t&= exp(log(\\phi^T(1-\\phi^T)))\\\\\\\n\t&= exp(ylog(\\phi)+(1-y)log(1-\\phi))\\\\\\\n\t&= exp(log\\frac{\\phi}{1-\\phi} \\cdot y + log(1-\\phi))\n\\end{align}\n$$\n\n比较我们上面的概率形式和指数分布族的标准形式，可以得到：\n\n$$\n\\begin{cases}\n\\eta &= log\\frac{\\phi}{1-\\phi}, \\text{于是} \\phi=\\frac{1}{1+e^{-\\eta}}\\\\\\\na(\\eta) &= -log(1-\\phi)=log(1+e^\\eta)\\\\\\\nT(y) &= y\\\\\\\nb(y) &= 1\n\\end{cases}\n$$\n\n这里的$\\phi$一般会被称为正则响应函数（_canonic response function_）：\n\n$$\ng(\\eta) = E[y|\\eta]=\\frac{1}{1+e^{-\\eta}}\n$$\n\n相对的，正则关联函数（_canonic link function_）则是$g^{-1}$。\n\n## 高斯分布\n\n$$\nN(\\mu,\\sigma^2)=\\frac{1}{\\sqrt{2\\pi}}exp(-\\frac{1}{2}(y-\\mu)^2)\n$$\n\n这里，出于简洁考虑，假设$\\sigma=1$，经过一系列化简后，可以表示成：\n\n$$\n\\frac{1}{\\sqrt{2\\pi}} \\cdot exp(-\\frac{1}{2}y^2) \\cdot exp(\\mu y-\\frac{1}{2}\\mu^2)\n$$\n\n那么，\n\n$$\n\\begin{cases}\n\\eta &= \\mu\\\\\\\na(\\eta) &= \\frac{1}{2}\\mu^2=\\frac{1}{2}\\eta^2\\\\\\\nT(y) &= y\\\\\\\nb(y) &= \\frac{1}{\\sqrt{2\\pi}} \\cdot exp(-\\frac{1}{2}y^2)\n\\end{cases}\n$$\n\n## 多项式分布\n\n#### 建模\n\n在二项分布中，$y\\in \\lbrace 1, 2 \\rbrace$\n\n而多项式分布，$y \\in \\lbrace 1,\\cdots, k \\rbrace$\n\n一般会被用来进行邮件分类或者进行病情分类等等\n\n我们假设\n\n$$\nP(y=i)=\\phi_i\n$$\n\n也即，邮件属于$i$类的概率是$\\phi_i$，是关于特征$x$的一个函数。\n\n那么，可以用$k$个参数来建模多项式分布\n\n$$\nP(y)=\\prod_{i=1}^k\\phi_i^{1\\lbrace y=i \\rbrace}\n$$\n\n其中，$1 \\lbrace \\cdots \\rbrace$的含义为，检验$\\cdots$是否为真命题，若为真命题，则取 1，否则取 0。\n\n因为所有概率和为 1，所以最后一个参数\n\n$$\n\\begin{align}\n\\phi_k &= 1-\\sum_{j=1}^{k-1}\\phi_j \\\\\\\n1 \\lbrace y=k \\rbrace &=1-\\sum_{j=1}^{k-1}1 \\lbrace y=j \\rbrace\n\\end{align}\n$$\n\n经过化简，也可以表示成：\n\n$$\nP(y)=exp[\\sum_{i=1}^{k-1}(log(\\frac{\\phi_i}{\\phi_k}) \\cdot 1\\lbrace y=i \\rbrace )] + log(\\phi_k)\n$$\n\n故而\n\n$$\n\\eta = \\begin{bmatrix}\nlog(\\frac{\\phi_1}{\\phi_k}) \\\\\\\n\\vdots \\\\\\\nlog(\\frac{\\phi_{k-1}}{\\phi_k})\n\\end{bmatrix} \\in \\Bbb R^{k-1}\n$$\n\n$$\na(\\eta) = -log(\\phi_k)\n$$\n\n$$\nT(y)= \\begin{bmatrix}\n1 \\lbrace y=1 \\rbrace \\\\\\\n\\vdots \\\\\\\n1 \\lbrace y=k-1 \\rbrace\n\\end{bmatrix} \\in (0, 1)^{k-1}\n$$\n\n$$\nb(y) = 1\n$$\n\n根据$\\eta$可得：\n\n$$\n\\phi_i = e^{\\eta_i} \\cdot \\phi_k\n$$\n\n又因为：\n\n$$\n\\sum_{i=1}^{k}\\phi_i=\\sum_{i=1}^k\\phi_ke^{\\eta_i}=1\n$$\n\n故而：\n\n$$\n\\phi_k = \\frac{1}{\\sum_{i=1}^ke^{\\eta_i}}=\\frac{1}{e^{\\eta_k}+\\sum_{i=1}^{k-1}e^{\\eta_i}} = \\frac{1}{1+\\sum_{i=1}^{k-1}e^{\\eta_i}}\n$$\n\n所以：\n\n$$\n\\begin{align}\n\\phi_i &= e^{\\eta_i} \\cdot \\phi_k \\\\\\\n&= \\frac{e^{\\eta_i}}{1 + \\sum_{j=1}^{k-1}e^{\\eta_j}} \\\\\\\n&= \\frac{e^{\\theta_i^Tx_i}}{1 + \\sum_{j=1}^{k-1}e^{\\theta_j^Tx_j}}\n\\end{align}\n$$\n\n上述函数，被称为『softmax』函数，这个函数的作用经常用于进行归一化。\n\n经过上述步骤，假设函数可以被写成如下形式：\n\n$$\nh_\\theta(x)=\n\\left[\n\\begin{array}{c}\n1\\lbrace y=1 \\rbrace  \\\\\\\n\\vdots \\\\\\\n1\\lbrace y=k-1 \\rbrace\n\\end{array} | x;\\theta\n\\right]=\n\\begin{bmatrix}\n\\phi_1\\\\\\\n\\vdots\\\\\\\n\\phi_{k-1}\n\\end{bmatrix}\n$$\n\n#### 回归\n\n在经过上述推导，当我们有一堆训练集（$(x^{(1)}, y^{(1)}), \\cdots, (x^{(m)}, y^{(m)})$）用于训练的时候，则可以进行极大似然估计：\n\n$$\nL(\\theta) = \\prod_{i=1}^mP(y^{(i)} | x^{(i)};\\theta) = \\prod_{i=1}^m\\prod_{j=1}^k\\phi_j^{1\\lbrace y^{(i)}=j \\rbrace }\n$$\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：06-牛顿法","url":"/blog/2018/06/07/2018-06-07 06-牛顿法/","content":"\n> **牛顿法**（英语：Newton's method）又称为**牛顿-拉弗森方法**（英语：Newton-Raphson method），它是一种在实数域和复数域上近似求解方程的方法。方法使用函数$\\displaystyle f(x)$的[泰勒级数](https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0)的前面几项来寻找方程$\\displaystyle f(y)=0$的根。\n>\n> ——维基百科\n\n牛顿法可以通过迭代逼近的方法，求得函数$f(x)=0$的解。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-7/69557176.jpg)\n\n1. 先初始化某个点$x_0$，对该点求导数$f'(x_0)$，可以得到一条切线；\n2. 切线会和横轴再有一个交点$x_1$，然后再重复第一步；\n3. 直到$f(x_n)=0$\n\n通过一系列推导，我们可以得知：\n\n$$\nx_{i+1}-x_{i}=\\frac{f(x^{(i)})}{f'(x^{(i)})}\n$$\n\n于是，我们可以将牛顿法用于极大似然估计，也就是求$l(\\theta)$的最大值，可以看做是求$l'(\\theta)=0$的解。\n\n那么，每次迭代就可以写成：\n\n$$\n\\theta^{(t+1)}=\\theta^{(t)}-\\frac{l'(\\theta^{(t)})}{l''(\\theta^{(t)}}\n$$\n\n更一般地，可以写成：\n\n$$\n\\theta^{(t+1)}=\\theta^{(t)}-H^{-1}\\nabla_\\theta l\n$$\n\n其中，$H$是$l(\\theta)$的 Hessian 矩阵：\n\n$$\nH_{ij}=\\frac{\\partial^2l}{\\partial\\theta_i\\partial\\theta_j}\n$$\n\n但这个方法有个缺点，每次迭代的时候，都需要重新计算$H^{-1}$，虽然牛顿法对函数$f$有很多要求和限制，但对于 logistic 函数而言，足够有效。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：05-二分类问题","url":"/blog/2018/06/05/2018-06-05 05-二分类问题/","content":"\n在二分类问题中，输出$y\\in \\{0, 1\\}$。同样的，我们也可以用线性拟合来尝试解决二分类问题（如下图左），但数据点比较异常时，容易出现下图右这样的情况：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-5/41455819.jpg)\n\n一般，在二分类问题中，我们会选用『*logistic*函数』来拟合（因为形状像*S*，又称为『*sigmoid*函数』）：\n\n$$\nh_\\theta (x)=g(\\theta^Tx)=\\frac{1}{1+e^{-\\theta^Tx}}\n$$\n\n*logistic*函数$g(z)=1/(1+e^{-z})​$的形状如下：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-5/53166407.jpg)\n可以定义\n\n$$\n\\begin{align}\nP(y=1|x;\\theta)& =h_\\theta (x) \\\\\\\nP(y=0|x;\\theta)& =1-h_\\theta(x)\n\\end{align}\n$$\n\n于是：\n\n$$\nP(y|x;\\theta)=h_\\theta(x)^y(1-h_\\theta(x))^{(1-y)}\n$$\n\n进行极大似然估计：\n\n$$\nL(\\theta)=P(y|x;\\theta)=\\prod_{i=1}^mP(y^{(i)}|x^{(i)};\\theta)=\\prod_{i=1}^mh_\\theta(x^{(i)})^{y^{(i)}}(1-h_\\theta(x^{(i)}))^{(1-y^{(i)})}\n$$\n\n为了计算方便，定义\n\n$$\n\\begin{align}\nl(\\theta)&=log(L(\\theta))\\\\\\\n&=\\sum_{i=1}^mlog(P(y^{(i)}|x^{(i)};\\theta))\\\\\\\n&=\\sum_{i=1}^m(y^{(i)}\\cdot log(h_\\theta(x^{(i)}))+(1-y^{(i)})\\cdot log(1-h_\\theta(x^{(i)})))\n\\end{align}\n$$\n\n利用梯度上升进行求解：\n\n$$\n\\theta := \\theta + \\alpha \\nabla_\\theta l(\\theta)\n$$\n\n其中\n\n$$\n\\nabla_{\\theta_j} l(\\theta)=\\frac{\\partial}{\\partial\\theta_j}l(\\theta)=\\sum_{i=1}^m(y^{(i)}-h_\\theta(x^{(i)}))\\cdot x_j^{(i)}\\\\\\\n\\theta_j:=\\theta_j+\\alpha \\cdot \\sum_{i=1}^m(y^{(i)}-h_\\theta(x^{(i)}))\\cdot x_j^{(i)}\n$$\n\n最终的梯度上升结果几乎与线性拟合中的梯度下降结果一样。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：04-线性模型的概率解释","url":"/blog/2018/06/05/2018-06-05 04-线性模型的概率解释/","content":"\n关于：为何在进行线性回归时，选择用最小二乘拟合（距离的平方和）来进行，而不是选用其他的模型（比如三次方或四次方）？\n\n我们更新一下假设函数，使之变为：\n\n$$\ny^{(i)} = \\theta^Tx^{(i)} + \\varepsilon^{(i)}\n$$\n\n其中，$\\varepsilon^{(i)}$是误差项，表示未捕获的特征（unmodeled effects），比如房子存在壁炉也影响价格，或者其他的一些随机噪音（random noise）。\n\n一般，会假设误差项$\\varepsilon^{(i)} \\sim N(0, \\sigma^2)$（满足正态分布），也就是：\n\n$$\nP(\\varepsilon^{(i)})=\\frac{1}{\\sqrt{2\\pi}\\sigma}exp(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})\n$$\n\n关于为什么假设正态分布的解释：\n\n1. 便于数学运算；\n2. 很多独立分布的变量之间相互叠加后会趋向于正态分布（中心极限定理），在大多数情况下能成立\n\n所以，$y^{(i)}$的后验分布：\n\n$$\nP(y^{(i)}|x^{(i)};\\theta)=\\frac{1}{\\sqrt{2\\pi}\\sigma}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2}) \\sim N(\\theta^Tx^{(i)}, \\sigma^2)\n$$\n\n之后，进行极大似然估计（maximum likelihood estimation）：$max L(\\theta)$，即选择合适的$\\theta$，使得$y^{(i)}$对于$x^{(i)}$出现的概率最高（有一些存在即合理的感觉），其中$L(\\theta)$的定义如下：\n\n$$\nL(\\theta)=P(y|x;\\theta)=\\prod_{i=1}^mP(y^{(i)}|x^{(i)};\\theta)=\\prod_{i=1}^m\\frac{1}{\\sqrt{2\\pi}\\sigma}exp(-\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2})\n$$\n\n那么，为了计算方便，我们定义：\n\n$$\nl(\\theta) = log(L(\\theta))=\\sum_{i=1}^mlog(P(y^{(i)}|x^{(i)};\\theta))=m\\cdot log(\\frac{1}{\\sqrt{2\\pi}\\sigma})-\\sum_{i=1}^m\\frac{(y^{(i)}-\\theta^Tx^{(i)})^2}{2\\sigma^2}\n$$\n\n于是，极大似然估计变为最小化：\n\n$$\n\\sum_{i=1}^m\\frac{(y{(i)}-\\theta^Tx{(i)})2}{2\\sigma2}\n$$\n\n也即之前线性回归所需进行最小二乘拟合的$J(\\theta)$。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：03-过拟合&局部加权回归","url":"/blog/2018/06/04/2018-06-04 03-过拟合&局部加权回归/","content":"\n## 欠拟合和过拟合\n\n对于之前房价的例子，假设只有一个特征 size。\n\n假如，我们只用简单的线性拟合（$\\theta_0+\\theta_1x_1$，$x_1$表示 size），最终拟合结果会变一条直线，就可能产生下图最左边的结果，我们称之为『欠拟合』。\n\n当我们尝试用二次曲线来拟合（$\\theta_0+\\theta_1x_1+\\theta_2x_1^2$，可以假设$x_2=x_1^2$，再进行线性拟合），就可能产生中间的结果。\n\n但如果再继续增加曲线的复杂度，对于下图这种五个样本的例子，假如我们用一个五次曲线来拟合它（$\\theta_0+\\theta_1x1+\\theta_2x1^2+\\cdots+\\theta_5x_1^5$）就会精确拟合所有数据，产生右图的结果，我们称之为『过拟合』。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-4/71073333.jpg)\n\n## 局部加权回归（Locally Weighted Regression）\n\n局部加权回归，是一种特定的非参数学习方法。\n\n什么叫非参数学习方法，首先，简单了解一下『参数化学习方法』(parametric learning algorithm)，是一种参数固定的学习方法，如上所示。而『非参数化学习方法』（non-parametric learning algorithm）则不固定参数，参数的个数会随着训练集数量而增长。\n\n我们回顾一下，线性拟合中，我们的目标是找到合适的参数$\\theta$，使得最小化$\\sum_i(Y^{(i)} - \\theta^TX^{(i)})^2$。\n\n而『局部线性拟合』，则是在某个局部区域 A 进行线性拟合，目标是最小化$\\sum_iw^{(i)}(Y^{(i)} - \\theta^TX^{(i)})^2$，其中权重$$w^{(i)} = exp(-\\frac{(x^{(i))}-x)^2}{2})$$，当然，权重公式是可替换的。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-4/30285296.jpg)\n\n我们观察一下$w^{(i)}$的形状，当数据$x^{(i)}$靠近$x$时，其权重就会较大，那么对目标函数的贡献就会大一些；而数据远离$x$的时候，权重就会较小，贡献就会较小。这样做，目标函数就会更关注$x$附近的数据点，从而达到局部的目的。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-4/78196882.jpg)\n\n当然，可以调整权重函数，常用的另一个权重函数：$$w^{(i)} = exp(-\\frac{(x^{(i))}-x)^2}{2 \\tau^2 })$$（波长函数），$\\tau$越大，波形越平缓，局部性越差。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-4/54967961.jpg)\n\n但问题在于，当训练数据较大时，该方法的代价会很高。每要预测一个值，就需要重新进行一次局部线性拟合。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：02-线性回归","url":"/blog/2018/06/03/2018-06-03 02-线性回归/","content":"\n首先引入一些后面会用到的定理：\n\n**定义 1**：定义函数$f: \\Bbb R^{m \\times n} \\mapsto \\Bbb R$，$A \\in \\Bbb R^{m \\times n}$，定义\n\n$$\n\\nabla_Af(A)=\n    \\begin{bmatrix}\n    \\frac{\\partial f}{\\partial A_{11}} & \\cdots & \\frac{\\partial f}{\\partial A_{1n}}\\\\\\\n    \\vdots & \\ddots & \\vdots \\\\\\\n    \\frac{\\partial f}{\\partial A_{m1}} & \\cdots & \\frac{\\partial f}{\\partial A_{mn}}\n    \\end{bmatrix}\n$$\n\n**定义 2**：矩阵的迹（Trace）：如果$A \\in R^{n\\times n}$方阵，那么$A$的迹，是$A$对角线元素之和\n\n$$\ntr A = \\sum_{i=1}^nA_{ii}\n$$\n\n**定理 1**：$tr AB = tr BA$\n\n**定理 2**：$tr ABC = tr CAB = tr BCA$\n\n**定理 3**：$f(A)=tr AB \\Rightarrow \\nabla_Af(A)=B^T$\n\n**定理 4**：$trA = tr A^T$\n\n**定理 5**：$a \\in R \\Rightarrow tr a=a$\n\n**定理 6**：$\\nabla_AtrABA^TC=CAB+C^TAB^T$\n\n## 线性回归\n\n#### 一些符号的改写\n\n[上一篇博客](http://jackieanxis.coding.me/2018/06/03/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/)提到，梯度下降的每一步，对某个参数$\\theta_i$，执行：\n\n$$\n\\displaystyle \\theta_i:=\\theta_i - \\alpha\\frac{\\partial}{\\partial \\theta_i}J(\\theta)\n$$\n\n那么，$h_\\theta(x)$的所有参数$\\theta$可以表示成一列向量：\n\n$$\n\\theta = \\left[\n\t\\begin{array}{c}\n\t\\theta_0\\\\\\\n\t\\theta_1\\\\\\\n\t\\vdots\\\\\\\n\t\\theta_n\n\t\\end{array}\n\\right] \\in R^{n+1}\n$$\n\n我们可以定义：\n\n$$\n\\nabla_\\theta J = \\left[\n\t\\begin{array}{c}\n\t\\frac{\\partial}{\\partial \\theta_0}J\\\\\\\n\t\\frac{\\partial}{\\partial \\theta_1}J\\\\\\\n\t\\vdots\\\\\\\n\t\\frac{\\partial}{\\partial \\theta_n}J\n\t\\end{array}\n\\right] \\in R^{n+1}\n$$\n\n梯度下降过程可以表示成：\n\n$$\n\\theta:=\\theta - \\alpha\\nabla_\\theta J\n$$\n\n其中，$\\theta$和$\\nabla_\\theta J$都说是 n+1 维向量。\n\n对于训练集中所有的输入${x^{(1)}},x^{(2)},…,x^{(m)}$，其中\n\n$$\nx^{(i)} = \\left[\n\t\\begin{array}{c}\n\t1\\\\\\\n\tx_1^{(i)}\\\\\\\n\t\\vdots\\\\\\\n\tx_n^{(i)}\\\\\\\n\t\\end{array}\n\\right] \\in R^{n+1}\n$$\n\n$h(x)=h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+...+\\theta_nx_n$，可以表示成向量：\n\n$$\n\\left[\n    \\begin{array}{c}\n    h_\\theta(x^{(1)})\\\\\\\n    h_\\theta(x^{(2)})\\\\\\\n    \\vdots\\\\\\\n    h_\\theta(x^{(m)})\\\\\\\n    \\end{array}\n\\right] = \\left[\n    \\begin{array}{c}\n    (x^{(1)})^T\\theta\\\\\\\n    (x^{(2)})^T\\theta\\\\\\\n    \\vdots\\\\\\\n    (x^{(m)})^T\\theta\\\\\\\n    \\end{array}\n\\right] = \\left[\n\t\\begin{array}{c}\n\t(x^{(1)})^T\\\\\\\n\t(x^{(2)})^T\\\\\\\n\t\\vdots\\\\\\\n\t(x^{(m)})^T\n\t\\end{array}\n\\right] \\cdot \\theta = X \\cdot \\theta\n$$\n\n而\n\n$$\nY = \\left[\n\t\\begin{array}{c}\n\ty^{(1)}\\\\\\\n\ty^{(2)}\\\\\\\n\t\\vdots\\\\\\\n\ty^{(m)}\n\t\\end{array}\n\\right]\n$$\n\n于是，\n\n$$\nJ(\\theta) = \\frac{1}{2}\\sum_{i=1}^{m}(h(x^{(i)} - y^{(i)})^2)=\\frac{1}{2}(X \\cdot \\theta - Y)^T(X \\cdot \\theta - Y)\n$$\n\n#### 推导过程\n\n关于梯度下降法，可以直接简化为求梯度为 0 的位置，即求$\\nabla_\\theta J(\\theta) = \\vec{0}$\n\n首先，简化：\n\n$$\n\\begin{align}\n\\nabla_\\theta J(\\theta) & = \\nabla_\\theta\\frac{1}{2}(X \\cdot \\theta - Y)^T(X \\cdot \\theta - Y)\\\\\\\n& =\\frac{1}{2}\\nabla_\\theta tr(\\theta^TX^TX\\theta - \\theta^TX^TY - Y^TX\\theta + Y^TY)\\\\\\\n& =\\frac{1}{2}[\\nabla_\\theta tr(\\theta\\theta^TX^TX) - \\nabla_\\theta tr(Y^TX\\theta) - \\nabla tr(Y^TX\\theta)]\n\\end{align}\n$$\n\n其中，第一项：\n\n$$\n\\begin{align}\n\\nabla_\\theta tr(\\theta\\theta^TX^TX) & = \\nabla_\\theta tr(\\theta I \\theta^TX^TX) &\\text{定理6, set: $\\theta =^{set} A, I = B, X^TX=C$}\\\\\\\n& = X^TX\\theta I + X^TX\\theta I & \\text{$CAB+C^TAB^T$}\\\\\\\n& = X^TX\\theta + X^TX\\theta\n\\end{align}\n$$\n\n第二项和第三项：\n\n$$\n\\nabla_\\theta tr(Y^TX\\theta) = X^TY\\\\\\\n(定理3，set:Y^TX = B, \\theta = A)\n$$\n\n所以：\n\n$$\n\\nabla_\\theta J(\\theta) = X^TX\\theta - X^TY = 0\\\\\\\n\\Rightarrow X^TX\\theta = X^TY\\\\\\\n$$\n\n最后解得：\n\n$$\n\\theta = (X^TX)^{(-1)}X^TY\n$$\n\n当然，以上的解是有限制的，只有当$X^TX$满秩时，才能够求逆。\n\n如果非满秩，说明方程数量不够，也就是当需要 n 个参数时，却不够 n 个输入样本。\n","tags":["Course Notes","Machine Learning"]},{"title":"CS229：01-监督学习&梯度下降法","url":"/blog/2018/06/03/2018-06-03 01-监督学习&梯度下降法/","content":"\n## 监督学习\n\n### 符号定义：\n\n| 符号                 | 意义                     |\n| -------------------- | ------------------------ |\n| $m$                  | 训练集包含的数据个数     |\n| $x$                  | 输入变量/特征（\u0004feature） |\n| $y$                  | 输出变量/目标（target）  |\n| $(x, y)$             | 一个训连样本             |\n| $(x^{(i)}, y^{(i)})$ | 第 i 个训练样本          |\n\n### 监督学习的主要流程：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-3/4328727.jpg)\n\n### 线性回归\n\n以预测房价为例，我们的目标是导出一个函数（即假设），根据房子的特征（比如大小、卧室数量等等）来预测房价，那么：\n\n-   输入（特征）：$x_1, x_2, …$（比如大小、卧室数量等等）\n-   输出（目标）：$y$（房价）\n-   假设：$h(x)=h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+...+\\theta_nx_n$，用于预测房价，其中$\\theta_i$是参数，$n$是特征数量\n\n    为了方便，可以将假设写成：$h(x)=\\sum_{i=0}^n\\theta_ix_i=\\theta^Tx​$\n\n此时，学习函数（Learning Algorithm）的目标就是找到合适的参数$\\theta$，使之能够导出『合理』的假设$h(x)$，这里我们将『合理』理解为：$h_\\theta(x)$（假设）和$y$（目标）之间的差距最小，也即：\n\n$$\n\\displaystyle \\min_{\\theta}\\frac{1}{2}\\sum_{i=1}^m(h_\\theta(x)^{(i)}-y_{(i)})^2\n$$\n\n这里的$\\frac{1}{2}$是为了简化之后的计算。\n\n我们定义$$\\displaystyle J(\\theta)=\\frac{1}{2}\\sum_{i=1}^m(h_\\theta(x)^{(i)}-y_{(i)})^2$$，那么我们的目标就是去选取合适的$\\theta$，以最小化$J(\\theta)$。\n\n## 梯度下降法\n\n### 搜索算法（梯度下降）\n\n目的：不断改变$\\theta$，从而来减少$J(\\theta)$。\n\n原理：每次都往下降最快的地方走，从而找到一个局部最优解。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-3/2339619.jpg)\n\n一般会初始化$\\vec{\\theta}=\\vec{0}$，然后每次都沿着梯度方向走，以保证每次都往下降最快的地方走：\n\n$$\n\\displaystyle \\theta_i:=\\theta_i - \\alpha\\frac{\\partial}{\\partial \\theta_i}J(\\theta)\n$$\n\n其中，$:=$表示赋值操作，$\\alpha$为步长。\n\n对于某个训练样本$(x, y)​$\n\n$$\n\\displaystyle \\frac{\\partial}{\\partial \\theta_i}J(\\theta) = \\frac{\\partial}{\\partial \\theta_i}(\\frac{1}{2}(h_\\theta(x)-y)^2)\n$$\n\n$$\n\\displaystyle = 2 \\times \\frac{1}{2}(h_\\theta(x)-y)\\frac{\\partial}{\\partial \\theta_i}(h_\\theta(x)-y)\n$$\n\n$$\n\\displaystyle = (h_\\theta(x)-y)\\frac{\\partial}{\\partial \\theta_i}(\\theta_0x_0+…+\\theta_nx_n-y)\n$$\n\n$$\n\\displaystyle =(h_\\theta(x)-y) \\times x_i\n$$\n\n那么，\n\n$$\n\\theta_i:=\\theta_i - \\alpha (h_\\theta (x) - y) \\times x_i\n$$\n\n### 批量梯度下降法（Batch Gradient Descent）\n\n批量梯度下降法，使用的是所有训练样本的平均梯度：\n\n$$\n\\displaystyle \\theta_i:=\\theta_i - \\alpha \\frac{1}{m} \\sum_{j=1}^m(h_\\theta(x^{(j)})-y^{(j)}) \\times x_i^{(j)}\n$$\n\n但每次下降都需要遍历所有样本，效率较低，具体过程可能如下：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-3/49403960.jpg)\n\n### 随机梯度下降法（Stochastic Gradient Descent）\n\n又称为『增量梯度下降法』\n\n对每个样本$(x_{(j)}, y_{(j)})$进行：\n\n$$\n\\displaystyle \\theta_i:=\\theta_i - \\alpha (h_\\theta(x^{(j)})-y^{(j)}) \\times x_i^{(j)}\n$$\n\n直到收敛\n\n这时，每次梯度下降只遍历一个样本，具体过程可能如下：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-6-3/85884341.jpg)\n","tags":["Course Notes","Machine Learning"]},{"title":"ICCV2017：第一人称视角手势估计","url":"/blog/2018/05/06/2018-05-06 ICCV2017：第一人称视角手势估计/","content":"\n### 一、背景介绍\n\n由于手在日常的人类活动中，起着至关重要的作用，估计完整的手的三维姿态越来越重要。在很多场景下，比如运动控制，人机交互，虚拟/增强现实，对手姿态的估计需要在一些混乱、有干扰的环境下进行。由于最近卷积神经网络的发展，目前静态、第三人称视角、在无干扰、无遮挡环境下对手部的追踪和手势估计已经很有效。但很明显，这种场景设定在一些实际场景中并不常见。\n\n在现实世界场景下，经常需要从第一视角来进行手势追踪估计，而且背景往往杂乱无章，手经常在跟物体进行交互时存在遮挡，而需要交互的物体形状不定， 这就为手势估计和重建构成了很多具有挑战性的任务。总结而言，第一人称视角下，进行手势跟踪和估计具有如下一些挑战：\n\n-   存在遮挡\n-   背景杂乱无章(噪声)\n-   第一人称视角带来的视野限制（因为相机往往放置在肩部，如图 1）\n-   手和物体的交互\n-   该场景下，标注数据的缺失\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/94908344.jpg)\n\n> 图 1，第一人称视角的手势跟踪\n\n本文总结了近几年在第一人称手势估计方面的顶级工作。这些方法基本上都是基于卷积神经网络进行，利用已有的，或者自己采集的，真实的或者合成的数 据进行训练。一般针对与物体交互的场景进行，需要在有遮挡、杂乱无章的环境下进行。\n\n### 二、手部姿势估计的一般过程\n\n一般而言，第一人称视角下，手部姿势估计过程可以分成两步，手部定位和姿势估计。近几年，这两者基本上都可以通过卷积神经网络实现。\n\n**手部定位**：通过训练好的，多层卷积神经网络，我们可以得到一个关于手部中心位置的置信度分布图，从而可以绘制成热力图的形式，如图 2。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/61027681.jpg)\n\n> 图 2，卷积神经网络输出的热力图\n\n**姿势估计**：对手部姿势估计，一般都会采用 21 手关节参数[^1]来估计整个手的姿态。通过手关节的角度，相对位置等信息，可以对整个手姿态进行一个重建，如图 2 b。\n\n### 三、带标注的训练数据的获取\n\n一般而言，根据数据获取方式，可以分成三大类，（i）完全合成的数据，（ii）半合成数据以及（iii）真实数据。这些数据大部分是基于 RGB-D 相机获取的，也有搭配手部传感器进行采集。\n\n#### 1 完全合成数据\n\n因为手动模拟手-物体的交互是一项耗时的任务，故而采用自动的，完全用计算机进行模拟的方法来合成数据。\n\nChoi 等人的工作[^2]中，提出了一种用模型进行拟合的方式，来优化模拟手对于模拟物体的抓握姿势的方法。该工作使用了粒子群优化方法（particle swarm optimization），对虚拟的三维手模型和被该手握住的模型的距离误差进行最小化。之后，作者通过碰撞检测技术来判断这个虚拟手部的抓取是否有效，从而排除无效的抓取。之后作者从模型中导出了相应的手的关节角度参数。最后作者将虚拟手部的深度图插入到杂乱无章的背景中，以模仿现实世界的真是噪音的存在。\n\n#### 2 半合成数据\n\n为了在真实性和数据的多样性、易获取性上做出权衡，Mueller 等人的工作[^3]则采用了半合成数据的方法，作者称为混合现实（merged reality）。如图 3a 所示，作者用一个无标记跟踪摄像头，用以从第三视角，跟踪一个无遮挡的真实手部，产生跟踪数据（这种方法已经很成熟），从而用以操作虚拟 3D 模型手来抓取虚拟的物体。通过这个方法可以增加数据的真实性。\n\n这种方式的优点在于，既保留了一定的手部运动真实性，又能模拟出大量不同的虚拟手部（比如肤色的不同，手指长短，体毛浓密等等），与各种不同类型物体的交互以及各种不同的场景。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/74120103.jpg)\n\n> 图 3，a：混合现实（merged reality）方式获取手部数据，b：使用传感器和 RGB-D 相机 采集第一人称数据\n\n### 3 真实数据\n\n在 Garcia-Hernando[^4]的工作中，采集了超过 100,000 个有 3D 手姿势注释的 RGB-D 帧，使用装在指尖上的六个磁性传感器进行数据采集，如图 3b。其中包括 45 个类别，在 3 个场景中，与 25 个不同的物体进行交互。作者静心设计了不同的手部动作，以保证能覆盖较多的姿势，交互时间和运动状态。\n\n### 四、手部定位方法（Localization）\n\n因为卷积神经网络（CNN）方法的成熟，现如今，手部定位基本上都采用卷积神经网络来进行，Choi 等人的工作，也证明了卷积神经网络相对于随机森林方法的优势[^1]。在经过训练好的深度神经网络的估计之后，一般会输出一张关于手部中心位置置信度的热力图。\n\n比如，在 Choi 等人的工作中[^2]，训练了一个带有六个卷积层，以及一个非线性判定层的卷积神经网络，用以判定输入图中的手心位置以及物体位置，如图 4。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/69002183.jpg)\n\n> 图 4：由五层卷积层与一层非线性层构成的位置估计卷积网络\n\nMueller 等人的工作[^2]，在深度神经网络训练结果上，加入了后处理（post processing）过程，目的是增加数据的稳定性，因为手部中心位置不会随时间的变化而发生较大的变化）。作者保留了同一组数据，多帧图像的历史定位记录，并对每一帧图像的手部位置的定位结果做一个是否可信的判定。如果帧 t 的热力图的最大置信度小于 0.1，且出现的位置和上一次最大值位置距离大于 30，则认为其不可信，然后需要对这个最大值点进行更新：\n\n$$\\phi_t=\\phi_{t-1}+\\delta^k\\frac{\\phi_{c-1} - \\phi_{c-2}}{||\\phi_{c-1} - \\phi_{c-2}||}$$\n\n其中$\\phi_t=\\phi(H_R^t)$是帧$t$处的更新之后的最大值位置，是$\\phi_{c-1}$上一个可置信（confident）的最大值位置，$k$是自上个可置信的最大值起经过的帧数，$\\delta$是逐渐对不可信的最大值进行减权（downweight）的衰减因子。\n\n经过更新，最大值位置不会随着时间变化而发生较剧烈的变化。\n\n### 五、手势估计方法（Hand Pose Estimation）\n\n目前有的手势估计方法基本上可以分成两类，基于分类的方法和基于回归的方法。\n\n#### 分类方法\n\nRogez 等人在 2014 年发表的文章[^5]中，使用了分层量化的分类器。首先，需要构建一棵姿态类别树，每个节点都代表了一种姿态，层次越高的姿态，普遍性越高。而越接近叶节点，代表其手势的细节越多，更特殊，如图 5 所示。接下去，可以使用宽度优先搜索（BFS）来对输入的手势进行评估，对树的每一层，都可以剪掉那些评级为 0 的节点（也就是没有吻合性的姿态）。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/60258705.jpg)\n\n> 图 5，手势层次量化分类器\n\nChoi 等人的工作[^2]，用一个卷积神经网络，训练了一个分类器，已分类手部姿态，该工作的场景中，用户会抓取一个未知的物体。在训练分类器之前，作者认为，在追踪用户的手部姿态的时候，会因为传感器噪声等，导致输出的 RGB-D 图像存在一定缺失。故而在训练该分类器的同时，训练了输入数据再生成网络，通过自动编码器的方法实现输入数据复原。自动编码器由编码器（将高维数据映射到较低的维特征空间来降低输入的维数）和解码器（通过将学到的表示，映射回高维空间来恢复原始输入）构成，两者都是卷积神经网络，作者为两者都加入了四层隐含层，如图 6a。之后，作者认为手的姿态和物体形状高度相关，所以在训练手部姿态分类器的同时，也加入了另一个神经网络作为物体形状的分类器，并共享这两者的决策层，来协作学习手和物体的成对的卷积特征，以增加分类准确性，如图 6a。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/74747573.jpg)\n\n> 图 6，a：RGB-D 图 数据再生成网络，b：手势分类器神经网络的架构\n\n#### 回归方法\n\n在 Mueller[^3]等人的工作中，则是使用了卷积神经网络，对手部姿态向量进行了回归。作者采用了一个 26 自由度的手骨骼模型，其包括 6 个用于全局平移和旋转的角度，以及 20 个关节角度，存储在向量$\\Theta$中，然后用一个卷积神经网络对这个向量进行了回归。Mueller 等人在这个基础上，还加入了一些约束（比如关节旋转角度的范围，手关节运动速度等），以保证回归结果的有效性。\n\n$$\\mathcal{E}(\\Theta) = E_{data}(\\Theta,p_G,H)+E_{reg}(\\Theta)$$\n\n其中，$E_{data}$约束了相对位置，$E_{reg}$约束了关节旋转角度和运动速度。\n\n[^1]: Choi, Chiho, et al. \"A collaborative filtering approach to real-time hand pose estimation.\" _Proceedings of the IEEE International Conference on Computer Vision_. 2015.\n[^2]: Choi, Chiho, et al. \"Robust hand pose estimation during the interaction with an unknown object.\" _Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition_. 2017.\n[^3]: Mueller, Franziska, et al. \"Real-time hand tracking under occlusion from an egocentric rgb-d sensor.\" _Proceedings of International Conference on Computer Vision (ICCV)_. Vol. 10. 2017.\n[^4]: Garcia-Hernando, Guillermo, et al. \"First-Person Hand Action Benchmark with RGB-D Videos and 3D Hand Pose Annotations.\" _arXiv preprint arXiv:1704.02463_(2017).\n[^5]: Rogez, Grégory, et al. \"3d hand pose detection in egocentric rgb-d images.\" _Workshop at the European conference on computer vision_. Springer, Cham, 2014.\n","tags":["Deep Learning","Computer Vision"]},{"title":"Affective Color in Visualization","url":"/blog/2018/05/03/2018-05-03 Affective Color in Visualization/","content":"\n-   论文原文：Affective Color in Visualization\n-   作者：Lyn Bartram，Abhisekh Patra，Maureen Stone\n-   发表刊物/会议：[CHI '17](http://chi2017.acm.org/) Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems。\n\n用正确的情感进行沟通，对视觉交流至关重要。文章进行了三项研究，主要研究不同的颜色属性（亮度、饱和度和色调）以及调色板属性（不同的色彩组合和分布）对信息可视化中的情感表达的影响。研究结果展示了在信息可视化中，如何使用不同的颜色和调色板属性来有效表达数据。\n\n## 一、基本介绍\n\n之前有很多工作，研究了关于情感和视觉元素之间的关系。在可视化中，情感的表达也是非常重要的一部分，但还没有任何一个框架性工作来研究可视化中的情感表达原则。这项工作研究了颜色的不同属性，主要是感知上的属性（LCH，亮度，饱和度和色调），以及色彩组合，在可视化中对情感表达的作用。\n\n#### 研究范围\n\n1. **色彩组合**。经常研究的内容是，关于颜色跟情感表达之间的关系，这项工作主要研究的是色彩组合和情感之间的关系。色彩组合在数据可视化是一个关键角色，他们经常用来映射类别属性，以便进行区分和识别。但至今为止，还没有关于在类别型的信息可视化中，色彩组合在有限范围内如何影响不同的情感表达。\n2. **简单信息可视化的分类数据可视化**。对分类数据进行映射的颜色有两个重要的**约束条件**：1. 可用的颜色范围比较少，一般只能是 5-10 种颜色；2. 颜色之间要有强烈的感知差别。这个工作，主要在研究这些有限制的颜色组合和情感之间的对应关系模型。主要集中在研究**五种颜色**的色彩组合（在一般可视化中比较常见）。\n3. **情感可视化**。信息可视化中，数据可视化和情感可视化（affective visualization）的基本区别是在于它们的交流意图。文章中，主要用了[PAD 模型](https://en.wikipedia.org/wiki/PAD_emotional_state_model)的其中两个维度：valence(pleaure)维度和 arousal 维度（翻译过来即：愉悦度和激活度，分别表示情绪的正负以及个体兴奋程度），大部分典型情感都可以放在空间内。\n    - 数据可视化用视觉特征来表达数据，从而使得人能够获得有效的认知。\n    - 情感可视化用视觉特征来唤起人的情绪、感觉或产生印象。\n4. **8 种简单情感**。四种核心情感：平静、激动、积极、消极。并且增加了四种实际情感：严肃、俏皮、信任和不安。这些情感在情感空间中的位置并不是均衡的。比如，可视化应用可能对开心、悲伤等情绪没兴趣，但信任和严肃可能在商业交流中比较重要。俏皮、严肃和不安等情感则和故事讲述相关，这在可视化中是一个新兴领域。\n\n#### 色彩心理学的结论和工作\n\n在这之前，色彩心理学已经验证了色彩、认知、情感和行为之间的相互作用，其中一个重要结论：暖色调比冷色调更引人注目，其他结论还有：\n\n-   色调方面：\n    -   红色被认为是热的，更充满活力、容易引起兴奋和焦虑。\n    -   黄色、橙色、棕色则在情感表达的不同场景中表现不是很一致。棕色和“悲伤”、“陈旧”等有联系。\n    -   蓝色在很多文化中都表示了平和和冷静。\n-   饱和度：高饱和度令人兴奋，低饱和度更平静，灰色则表现为“严肃”和“专业”。\n-   亮度：亮度则和冷静度相关，较淡的颜色被认为更愉悦，不那么兴奋，并且跟暗一些的颜色比，显得不那么显眼。黑色则是负面的并且显眼的。黑褐色则是悲伤的。\n\n在色调的选择有限的时候，关于亮度和饱和度的这两个结论就显得尤为重要，因为修改亮度和饱和度不会违背该种颜色表达的类别的含义。\n\n#### 色彩设计方面的结论和工作\n\n最重要的设计原则：和谐一致。而关于色彩组合的设计，通常表现为这些色彩在色环上的几何分布形状，以及亮度变化的控制。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/13077913.jpg)\n\nIttern 的定性对比研究模型，将暖色调和冷色调进行了形式化，并假设了浅色代表了明亮跟美好，深色则代表了黑暗、悲伤和消极[^1]。\n\nMadden 在 LOGO 设计相关的研究中定义了两种颜色组合设计的策略[^2]：一致性（颜色之间有相似的意义）和互补性（不同颜色含义不同）。他发现，当用蓝色作为 LOGO 的颜色时，往往搭配白色、绿色和黄色（主要是一致性策略），当红色是主要颜色时，则更喜欢用互补策略。\n\nHeer 和 Stone 的工作，建立了颜色命名的概率模型[^3]，表现了颜色跟名称之间是如何进行映射的并可以测量颜色的相似性。这项工作可以用来比较和评估色彩组合的设计，最小化名称之间的重叠、最大化显著性能够帮助记忆和理解。作为该项工作的扩展工作，Lin 等人的工作[^4]将它用到可视化中的语义颜色设计中，Setlur 和 Stone 的工作[^5]，旨在为每个类找到合适的关联颜色。以上这些算法都探索了颜色和对象之间的相关性，但还没有工作将它用到情绪、气氛或者感情上面。\n\n在设计颜色组合的多种策略里面，颜色-词汇关联一直被当做它们的基础： 手动选择一组关联到特定的词汇或者概念的预设颜色组合。Kobayashi 的工作[^6]，提供了 130 种基本色彩，1170 种色彩组合，共有 180 个关键词组成。Lindner 等人[^7]使用基于色轮的颜色-词汇关联手段来生成色彩组合，用户描述语义内容，算法则可以从预设颜色库中确定合适的颜色。Jahanian 等人[^8]的工作，基于 Kobayashi 的颜色开发了一种用于杂志颜色组合设计的颜色抽取方法。Wijffelaars 等人[^9]则开发了一套通用方法，可以不需要用户输入，通过在颜色空间中进行连续路径采样来生成。相反，Colorgorical[^10]是一个自动生成颜色组合的交互式工具，用户可以根据自己的喜好来自定义采样的偏好。\n\n#### 对色彩进行量化\n\n基于感受的颜色度量标准，可以被定量表示为三维颜色空间中的几何体。通用的 CIELAB 表示方法，通过颜色的坐标系（$L^*, a^*, b^*$），提供了两个颜色之间的距离表达（欧式距离），使用极坐标来表达 a 通道和 b 通道会更加直观，L,C,H 分别表示亮度，饱和度和色调（角度）。这样就变成了柱状坐标系。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-1/92964242.jpg)\n\nLin 等人[^11]利用颜色距离度量标准从图像中抽取不同的颜色组合，包括了不同主题内颜色之间距离的均值，最小值和最大值。测量色调变化的两种手段分别是熵（entropy，表达颜色之间的区分差异）或者饱和度加权色相离差(WHD，计算了在色轮上色调之间的角度的离差，同时将饱和度也考虑进去[^12])。WHD 越高，色彩越集中。也有用 k-means 的方法来模拟颜色关联关系[^4]。\n\n#### 贡献\n\n在这个研究范围内，这项工作主要进行了三项实验，检验了色彩组合的不同属性如何和特定的情感相关联。**贡献**是：\n\n1. 证明颜色可以表达情感且色彩组合能加强情感印象，即便只是简单数据可视化中用于表达类别的颜色（范围小，数量少）。\n2. 基于色调、饱和度和亮度的分布，发现了一些关于本工作研究的情感的颜色选择规律。\n3. 提出了一个用社交网络分析色彩组合中的颜色关系的模型。\n\n### 二、方法\n\n进行了三个实验，探索了颜色-情感之间的关系：\n\n1. 分析了两个社交网络数据库中，带有标记的图片中含有的色彩组合（Flickr 和 deviantArt.com）。\n2. 生成一个颜色集，让用户选择五种颜色进行组合，能够最好地表达某种特定情感。这项实验还定义了一个新的度量方法：色彩组合权重（和该色彩组合中包含的颜色的使用频率相关）。\n3. 进行了一次验证试验，利用 2 中定义的色彩组合权重来生成颜色组合，然后让用户评判哪种颜色组合最能传递某个情感，以及哪种颜色组合最无法传递某种情感。\n\n### 三、实验\n\n#### 实验 1：图片分析\n\n##### 方法\n\n一共对 8608 张图进行了色彩分析。主要方法是：\n\n1. 筛选：在已有标记的图片中，搜索和之前提到的 8 种情感相关的图片，并排除掉带有人的，防止干扰。\n\n2. 统计：对每张图计算一个宽度为 10 的色彩分布直方图，并将这个直方图归一化成百分比表示。最终利用 k-means，对八种情感，生成了八种，一共 40 个色调的色彩分组，每个情感下，都计算了不同颜色出现的概率。结果如下：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/73974099.jpg)\n\n> 图 1：通过颜色分析实验，抽取的每种情绪下最普遍的颜色，分别为：平静、激动、积极、消极、严肃、俏皮、不安、信任\n\n##### 结论\n\n因为数据的分布是非正态的分布，所以用了 Kruskal-Wallis 检验来检验显著性。\n\n情感对亮度（$\\chi^2(78607)=199.6250, p<.0001$）和饱和度（$\\chi^2(78607)=87.7106, p<.0001$）都是有显著影响的。\n\n-   亮度上，[**平静**、俏皮、激动]>[不安、消极]。\n-   饱和度上，[平静、消极]<[俏皮、激动]。\n\n其中一个跟色彩心理学矛盾的发现是：积极的色彩里面包含了一部分棕色和黑色。\n\n#### 实验 2：用户设计色彩组合\n\n##### 实验之前\n\n**专家设计**：邀请了一个可视化颜色专家，设计了一套色彩。首先用了 k-means 再次合并相似色彩，减到 36 种。之后将太浅的颜色去掉，防止看不清楚。最后用了一些可视工具，使得最终的颜色在色调、饱和度和亮度上都分布比较均匀。\n\n**试点试验**：让有设计经验的人，根据情感创建一些色彩组合。研究目标是看看他们能否在简单的可视化任务中，为给定的八种不同情感类别，创建不同色彩组合。试点试验的结果显示了情感会强烈影响颜色的选择。正式实验中，增加了一些黑色调，将颜色扩展成**41 种**，因为试点试验中，一些比较黑暗的情感所需的颜色不够。\n\n##### 方法\n\n参与者通过如下的用户界面，选择一些颜色来表达给定的 8 种给定情感。\n\n除了情感意图之外，参与者并不知道具体的数据表示方法是什么。可以通过滑块调节透明度，选完后，然后用 0-10 的滑块来评定其满意度（自己觉得对该种情感传达的接近程度）。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/72487483.jpg)\n\n> 图 2：实验二的界面\n\n参与者在开始前，先会进行训练任务，选择颜色来表达“开心”和“伤心”这两种情感。\n\n###### 变量\n\n-   自变量（independent variables）：情感（8 种）和可视化形式（2 种，条形图和美国地图）\n-   因变量（dependent variables）：色彩度量标准（亮度、饱和度和色调），透明度以及满意度评分\n\n##### 假设\n\n-   **H1**：情感会影响颜色的选择。\n    -   低唤起度的情感（平静、颜色、信任）会用冷色调\n    -   高唤起度的情感（激动、不安、俏皮）会用暖色调（更多的红色、棕色和桔色）\n    -   积极的情感（积极、俏皮、信任）会用更多绿色\n    -   消极的则使用棕色和灰色。\n-   **H2**：情感会对亮度有显著影响：平静的会更浅，消极的则更黑。\n-   **H3**：情感会对饱和度有显著影响：高唤起度情感用饱和度高的。\n\n##### 实验设计\n\n采用了一个两路的 between-subject 设计（基于两种可视化类型），一共八个实验条件（1 个实验 1 种情感）。\n\n[between subjects design 是什么意思？between subjects design - 谢雨的回答 - 知乎](https://www.zhihu.com/question/26002453/answer/59396753)：\n\n> **Between subjects design**: 每个实验参与者只参与一个实验变量的测试（Each person see one level of independent variable），可以简单理解为一个参与者只参加一次实验\n> **Within subjects design**: 每个实验参与者都需要参与所有实验变量的测试 （Each person see all levels of independent variable），可以简单理解为一个参与者要参加所有实验变量的测试，也就是多次测试\n>\n> 再补充一种叫**mix design**的实验设计方法：这类的实验比较复杂，有多个实验变量，综合使用上述的两种方法。\n>\n> 作者：谢雨链接：https://www.zhihu.com/question/26002453/answer/59396753\n>\n> 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n##### 参与者\n\n76 个人，性别分布大概平衡，视力正常或矫正到正常，付费实验。分配到两组实验。$76\\times8=608$个实验。\n\n##### 结果\n\n删除了不完整或者重复的色彩组合，总共得到 504 个色彩组合，每个组合包含五种颜色。下图是最终结果，气泡越大，说明该种颜色的频率越高。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/63264355.jpg)\n\n> 图 3：每种情感中，颜色的频率分布\n\n可以清楚的看到，色彩会因情感发生变化，接受假设**H1**。然后用了一个非参数化的 Kruskal-Wallis 检验来检验显著性。\n\n-   **可视化形式（2 种，条形图和美国地图）**：没有显著性差异。\n-   **颜色的三个感知量（亮度、饱和度、色调）**：都有显著差异。\n\n    -   『平静』、『俏皮』、『积极』的颜色会比『不安』、『严肃』、『消极』更淡。\n    -   『平静』的饱和度最低，『激动』、『俏皮』、『积极』则更丰富多彩（饱和度高）。\n    -   情感对色调的影响非常显著。计算了每个颜色组合的 WHD（饱和度加权色相离差），看到了显著的差异。其中『激动』、『俏皮』和『积极』的色彩在空间中最为分散，而『平静』、『消极』则最为集中。\n\n    以上的结果支持了假设**H2**，亮度和愉悦度轴（『积极』、『消极』）相关。\n\n    并支持了假设**H3**，兴奋度轴会影响饱和度情况的选择（激动、俏皮 vs 平静、严肃）。愉悦度轴和兴奋度轴都会影响颜色选择，特别是在『平静』这种情感下（亮度最亮、饱和度最低）。\n\n-   **透明度**：显著性明显，但影响不大：只在『平静』的色彩上发挥作用。之后就再也不分析了。\n\n-   **满意度评分**：没有发现显著的区别，都比较高。\n\n对于核心情感（平静、激动、积极、消极），有更明显的模式：\n\n-   平静：用了更多的冷色调，也拥有最高的亮度和最低的饱和度（蓝、绿）。\n-   激动：用了更温暖的，并且更饱和的色彩（红、黄）。\n-   积极：和“激动”一样也用了强烈饱和的色彩，但包含了更多的绿色。\n-   消极：更多棕色、暗红色和灰色\n\n对于实际情感（严肃、俏皮、信任、不安），则比较有趣：\n\n-   俏皮，包含了“激动”和“积极”，颜色和“激动”比较类似，但包含了更多绿色和黄色，少一些红色。\n-   严肃，用了像“消极”一样的很多灰色，但也用了更多蓝色。这种情感的唤起度比较低，比较平静。\n-   不安，“激动”和“消极”混合，有着“消极”的灰色和棕色，但也包含了“激动”的红色和黄色。\n\n平静、负面的色彩组合则聚集的最紧密，上述这些发现证实了**H1**。\n\n#### 实验 3：用户评价颜色组合\n\n目的：确认上述结果，并生成一个算法设计标准，用实验 2 的结果（41 种颜色，504 个组合）来设计色彩组合。\n\n这个实验中，让用户每次都从五个颜色组合选项中，选择最好和最差的颜色组合。\n\n首先，对每种情感，都会生成所有颜色的组合情况$C_5^{41}=749,398$种，然后计算这些颜色组合的权重，从高到低排序。然后从三个不同区域中（最高权重区域，最低权重区域，中间权重）选出候选的颜色组合。\n\n关于如何生成最能代表某种情感的色彩组合，在该种情感下：\n\n1. 单独一种颜色的权重：也就是该颜色在实验 2 的结果中的出现频率。\n2. 某种颜色组合的权重：通过简单加和该种颜色组合包含的颜色的权重。可以认为，某种特定情感下，具有最高权重的颜色组合就最能代表这种颜色。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/78037304.jpg)\n\n> 图 4：较好（高权重）和较差（低权重）的色彩组合的示例\n\n##### 方法\n\n在实验中，参与者会看到五个相同的条形图，每个都用不同的颜色组合来上色，如下图。\n\n参与者需要对它们进行选择，确定一个表达最好的，和一个最差的。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/4515978.jpg)\n\n> 图 5：实验 3 的界面，用户对 5 种色彩组合，评出最好和最差\n\n##### 变量\n\n-   自变量（independent variables）：情感和色彩组合的权重（PW）。\n-   因变量（dependent variables）：对每个色彩组合的最好（Best）/最坏（Worst）的评价。\n\n##### 假设\n\n**H4**：更高权重的色彩组合更有可能被评价为最好（Best）\n\n**H5**：更低权重的色彩组合更有可能被评价为最差（Worst）\n\n##### 参与者\n\n38 名用户（另外有两个数据不完整）参与。性别分布大概平衡，视力正常或矫正到正常，实验最后抽奖。这些人都没参与之前的用户调研。\n\n##### 结果\n\n下图显示了评分结果。因为不同的色彩组合集之间，权重的分布不一致，所以把权重进行了归一化，变成了百分比。然后用了逻辑回归分析（logistic regression analysis）来检验权重是否是重要的判别标准。结果是非常显著的，也即**色彩组合的权重的确可以作为某种色彩组合对情感表达的优劣程度的标准**。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/78594763.jpg)\n\n> 图 6：色彩组合的打分结果\n\n结果证实了假设 H4 和 H5。\n\n更一般的，它验证了基本假设：**即便简单五种颜色进行组合，也能表达不同的情感**。在每种情感中，通过统计色调被选为最好的次数来简单生成图 7。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/8110228.jpg)\n\n> 图 7：实验 3 中，被选为最好的颜色组合中包含的色彩\n\n### 四、分析\n\n上述结果表明，不同的情感有不同的颜色选择偏好的模式。\n\n可以引入社交网络的分析方法，来分析这些颜色组合的模式。比如，中心度来确定网络中最重要的节点，网络结构模型可以来识别聚类和异常。\n\n每个色彩组合都可以被视作一个 5 节点的完全连通子图。8 种情感都可以被建模为一个 41 节点（代表 41 种颜色）的独立网络，不仅可以看到颜色使用率，还可以看到结构模式。\n\n这里用了力引导的布局算法，颜色的使用频率映射为节点的大小，颜色之间的配对关系的频率（也就是权重）会被映射为边的粗细，然后移除了边权重小于 3 的边。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-2/77051138.jpg)\n\n### 五、总结\n\n作者的逻辑：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/21023212.jpg)\n\n对每种情感选出来的优质颜色组合中的颜色，进行了 L/C/H 分布的绘制，在设计情感相关的颜色时，虽然实验结果并不能指定某些颜色就是最优质的，但的确可以避免一些传达效果不好的颜色。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-3/6928939.jpg)\n\n> 图 10：每种情感的 L,C,H 分布情况（亮度，饱和度，色调）。其中色调 H 进行了一个 60° 的旋转，以保证冷色调和暖色调分别聚在一起，所有值都统一进行了归一化。\n\n### 六、评述\n\n#### 作者讨论的限制性\n\n1. 图片数据的有限性，对一开始产生的颜色数据产生了限制\n\n2. 可视化类型的有限性，只讨论了两种可视化类型，并且每种类型下，颜色的填充面积都比较大，不足以证明其可延展性\n\n3. 可视化任务的抽象性，因为案例都是抽象的，所以在实际任务中是否有效未能验证\n\n    ​\n\n#### 个人评述\n\n**整体评述**：这种以实验为主的文章，在可视化中非常少见，首先给人眼前一亮的感觉。\n\n1. 在准备数据的时候，用已有的大数据集作为 ground truth 的方法值得借鉴，比如在生成测试数据的时候，可以通过识别已有数据集的模式来作为生成数据的标准。但作者使用的数据集限制性比较严重，可能有更普适的数据集会产生更好的结果。\n2. 事实上，实验一可以看作是作者对用户实验数据的一个预处理，实验一帮助限制了实验二的输入数据，这使得用户在进行实验二的时候，不用从大量的颜色数据中挑选自己想要的数据，而只要从有限的数据中挑选即可。这也为 user study 提供了一个有效的思路。\n3. 『他山之石可以攻玉』的分析方式，将网络分析应用到分析组合方式中。对于关系型数据的分析，可能的确可以用其他的分析方式来进行分析，或许能得到一些不错的分析结果。\n4. 2016 年，ACM 举办了第一次情感与可视化的大会 EmoVis2016，专注于数据可视化在情感方向的应用，这项工作其实很有意义，但还需要继续延伸。\n\n**不足**：除了作者提到的限制外，有几点：\n\n1. 有些写作方面的问题，以及配图的问题等，不够细致。\n2. 使用的八种基本情感，只有四种有背书，可以采用一些有背书的基础情感，比如 1980 年，心理学家 Robert Plutchik 提出的著名情绪环的概念，用图形与色彩展现出了人类所具备的八种基础情绪：喜爱，信任，恐惧，惊讶，悲伤，厌恶，愤怒，期待。\n3. 颜色的几次聚类，事实上会很大程度上影响最终结果，作者未进行讨论。当每个聚类比较大的时候，容易的到粗粒度的结果。应加以说明。\n4. 作者的 user study 的参与者，文化背景未进行介绍，明显文化背景对颜色认知很重要。\n5. 关于网络分析，力引导算法可以定义边的权重和节点的权重，作者也未提或者似乎没有使用。\n6. 可以分析讨论实验 2 的结果和实验 3 的结果进行网络分析的结果的区别，会明显看到用户的喜好的转变。\n\n**未来工作的建议**：\n\n1. 对网络分析的进一步深入。\n2. 建立算法模型，对整个 PAD 空间进行覆盖，能够为 PAD 空间的某个情感生成特定的颜色组合选项，或者生成一些不推荐的颜色组合选项。\n3. 对更多可视化类型进行讨论。\n\n---\n\n[^1]: Johannes Itten. 1974. The art of color. Reinhold Pub. Corp, New York.\n[^2]: Thomas J Madden, Kelly Hewett, and Martin S Roth. 2000. Managing images in different cultures: A cross-national study of color meanings and preferences. Journal of international marketing 8, 4 (2000), 90–107.\n[^3]: Brent Berlin and Paul Kay. 1969. Basic color terms: Their universality and evolution. Univ of California Press, Berkeley.\n[^4]: Sharon Lin, Julie Fortuna, Chinmay Kulkarni, Maureen Stone, and Jeffrey Heer. 2013. Selecting Semantically-Resonant Colors for Data Visualization. In Computer Graphics Forum, Vol. 32. Wiley Online Library, Blackwell Publishing Ltd, 401–410.\n[^5]: Vidya Setlur and Maureen C Stone. 2016. A linguistic approach to categorical color assignment for data visualization. IEEE transactions on visualization and computer graphics 22, 1 (2016), 698–707.\n[^6]: Shigenobu Kobayashi. 1981. The aim and method of the color image scale. Color research & application 6, 2 (1981), 93–107.\n[^7]: Albrecht Lindner, Bryan Zhi Li, Nicolas Bonnier, and Sabine Süsstrunk. 2012. A large-scale multi-lingual color thesaurus. In Color and Imaging Conference, Vol. 2012. Society for Imaging Science and Technology, 30–35.\n[^8]: Ali Jahanian, Jerry Liu, Qian Lin, Daniel Tretter, Eamonn O’Brien-Strain, Seungyon Claire Lee, Nic Lyons, and Jan Allebach. 2013. Recommendation system for automatic design of magazine covers. In Proceedings of the 2013 international conference on Intelligent user interfaces. ACM, 95–106.\n[^9]: Martijn Wijffelaars, Roel Vliegen, Jarke J Van Wijk, and Erik-Jan Van Der Linden. 2008. Generating color palettes using intuitive parameters. In Computer Graphics Forum, Vol. 27. Wiley Online Library, 743–750.\n[^10]: Connor C Gramazio, David H Laidlaw, and Karen B Schloss. 2016. Colorgorical: Creating Discriminable and Preferable Color Palettes for Information Visualization. IEEE Transactions on Visualization & Computer Graphics 27, 1 (2016), 521–530.\n[^11]: Sharon Lin and Pat Hanrahan. 2013. Modeling how people extract color themes from images. In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI ’13). ACM, 3101–3110.\n[^12]:\n","tags":["Visualization","Color"]},{"title":"iSphere-交互式探索大规模图的焦点+上下文球体可视化技术","url":"/blog/2018/04/26/2018-04-26 iSphere_ Focus+Context Sphere Visualization for Interactive Large Graph Exploration/","content":"\n# iSphere: 交互式探索大规模图的焦点+上下文球体可视化技术\n\n-   论文原文：iSphere: Focus+Context Sphere Visualization for Interactive Large Graph Exploration\n-   作者：Fan Du , Nan Cao , Yu-Ru Lin\n-   发表刊物/会议：[CHI '17](http://chi2017.acm.org/) Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems。\n\n文章主要对大图探索技术进行了一些综述，提出了一个新的焦点+上下文技术 iSphere，并进行了实验：在不同窗口条件下，不同图探索任务下，比较多种图的焦点+上下文技术。结果显示，iSphere 在边探索和路径探索下跟其他对照组相比有最佳的探索效率。\n\n[组会报告 PDF 链接](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/iSphere.pdf)\n\n### 一、介绍\n\n交互式探索是在大图数据中进行导航的一个主要方法。\n\n有很多可视化和交互技术用来支持大图探索（也即在一块相对较小的屏幕上探索大规模图），大概能分以下几类：\n\n-   **交互技术**：包括三种：（1）基于查询的方法；（2）在层次聚类图中进行语义缩放；（3）缩放和平移；\n\n    -   **基于查询的方法**：查询是探索大图最简单的方法，可以查询节点或者链接的标签，并展示一部分用户感兴趣的图。但这类探索方法只在用户任务明确，查询可以明确定义的时候才能有效。\n\n        ​\n\n    -   在层次聚类图中进行语义缩放\\*\\*：经常被用在层次聚类图的可视化中，当用户缩放到下一个层次中，则需要可视化当前层次的图。和一般的缩放相比，语义缩放不仅改变了图的表示，也同时更新了需要展示的数据。\n\n        层次聚类图可视化提供了附加的上下文信息用来进行数据导航。然而在不同分支下，叶节点之间的拓扑信息被隐藏，用户要进行缩放。并且，当层次比较深的时候，或者说有很大的扇出（缩放的代价）时，语义缩放就会很低效。\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/55799171.jpg)\n\n    -   **缩放和平移**：为了消除无效的语义缩放，则需要将层次扁平化或者索性去掉层次结构。但是当展示大数据集的时候就会缺少空间。缩放和平移经常一起使用，用来解决这个问题。\n\n    ​\n\n-   **可视化技术**：两种通用的可视化设计原则：（1）概览+细节；（2）焦点+上下文。\n\n    -   **概览+细节**：概览视图用来描绘整个图，然后细节图则表述不同的视角下的图的细节。\n\n        概览视图一般在一个小的视窗下，一般悬浮在另一个大的窗口（一般用来展示部分选择的图的细节）前面，或者相反。两者通过交互一起联动。\n\n        这种技术很容易实现并使用广泛 ，但这种在两个分离的视图中展示概览和细节的形式，打破了空间连续性。\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/44210738.jpg)\n\n    -   **焦点+上下文**：另一种通用的探索大数据的可视化设计原则。使得观察者能主要看感兴趣的部分（全细节）同时将上下文结构用概览的形式展示。焦点+上下文技术有两种分类：平面的和双曲空间的。平面探索展示的上下文太少，后者则引入了过多的畸变。\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/32982992.jpg)\n\n作者提出了一个新颖的焦点+上下文的展示方式，iSphere。将节点链接图映射到黎曼空间中，然后再正交投影到二维平面上。产生的焦点上下文视图，有一个聚焦区域并被周围的上下文所包围。文章的主要贡献有：\n\n1. 提出了一种新的用于探索大规模图的焦点上下文展示方法。\n2. 进行了第一次用于比较两种不同的焦点+上下文技术的用户调研（在不同的探索任务、屏幕大小以及图大小下进行）。\n3. 提供了针对实验结果的拓展性的分析和讨论，主要围绕不同的焦点+上下文技术在何时、为什么以及怎么发挥作用或者说它们拥有的限制。以及 iSphere 用在小屏幕上的优点。\n\n### 二、焦点+上下文技术\n\n焦点+上下文技术，最简单的方法就是在一个可以缩放和平移的窗口进行展示（不带有任何畸变），但这只能展示一部分的数据。\n\n#### 畸变导向技术\n\n畸变导向的技术则提升了这种设计，在展示更多包围的上下文的同时，将聚焦区域放大，并且不用增加展示区域或者损失空间连续性。技术有：\n\n-   polyfocal projection 多焦点投影[^1]，下图左，图像的每个像素点上的畸变率，跟该像素离焦点中心的距离的 N 次方成反比。\n\n-   graphical fisheye views 图鱼眼，下图右，将图像的鱼眼转换到拓扑结构上\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/82242877.jpg)\n\n-   topological fisheye views 拓扑鱼眼。在图鱼眼的基础上，增加了层次聚类图，展开焦点附近的层次聚类图，而将远离焦点的聚合起来。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/99073611.jpg)\n\n但，在给定的畸变率限制下，这些技术都无法将整个可视化平面放进焦点+上下文展示中。而且，过去的用户调研显示，引入了畸变，就会降低用户的表现，因为他们需要留意畸变的形状和位置以便在脑中进行回忆。\n\n#### 非欧式几何技术\n\n非欧氏几何会用来构造更高的畸变率的焦点+上下文展示。在三维空间中有两种非欧氏几何，**椭圆几何**和**双曲几何**。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/38473098.jpg)\n\n-   椭圆几何能够被可视化为一个三维球体的表面，当通过**正交投影**将这个球体投影到屏幕上时，就会自动生成一个焦点+上下文的展示（上图左）。然而这些技术会被『表达问题』所限制，因为球体表面区域有限。\n\n-   双曲几何，能够用 Poincare disk 模型（庞加莱圆盘模型）在二维空间进行描述。就如上图右展示的那样，这种模型利用**透视投影**将无限的双叶双曲面投影到一个圆盘上。会有较高的畸变率，但可以投影到任意大小的窗口中。庞加莱圆盘模型是保角的，这对保持结构和形状很重要。但庞加莱圆盘模型虽然能保持角度但是却会让直线、曲线产生畸变。\n\niSphere 解决了上述的限制，该种方法相对温和的畸变率，能比平面展现更多的上下文，相对于双曲几何而言则能降低边的扭曲。\n\n### 三、ISPHERE 的设计\n\n#### 1 设计思想\n\niSphere 适用于任何类型的图（有向无向，无部/二部/多部，平坦图/非平坦图），可以是任何大小的节点链接图，并且可以是任意的节点链接布局。\n\n首先，将图布局在一个虚拟平面$\\Bbb P$上，将$\\Bbb P$映射到单位球体$\\Bbb S$上（基于球面投影 Stereographic Projection 的逆过程，Stereographic Projection 球面投影，也就是如何将地球仪上的地图投影成平面的过程）。在这之后，$\\Bbb S$会通过正交投影投影到一个二维平面上，形成一个焦点+上下文视图，如下方的示意图。\n\n##### 布局方法\n\n可以用任意的布局方法，布局是离线进行的。\n\n##### 将虚拟平面映射到黎曼球体上\n\n将虚拟平面映射到黎曼球体上。基于球面投影的逆过程。\n\n球面投影的正向过程：\n\n北极点$N: (0,0,1)$\n\n球面上的某个点$P: (x, y, z), x^2+y^2+z^2=1$\n\n虚拟平面上的投影结果：$$P': (X, Y) = (\\frac{x}{1-z}, \\frac{y}{1-z})$$\n\n逆向投影：\n\n$P:(x, y, z) = (\\frac{2X}{X^2+Y^2+1}), \\frac{2Y}{X^2+Y^2+1}, \\frac{X^2+Y^2-1}{X^2+Y^2+1})$\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-5-4/81448962.jpg)\n\n以上的过程是保角的，感兴趣的区域（赤道内）会被投影到南半球，其他区域则投影到北半球，无限远的点会被投影到北极点。\n\n##### 渲染\n\n通常只会渲染$\\Bbb S$的南半球（正交投影），因为它展示了聚焦区域。用 GPU 在像素级别上进行并行渲染。\n\n当边是任意的曲线的时候，则需要将边的每个像素点都映射到球体上，然后用样条曲线进行差值来进行模拟。\n\n当边是直线的时候，就可以简单用投影的性质进行映射。一条直线就可能是一个大的弧。\n\n本文假设所有边都是直的。\n\n##### 交互\n\n缩放和平移都在 iSphere 上进行了实现。缩放是通过调整$\\Bbb S$的半径。平移则是基于莫比乌斯变换 Möbius transformation。一个等价的实现则是保持$\\Bbb S$不变，而简单平移和缩放虚拟平面。这种平移的效应可能像是旋转球体。\n\n#### 和双曲投影的比较\n\n两者有很多共同的性质：\n\n1. 两者都将原始的欧式平面转换成了一个焦点+上下文的展示，中间区域被放大，周围区域则被压缩成为上下文。\n2. 他们都提供了保角变换，图结构能够被保留。\n3. 能够将无限的信息空间映射到单位空间中，就可以用任意大小的窗口进行可视化。\n\n不同的性质：\n\n1. 双曲显示会有更高的畸变率，因为它将所有的空间都展示给用户，那么高层次的拓扑任务，比如检测聚类，就会变得更简单。但高度的畸变会让小的移动产生大的视觉变化。相对而言，iSphere 将信息空间映射到三维黎曼球体上，然后正交投影到二维平面上，于是只要展示半球即可，将远离聚焦区域的节点隐藏。\n2. 一条双曲线，在庞加莱圆盘上会被映射成一个欧几里得圆的一个弧，该弧垂直于原盘边界。\n3. 在双曲几何的环境里，平面的曲率是负数，而黎曼球体上则恒定为正数。这些性质则会影响结构的表示。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/7958076.jpg)\n\n### 四、实验设计\n\n#### 对照实验\n\n比较了三种技术，平面（$D_p$），双曲（$D_h$），iSphere（$D_s$）。\n\nJAVA 实现。\n\n三者用了同样的布局方法。\n\n#### 任务\n\n1. 节点探索：给定一个节点，找到最高度数的邻节点。\n2. 边探索：给定两个节点，找到拥有最高度数的公共邻节点。\n3. 路径探索：给定路径，找到路径上最高度数的节点。\n\n所有的任务都是一个广跨度的探索。只要求用户选择一个单一的目标，这样可以减少他们的操作。\n\n#### 变量\n\n文章用了 Exploring community structure in biological networks with random graphs[^4]中提到的图数据模型来生成能够精确控制规模和社团结构的图数据。并且用了四种不同的窗口大小。\n\n让四名用户进行了一次试点研究来决定是否有其他的条件影响用户的表现。\n\n并没有引入畸变透镜的技术，因为这些技术往往无法完全涵盖一个相对较大的虚拟平面，并且可能会引入其他的因素。\n\n-   **展示技术**：平面（$D_p$），双曲（$D_h$），iSphere（$D_\u0004s$）\n\n    ​\n\n-   **图规模**：参数为节点个数和边数。\n\n    在试点研究中进行了选择，选出了对用户表现区分的最好的参数。\n\n    最多 2048 个节点，保证所有任务都可以在大约 30 秒时间左右完成。（2048 个节点已经是作者认知中，对照比较实验中用的规模最大的图了）\n\n    然后为了验证不同的展示形式的 scalability：当图规模指数增长的时候，用户表现的趋势。\n\n    故而选择了$2^7, 2^8, 2^{11}$节点数量。然后 8 作为平均度数，边数则是 1024/4096/16384。\n\n    ​\n\n-   **图结构**：用了模块度（modularity）来测量图的聚类能力。\n\n    高模块度的图显示了清晰的模块结构，低模块度则没有清晰结构。\n\n    固定了聚类数量为 3，使得实验难度较为中等。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/4789149.jpg)\n\n-   **窗口大小**：$361 \\times 203mm, 148 \\times 197 mm, 58 \\times 104 mm, 36 \\times 42 mm$，笔记本电脑、平板、⼿机、⼿表\n\n除了以上三个原因，节点的数量和分布也很重要（参数都由试点研究进行确定，控制一个中等难度）：\n\n-   任务一中，给定节点为一个 15 度的节点，邻节点分布在不同的聚类中。\n-   任务二中，两个节点从属于不同的聚类，拥有三个公共邻节点。\n-   任务三种，路径长度为 5，节点散布在 3 个不同的聚类中。\n\n#### 实验条件\n\n每个参与者要经历 648 条测试（3 种技术，3 个任务，4 种窗口大小，3 种图规模，2 种模块度，3 次重复），一共预计要花 5 小时完成。这太耗时了，不大可能。为了降低这个疲劳问题却保证结果的质量，作者设计了两个对照实验，来覆盖所有的测试条件。\n\n|            |                       实验 I                       |               实验 II               |\n| ---------: | :------------------------------------------------: | :---------------------------------: |\n|       技术 | **双曲（$D_h$），平面（$D_p$），iSphere（$D_\u0004s$）** | **平面（$D_p$），iSphere（$D_\u0004s$）** |\n|       任务 |                     T1，T2，T3                     |             T1，T2，T3              |\n|   窗口大小 |                     笔记本电脑                     |          平板、手机、手表           |\n|     图规模 |                   **小、中、大**                   |                 大                  |\n|   图模块度 |                       低、高                       |               低、高                |\n|   重复次数 |                         3                          |                  3                  |\n| 参与者数量 |                         18                         |                 18                  |\n| 总测试条数 |                  2916（18\\*162）                   |           1944（18\\*108）           |\n\n#### 假设\n\n假设图规模较小，视窗较大的时候，三种不同技术效果差异不大；\n\n但当图的规模增大时或者窗口的大小降低时，保留图的上下文则能够指导用户进行导航，并且更高效的找到目标。\n\n-   $D_h$（双曲）拥有最高的畸变率，全图都会被展示出来，但只把聚焦区域留在中间，其他图压缩为上下文环绕着聚焦区域。\n-   $D_s$（iSphere）有着较低的畸变率，只将相关的部分展示为上下文围绕着聚焦区域。\n-   $D_p$（平面）没有畸变，展示了最少的上下文。\n\n也就是说更高的畸变率能增加上下文的数量，从而引导数据探索，但也带来更弯曲的边以及更畸形的图结构，交互的时候容易引起更大的视觉变化。因此更高效的图探索要在两个因素之间进行平衡。\n\n在三种技术中，$D_h$和$D_s$提供了更多的上下文信息，那么就能更好的进行节点探索任务，故而假设：\n\n-   **H1(a)**：在实验 1 中，当图规模上升的时候$D_h$比$D_s$$D_p$更高效\n-   **H1(b)**：在实验 1 中，当窗口大小降低时，$D_s$比$D_p$更高效。\n\n$D_s$比$D_p$展示了更多的细节，并且它的边比$D_h$畸变更少，故而假设：\n\n-   **H2(a)**：在实验 1 的任务 2 中，图规模上升，$D_s$比$D_h$和$D_p$效率更高\n-   **H2(b)**：在实验 2 的任务 2 中，窗口大小下降时，$D_s$比$D_p$效率更高\n-   **H3(a)**：在实验 1 的任务 3 中，图规模上升，$D_s$比$D_h$和$D_p$效率更高\n-   **H3(b)**：在实验 2 的任务 3 中，窗口大小下降时，$D_s$比$D_p$效率更高\n\n在任务 3 中，用户表现还会受到图的拓扑结构图结构的影响，当模块的结构比较清晰时，$D_p$会表现最佳，因为它保留了原始结构，没有畸变。当模块结构不清晰时，用户则会受益于焦点+上下文的展示，相信$D_s$会因为它较为温和的畸变率表现的更好：\n\n-   **H4**：当模块度高时，在任务 3 中，$D_p$会比其他两者表现的更高效\n-   **H5**：当模块度低时，在任务 3 中，$D_s$会比其他两者表现的更高效\n\n### 五、用户调研\n\n#### 参与者和实验设备\n\n实验 1：18 人，12 男 6 女，23-34 岁，均值 26.55 岁，标准差 3.03\n\n实验 2：18 人，11 男 7 女，19-25 岁，均值 20.44 岁，标准差 1.54\n\n都是计算机科学的学生或研究人员，有正常或者纠正到正常的视觉。\n\n白背景，黑节点，节点大小反映了它的度数（$radius=2 \\times log_2(degree+1)$），边也是黑色的，1 像素。\n\n当鼠标悬浮在节点上时，该节点和邻接边会变成蓝色。当点击节点，高亮会保持，直到下次点击。\n\n#### 过程\n\n-   **介绍**：开始实验前，先向参与者介绍图探索技术，向他们展示同个图是如何用不同技术进行展示的，如下图，展现了不同技术不同缩放率下的结果。\n\n    然后解释三种探索任务，然后用调研系统展示如何进行任务。\n\n-   **练习**：正式开始前都会给用户练习的时间，以保证正确理解所有的任务。练习任务包含了三种任务以及需要测试的图探索技术，使用了小规模图（128 节点，1024 边，0.3 模块度）。\n\n-   **正式实验**：分别在实验 1 和实验 2 使用了$3 \\times 3$或$2 \\times 2$拉丁方阵来平衡三种技术的顺序。三种技术的不同实验用例会被随机打乱。在三组技术下用了同样的图，但是每次重用的时候都会进行旋转或镜像变化。每个实验用例有 40 秒的时间限制，每次正式的实验会大概持续 1 小时。每次完成一种技术，参与者都会休息一会。两个实验会分别多次进行，实验 1 先进行。\n\n#### 数据收集和分析\n\n记录了完成时间和准确度(假如找到了目标节点则为 1，否则为 0)来度量用户表现。\n\n对完成时间进行了一个对数变化来归一化，然后用了对多种技术分析用 ANOVA，然后成对的技术比较则用了 t 检验。因为准确度的结果没有遵循正态分布，则用 Friedman 测试和成对 Wilcoxon 测试来分析，所有测试用了 0.5 的显著水平。\n\n|                      | 多因素检验（>2） | 成对检验（=2） |\n| -------------------- | ---------------- | -------------- |\n| 完成时间（正态分布） | ANOVA            | t 检验         |\n| 准确率（0-1 分布）   | Friedman         | Wilcoxon       |\n\n#### 实验 I 的结果\n\n将所有结果用图模块度和图规模分离。\n\n##### T1: 节点探索任务\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/4449587.jpg)\n\n> 误差线表示了一个 95%的置信区间，左边两个为准确率，右边两个为平均完成时间；上面两个为低模块度，下面两个为高模块度\n\n**准确度**：在所有情况下都没有明显区别。(a, c)\n\n**完成时间**：在所有情形下也没有找到明显区别。(b, d)\n\n总之，拒绝假设**H1(a)**。三种展示技术在任务 1 下有着相似的表现。\n\n##### T2: 边探索任务\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/23354116.jpg)\n\n> 误差线表示了一个 95%的置信区间。有显著性结果的行被绘制成白色背景\n\n**准确度**：在低模块度、图规模较大的情况下(a)，检测到了显著区别($\\chi ^2(2)=6.62, p=.03$)。$D_s$和$D_p$比$D_h$有显著更高的准确度。\n\n**完成时间**：没有发现任何显著差别。\n\n总之，$D_s$在任务 2 中，低模块度和大图规模的情况下，会比$D_h$有更高的准确度，能够部分支持假设**H2(a)**。而$D_p$和$D_s$之间没有发现明显的区别。\n\n##### T3: 边探索任务\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/56626463.jpg)\n\n> 误差线表示了一个 95%的置信区间。有显著性结果的行被绘制成白色背景\n\n**准确度**：在(a, c)中，当图规模较大时，在低模块度和高模块度的情况下都会有明显的区别。而在中等规模的图中，仅在低模块度下有差异。而在小图中则未发现显著区别。\n\n**完成时间**：(b, d)，低模块度情况下，当图规模中等或较大时会有显著区别，而高模块度情况下也同样。在中等规模图中，$D_s$和$D_p$会比$D_h$更快完成，而只在大图中，$D_s$会比$D_h$更快完成。\n\n总之，在任务 3 中，$D_s$和$D_p$会有更好的表现，特别是当图规模扩大的时候。这些结果支持了假设**H3(a)**和假设**H4-5**。\n\n##### 问卷调查\n\n实验 I 的参与者会进行问卷调研，根据对以下情况的支持有效程度对三种方法进行排序。(Q1)节点探索；(Q2)边探索；(Q3)路径探索；(Q4)大图探索；(Q5)易用程度；(Q6)总体偏爱程度。最终结果如下图：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/10477168.jpg)\n\n#### Results Of Study II\n\n结果根据模块度和视窗大小进行了分离，然后所有的图规模都是大的。\n\n##### T1: Node Exploration Task\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/88802243.jpg)\n\n> 误差线表示了一个 95%的置信区间\n\n**准确度**：$D_p$和$D_s$在所有情况下都没有明显区别。(a, c)\n\n**完成时间**：$D_p$和$D_s$在所有情形下也没有找到明显区别。(b, d)\n\n总之，拒绝假设**H1(b)**。$D_p$和$D_s$在不同的窗口大小下，任务 1 下有着相似的表现。\n\n##### T2: Link Exploration Task\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/98868642.jpg)\n\n> 误差线表示了一个 95%的置信区间。有显著性结果的行被绘制成白色背景\n\n**准确度**：$D_p$和$D_s$在所有情况下都没有明显区别。(a, c)\n\n**完成时间**：低模块度时(b)，$D_s$在手机大小视窗和平板大小视窗中的平均时间都明显快于$D_p$的平均时间。在高模块度(d)，$D_s$比$D_p$有明显更好的表现。\n\n总之，$D_s$在任务 2 中，能够比$D_p$完成更快。特别是在小窗口下，支持假设**H2(b)**。\n\n##### T3: Path Exploration Task\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/18-4-16/76744173.jpg)\n\n> 误差线表示了一个 95%的置信区间。有显著性结果的行被绘制成白色背景\n\n**准确度**：$D_p$和$D_s$在所有情况下都没有明显区别。(a, c)\n\n**完成时间**：(b, d)，低模块度情况下，在所有的视窗尺寸下，$D_s$都会比$D_p$花费显著更少的时间。当在高模块度的情况下，$D_s$会比$D_p$在手机大小的窗口和平板大小的窗口中快的更明显。\n\n总之，在任务 3 中，两种模块度情况下，$D_s$会比$D_p$更快完成，这些结果部分支持了假设**H3(b)**和假设**H5**，但和假设**H4**矛盾。\n\n##### Post-Study Questionnaire\n\n实验 II 的参与者会进行问卷调研，在不同窗口条件下选择他们认为更高效的技术。手表大小：10/18 选择了$D_s$，手机大小：11/18 选择了$D_s$，平板大小：12/18 选择$D_p$。\n\n### 六、讨论\n\n##### 为什么在实验 I 中，$D_h$会被认为最差的技术？\n\n问卷中，$D_h$被用户挑选为支持大图探索最低效的技术。一个用户提到『在双曲的布局下，很难遍历所有的节点，因为节点之间的相对距离一直在变化』。另一个提到『图的形状一直在发生变化即便只是一点点的平移交互』。这些抱怨都来源于一个问题：畸变。一些用户建议：『静止的图可能才适合双曲空间的布局，它一点都不适合交互』\n\n##### 为什么在实验 I 中，$D_s$只是某些条件下强于$D_p$？\n\n$D_s$和$D_p$相比并没有表现出显著的优势，这个发现很神奇。采访了那些在问题 1-3 中选择了$D_p$的人。他们都感到『比起追踪曲线，追踪直线更直观、有效』。根据结果，在追踪一个较长的路径的时候，$D_p$不够能扩展 scalable。当图规模上升的时候，用户表现一个明显的下降趋势，『在$D_p$中，会花更多的时间在大图中追踪长路径，当路径太长，会记不得前面的候选节点，展示更多的上下文会帮助我记住』。因此我们认为$D_s$会比$D_p$在真实情况的大图中表现的更好。\n\n##### 为什么在实验 I 中，$D_s$最受用户欢迎？\n\n在实验 I 中，在实验 I 中，虽然$D_s$只比$D_p$好一点，但是能够提供更好的用户体验，被最多的用户喜欢(16/18)。『球体的放大作用能够帮助我看到当前聚焦区域的细节，在平面展示中，需要放大才能达到同样级别的细节，在大数据集下，球体展示相对于其他另外两种技术会看上去更稀疏一些，所以能使得探索更简单』。一些其他用户提到『球体在有限区域内展示了更多的东西』，『当使用 iSphere 时，交互会更少，特别是找公共邻节点和追踪路径的时候』很多用户特别喜欢 iSphere 的平移操作，就类似于旋转一个球体。『在 iSphere 中，中心视图会被自然放大，所以只要旋转球体而并不需要放大』\n\n##### 为什么在实验 II 中，$D_s$比$D_p$在小视窗下表现的更好？\n\n『球体展示会更少需要拖动和缩放操作，假如屏幕太小，无法同时展示太多节点，就会需要大量的平移和缩放。而球体展示能够在屏幕上展示更多的节点，就只需要更少的交互』\n\n『球体会比平面显得更稀疏一些』\n\n『在球体展示中，注意力能更集中，因为它使得窗口看上去更大了，跟踪路径会更有效，因为能有效的避免路径周围的拥挤』\n\n『如果节点能够被更清晰的展示，那么在平面上跟踪直线边会更简单』\n\n##### 为什么要使用 iSphere\n\n我们认为在使用焦点+上下文技术时，选择一个合适的畸变率很重要。高畸变率能捕捉更多上下文信息，但也使得信息空间扭曲了，这会影响用户的感知。当屏幕较小或者图规模较大的时候，我们认为 iSphere 会比较合适。\n\n[^1]: Naftali Kadmon and Eli Shlomi. 1978. A polyfocal projection for statistical surfaces. The Cartographic Journal 15, 1 (1978), 36–41.\n[^2]: G W Furnas. 1986. Generalized fisheye views. In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems. 16–23.\n[^3]: James Abello, Stephen G Kobourov, and Roman Yusufov. 2004. Visualizing large graphs with compound-fisheye views and treemaps. In International Symposium on Graph Drawing. 431–441.\n[^4]: Pratha Sah, Lisa Singh, Aaron Clauset, and Shweta Bansal. 2014. Exploring community structure in biological networks with random graphs. BMC Bioinformatics 15, 1 (2014), 220.\n","tags":["Visualization","Graph Visualization","Fisheye"]},{"title":"如何选择JavaScript构建工具之Babel、Browserify、Webpack、Grunt以及Gulp","url":"/blog/2018/01/18/2018-01-18 如何选择JavaScript构建工具之Babel、Browserify、Webpack、Grunt以及Gulp/","content":"\n## 如何选择 JavaScript 构建工具之 Babel、Browserify、Webpack、Grunt 以及 Gulp\n\n当我们开始一个新的 JavaScript 项目时，我们需要考虑的第一件事就是搭建一个前端编译环境。但是在面对众多的 JavaScript 构建工具时，我们却无所适从，不知道究竟哪一个才是最适合我们的。\n\n想象一下，如果有一个很简单的判断标准，让你知道如何针对不同的项目，选取不同的前端构建工具，那是不是很美好呢？事实上，在使用自动构建系统，积累了 5 年的项目开发经验之后，我总结出来如下内容。相信我，它是可以让你明白不同构建工具的使用场景的。\n\n## 开门见山\n\n判断你的项目需要使用哪种构建工具是很容易的：\n\n- 如果是小项目的话，基于 ES6 编译器即可\n- 如果是单页应用的话，还需要一个模块打包器\n- 如果你的项目，部署在了生产环境之中，除了上述之外，还需要一个能够自动执行的任务运行器\n\n下面是我推荐的一些可以满足你上述需求的前端构建工具：\n\n- 使用 `Babel` 可以编译适配 ES6 代码\n- 使用 `Webpack` 能够打包 JavaScript 文件以及其相关的依赖\n- 使用 `Gulp` 能够自动化地将文件批量重命名，从而刷新静态资源文件的缓存\n\n那么，问题来了，前端构建工具那么多，为什么我偏偏推荐上述的这些呢？\n\n## 追根溯源\n\n我对很多流行的 JavaScript 构建工具进行了分析，并分别找出了它们的优点与缺点。既然编译器是无论如何都需要的，那么我们就从编译器开始说起吧。\n\n### 编译器\n\nES5 版的 JavaScript 并不是那么优雅。尽管 ES6 与 ES7 有了非常大的提升，但是目前的浏览器并不支持 ES6 与 ES7。\n\n幸运的是，有很多工程师打造了能够将`新的 JavaScript 代码`转换成`浏览器支持的 JavaScript 代码`的工具，有的甚至还在此基础上，加入了新的特性与功能 — 例如微软的 TypeScript 。但是如果我们要在众多的 JavaScript 编译器中，选取一个最接近 JavaScript 官方代码风格的，那么 `Babel` 无疑是最优秀的。\n\n#### Babel\n\n在阅读完这篇文章之后，如果你必须要学着使用一款工具，那么这款工具肯定就是 `Babel` 了\n\nBabel 的功能并不会让你大吃一惊，正如你所期待的那样，它主要是将 ES6 代码转换成浏览器所支持的 ES5 代码而已。还有一点就是它允许你在 Babel 已拥有的转换器基础之上，定制属于你自己的转换器——欣喜的是，Babel 的社区在转换器方面，已经为我们提供了很多。此外，它还能够对 ES7 的特性进行转换，例如 `async` / `await` 以及 `decorators`。同时，它也提供了对 React JSX 的支持。\n\n尽管 Babel 在转换 JavaScript 代码方面做得足够优秀，但是除此之外，它不能帮我们做任何事情。事实上，它甚至不能通过 ES6 的 `import` 和 `export` 的表达式，将我们的多个文件进行合并。这也是为什么我们接下来需要一个模块打包器了。\n\n### 模块打包器\n\n大多数的项目，无论规模多大，程序员都习惯于将代码拆分到多个文件之中。尽管你可以使用 `script` 标签，来一个个地引入这些单独的 js 文件，但是你终究还是需要基于不同文件的依赖关系来决定它们引入的先后顺序的。在这件事情上，工具能够比你做得更好，这也就是为什么你需要使用模块打包器，来将一些文件自动化地打包进一个单独的文件的原因。\n\n尽管我们可以从网上找到很多的模块打包器，但是只有两款是最具代表性的：[Browserify](http://browserify.org/) 与 [Webpack](https://webpack.github.io/)\n\n#### Browserify\n\nBrowserify 可以使得 Node packages 获得浏览器的支持。当然，它也可以帮助我们将 Web 应用打包成一个 Node Packages。\n\n这种以 Node 为中心的哲学，有很多的好处。使用 Browserify 来打包一个应用是非常容易的。你可以使用 Node 内置的模块，例如 `path` ，也可以引用你之前在 Node 项目中写过的任何代码。当然，缺点就是，你的单页应用通常需要的资源，正好是 Node 项目不需要的，例如 CSS 、图片以及字体。\n\n尽管存在这种问题，但是这种问题也并不是不能解决的。许多人已经写了插件来使得 Browserify 可以打包这些资源。这些插件可以使你能够转换 ES6 到 ES5 、打包 CSS、分离你的代码到多个文件之中等等。但是考虑到这些插件违背了 Browserify 这一工具的设计初衷，它的配置将会比较混乱。\n\n因此，尽管 Browserify 是一款能够优雅地将 Node Packages 打包成浏览器支持形式的工具，但是如果你写的是一个单页应用，那么你最好选择一款专门用于打包、并且能够打包所有资源文件的模块打包器。\n\n#### Webpack\n\nWebpack 是一款能够将许多的 JavaScript 模块以及它的相关依赖打包进一个单独文件的工具。它并不需要你给出这些模块的依赖具体是哪些，只要它能够打包成 JavaScript 模块即可。\n\n只要它能够打包成 JavaScript 模块即可？这意味着它不支持 CSS 和图片，是吗？当然不是，Webpack 是可以通过各种 loaders 来将各种资源文件都转换成 JavaScript 模块的神器。\n\nLoaders 是一种能够处理不同资源文件的转换器。它们能够接收任何形式的资源文件，也能输出任何形式的资源文件，而不仅仅是 JavaScript 。而且，这种操作也是可以链式的，它允许你先将 SCSS 文件转换为 CSS，然后再将 CSS 转换为 JavaScript 模块。然后，Webpack 再对这些 JavaScript 模块统一打包！\n\n如果非要说 Webpack 有什么缺点的话，那就是许多流行的案例项目都包含了令开发人员感到害怕的 Webpack 复杂的配置文件。如果你按照我的 [configuring Webpack with Babel in 26 lines](http://jamesknelson.com/webpack-made-simple-build-es6-less-with-autorefresh-in-26-lines/) 教程来做的话，你就会发现解决这种问题是如此的 so easy。\n\n经过上述的分析，现在你应该知道怎样使用模块打包器来生成一系列的静态资源文件了。但是有了这些文件之后，我们该怎么做呢？这就是该任务运行器发挥作用的时候了。\n\n### 任务运行器\n\n任务运行器是用来定义并运行任务的工具。简言之，任何你可能在命令行上执行的操作，都可以通过任务运行器来完成。\n\n在使用任务运行器之前，理解这句话是非常重要的：不要为了编写任务而编写任务。也就是说，如果你自己编写一个任务来进行模块打包，这也是可以的。但是如果你把这件事情交给 Webpack 去做的话，你只需要启动一下 Webpack 就好了，我们完全没有必要重复造轮子。\n\n编写一些你的模块打包器不能处理的任务才是有必要的，例如为模块打包器自动生成的静态资源文件在网页中插入一个 `script` 标签。\n\n#### Grunt\n\nGrunt 是一个运行你先前定义过的任务的工具。也就是说，如果你不定义任务，基本上 Grunt 不能为你做任何事情。\n\n原因就在于，Grunt 的任务并不是使用 JavaScript 的代码来定义，而是通过一系列的配置对象来进行声明式的定义的。为了保持 Grunt 核心包的大小，它的所有配置对象都是插件化的 — 从监控文件变化到复制、串联文件。\n\n这种做法也是有它的优势的。Grunt 有成千上万的插件，基本上你不需要编写任何代码，针对不同的需求，选取其一，直接拿来用即可。它最大的问题其实在于，如果你感觉确实有必要对插件运行的效果做一些微调的话，通过编写纯 JavaScript 代码是没法实现的，你必须要为此重新编写一个 Grunt 插件了。\n\n#### Gulp\n\nGulp，类似 Grunt ，也是一个用来定义并运行任务的工具。\n\nGrunt 与 Gulp 最大的不同就在于 Grunt 使用配置对象来声明任务的运行方式，而 Gulp 则使用 JavaScript 的函数来定义任务。也正是由于 Gulp 知道如何处理 JavaScript 返回的 [streams](https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/dealing-with-streams.md) 或者 [promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/) ，这使得你在编写任务的时候具备很大的灵活性。\n\nGulp 与 Grunt 一样，也拥有非常丰富的插件库。不过考虑到 Gulp 的插件提供的都是一些原始基础的功能，你也可以引用 Node 模块来丰富完善你的 Gulp 任务体系。\n\nGulp 最大的问题在于 `streams` 与 `promises` 的对接对新手来说可能是比较困难的。但是这也是一个双刃剑，随着实践经验的积累，你就能够体会到 `streams` 与 `promises` 的好处了。\n\n本文转载自思过崖的个人博客,原文链接为<http://www.siguoya.name/pc/home/article/271>\n","tags":["FrontEnd","JavaScript"]},{"title":"STRUC2VEC（图结构→向量）论文方法解读","url":"/blog/2018/01/17/2018-01-17 struc2vec Learning Node Representations from Structural Identity/","content":"\n## STRUC2VEC\n\n原文：struc2vec: Learning Node Representations from Structural Identity\n\n捕捉节点在网络中的结构信息，将它表达成一个高维向量，需要考虑以下两个相关的性质：\n\n1. 不同节点的表达之间的距离（也就是高维向量之间的距离）应该跟他们的结构之间的相似度高度相关。\n2. 节点的这种结构表达，不应该依赖于节点或者边的属性以及它们的标签。节点的结构信息应该跟他们在网络中的位置不相关。\n\n**STRUC2VEC**的基本步骤：\n\n1. 在不同的邻域大小下，比较图中的每个节点之间的结构相似度。\n\n   产生一个结构相似度度量的多层模型（hierarchy）。\n\n2. 构造一个带权的多层图，网络中所有的节点都会出现在每一层，每一层都会和度量结构相似度的多层模型（hierarchy）的每一级相对应。然后带权多层图的边的权重和该边相关的节点对之间的距离成反比。\n\n3. 使用上述的多层图生成每个节点的上下文。用带偏的 random walk 来生成多层图的节点序列。\n\n4. 使用某种技术，通过节点序列给出的上下文来学习潜在表达\n\n#### 第一步：度量结构相似度\n\n- $R_k(u)$表示了节点$u$的$k$级邻域。\n\n- $s(S)$则表示节点的集合$S \\subset V$的度数序列。\n\n- $g(D_1,D_2)$度量了两个度数序列$D1,D2$之间的距离\n\n- $f_k(u,v)$表示了$u,v$两节点之间，$k$级邻域（距离小于等于$k$的节点和所有它们之间的边）的结构距离。\n\n  $f_k(u,v) = f_{k-1}(u,v) + g(s(R_k(u)), s(R_k(v)))$\n\n  $f_{-1} = 0$\n\n  上述定义表达的是一个递归的过程，把问题转换成了如何定义两个节点集合之间的距离，也就是$g(\\cdot)$该如何计算。\n\n- 文章使用了 Dynamic Time Warping(DTW)来度量两个度数序列之间的距离。\n\n  序列 A 和 B，其中，$a \\in A$，$b \\in B$，那么$a, b$之间的距离定义为：$d(a, b) = \\frac{max(a, b)}{min(a, b)} - 1$，当$a=b$时，他们的距离也就是 0。然后两个序列之间的距离，也就是所有$a,b$组合之间的距离和。\n\n  其他方案也可以用在该框架下，感觉这里的时间复杂度相对较高，可以有替换的方案。VIGOR 论文中提到的方法？\n\n#### 第二步：构造上下文图（context graph）\n\n- 构造一个带权的多层图$M$。层数由$0到k^*$，其中$k^*$表示的是图的直径，也就是原始图$G=(V,E)$中节点之间的最远距离。\n\n- 第$k$层图表达的是节点之间$k$级邻域的相似度度量。\n\n- 故而$M$的每一层都是一个完全图，都会有$n=|V|$个节点，边的数量是$n(n-1)$，边的权重的定义：\n\n  $$w_k(u,v) = e^{-f_k(u,v)},k=0,…,k^*$$\n\n  当然，只有$f_k$定义了，边才能被定义。\n\n- 因为$f_k(u,v)$最小是 0，那么边的权重$w_k(u,v)$的取值范围是$(0,1]$，当等于 1 时，代表两个节点结构相同。\n\n- 不同层级之间，通过有向边连接，在$k$层的每个节点都会跟$k-1$层和$k+1$层的相同节点用有向边连接，边的权重定义：\n\n  $$w(u_k,u_{k+1})=log(\\Gamma_k(u)+e), k=0,…,k^∗−1$$\n\n  $$w(u_k,u_{k-1})=1,k=1,…,k^∗$$\n\n  - 其中$\\Gamma_k(u)$代表了指向节点$u$的权重大于$k$层图平均权重的边的数量：$\\Gamma_k(u)=\\sum_{v \\in V} \\mathbb{1}(w_k(u,v) > \\overline{w_k})$，也就是度量了该节点$u$和第$k$层其他节点之间的相似度。\n  - 而$\\overline{w_k} = \\sum_{(u,v)\\in  \\begin{pmatrix} V \\\\ 2 \\\\ \\end{pmatrix} }w_k(u,v)/\\begin{pmatrix} n \\\\ 2 \\end{pmatrix}$\n\n#### 第三步：生成节点的上下文\n\n利用$M$生成节点的上下文的过程：带偏的随机游走（biased random walk）。\n\n- 首先需要决定，随机游走的这一步，是留在当前层还是换层\n\n- 有一定概率$q$，留在当前层，假设留在当前层，那么从节点$u$走到$v$的概率（权重越大，概率越高，也就是更容易走到相似节点上）：\n\n  $$p_k(u,v) = \\frac{e^{-f_k(u,v)}}{Z_k(u)}$$，$$Z_k(u)=\\sum_{v \\in V, v ≠ u} e^{-f_k*(u,v)}$$\n\n- 假设在另一半概率上$1-q$，换层，换到$k+1$的概率定义：\n\n  $$p_k(u_k, u_{k+1}) = \\frac{w(u_k, u_{k+1})}{(u_k, u_{k+1})+(u_k, u_{k-1})}$$\n\n  而换到$k-1$层的概率：\n\n  $$p_k(u_k, u_{k-1}) = 1 - p_k(u_k, u_{k+1})$$\n\n- 当节点走到$k+1$层时，产生的 context 可能只是前$k$层产生的 context 的一个子集，所以这种情况下，并不没有贡献\n\n- 每次随机游走从第 0 层开始，游走步数都是一个固定的，较小的值，然后随机游走会在同一个节点上重复多次，产生多个独立的游走\n\n#### 第四步：学习语言模型\n\n通过 word embedding 的方法，对第三步生成的随机游走结果，生成高维向量。\n\n文章使用了**Skip-Gram**[^1]。\n\n[^1]: Mikolov, Tomas, et al. \"Efficient estimation of word representations in vector space.\" _arXiv preprint arXiv:1301.3781_ (2013).\n","tags":["Machine Learning","Graph Mining","Graph Embedding"]},{"title":"杂谈：六级翻译重要词汇短语","url":"/blog/2017/12/16/2017-12-16 六级翻译重要词汇/","content":"\n| 中文             | 英文                                         |\n| ---------------- | -------------------------------------------- |\n| 始于…延续到...   | started from…and lasted until...             |\n| 大幅             | dramatic/vigorous/tremendous/substantially   |\n| 最先进的         | most advanced                                |\n| 同时             | int the meantime                             |\n| 蓬勃发展         | Vigorous development/booming                 |\n| 人口迅速增长     | Burgeoning population                        |\n| 热闹的           | bultling                                     |\n| 产业             | industry                                     |\n| 第一             | stand on the top                             |\n| 占               | occupy                                       |\n| 从 x 年前就开始  | xx history of … can be traced to ...         |\n| 早在...之前      | long before                                  |\n| 推进             | promote xxx                                  |\n| 可持续发展       | sustainable development                      |\n| 明显提高         | enhanced significantly/remarkable progress   |\n| 由于             | Due to                                       |\n| 巨大的进步       | Tremendous progress                          |\n| 不足为奇         | It is no wonder that                         |\n| 蜂拥而至         | swarmed into                                 |\n| 努力             | Be striving to                               |\n| 生活水平         | Living standars                              |\n| 越来越...        | increasingly                                 |\n| 目睹了           | witness ...                                  |\n| ...的出现        | emergence of ...                             |\n| 前所未有的       | Unprecedented..                              |\n| 在这个时期       | during this period                           |\n| 还值得一提的是   | what's also noteworthy/in addtion            |\n| 四大名著         | Four great classical novels                  |\n| 说起...          | Speaking of ...                              |\n| 辉煌；灿烂       | brilliant                                    |\n| 典型代表         | Typical examples                             |\n| 结合             | combination                                  |\n| 源自             | Originate from                               |\n| 古人/祖先        | ancestors                                    |\n| 于是             | therefore                                    |\n| 哲学             | philosophy                                   |\n| 改革开放         | The reform and opening up                    |\n| 社会主义市场经济 | Socialist market economy                     |\n| 相当于           | equivalent to                                |\n| 综合             | comprehensive                                |\n| 创业者/企业家    | entrepreneurs                                |\n| 赶上             | catch up with                                |\n| 覆盖了...        | cover from … to ...                          |\n| 合作             | Cooperate with                               |\n| 展示了           | Reflect...                                   |\n| 有影响力的       | influential                                  |\n| 高铁             | High-speed trains                            |\n| 不久前           | not long ago                                 |\n| 合同             | contract                                     |\n| 信任             | have faith in                                |\n| 消除             | eradication                                  |\n| 就业机会         | employment opportunities                     |\n| 重视             | Pay more attention to / attach importance to |\n| 值得称赞         | be commendable                               |\n| 国际社会         | international society                        |\n| 贫困             | poverty                                      |\n| 使...摆脱贫困    | lift … out of poverty                        |\n| 现代化           | modernization                                |\n| 减少（n.）       | Alleviation                                  |\n| 做出不懈努力     | make unremitting efforts in                  |\n| 寻求             | pursue                                       |\n| 借鉴...的经验    | Learn from …'s experience                    |\n| 从（国情）出发   | proceeding from (national condition)         |\n| 在...的过程中    | in the process of                            |\n| 全面             | overall                                      |\n| 在全国范围内     | throughout the country                       |\n| 持续增长         | sustained increasement                       |\n| 相应的           | Corresponding                                |\n| 协调发展         | coordinated development                      |\n| 迅速超过         | screaming pass                               |\n| 同比增长（6%）   | Increase (6%) year-by-year                   |\n","tags":["Course Notes"]},{"title":"杂谈：机器学习三要素","url":"/blog/2017/11/23/2017-11-23 机器学习的三个主要组成/","content":"\n# 机器学习三要素\n\n机器学习（本文主要指的是监督学习）的最主要目标，是要让算法的最终结果跟实际真实值之间的损失函数值最小：\n\n$$argmin_{f \\in \\cal F} \\frac{1}{N} \\sum_{i=1}^{N}L(y_i, f(x_i)) + \\lambda J(f)$$\n\n对这个公式而言，主要可以将机器学习过程分解成三个部分：\n\n### 模型（model）\n\n模型指的是$\\cal F$，一般而言有 CNN/SVM/LDA 等等，我们的目标是要通过调整参数，从模型的参数空间中找出一个参数组合，使得在这个参数组合下，模型的损失函数值最小。\n\n首先需要区分一个概念，$\\cal F$和$f$的关系与区别。$\\cal F$指的是一个概念模型，比如 SVM 指的是支持向量机，那么在这个模型概念下，不一样的参数组合，就会生成不一样的具体模型，比如在支持向量机中，选择不同的核函数可以生成不同的具体的 SVM 模型（$f$）。\n\n其实，$\\cal F$是一个参数空间，是决策函数（也就是具体模型）$f$的一个值域空间。我们的目标是找出一个具体模型（知道这个具体函数的参数），使得损失函数最小化。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-23/40443514.jpg)\n\n以上这幅图，仅仅针对一个二维参数空间而言，对于不同的模型$\\cal F$，有着不同的参数空间，比如上图实线所包围的部分，就指代了模型$\\cal F$的能取值到的值域。选择不同的参数，在当前所选择的概念模型下，能生成不同的具体模型。当然，具体模型中，参数肯定不止两个，那么这个参数空间就是一个高维的参数空间。\n\n对于不同的模型（$\\cal F$），有着不同的表达能力，比如上图中虚线部分所代表的模型，表达能力大于实线部分，因为它能取到的参数空间完全包含了实线部分。比如四层卷积神经网络的表达能力大于三层。\n\n但是否表达能力越好的模型越好呢？这其实是一个权衡的问题，表达能力越好，也代表着可能这个模型的代价更高，所以我们要选择适合的模型而不是最好的模型，在有限的计算资源下，选出表达能力最佳的模型。\n\n那，是否可以把不同的概念模型（$\\cal F$）也当做一个参数维度传入参数空间呢？其实也是可以的，只不过因为计算资源有限，我们要去遍历不同的概念模型需要付出较大的代价，往往会选择某个概念模型，而不会都尝试一下。\n\n### 策略（strategy）\n\n-   损失函数\n\n    策略的一部分是损失函数，也称为代价函数。也就是$L(y_i, f(x_i))$。\n\n    我们首先要了解$y_i$和$f(x_i)$之间的关系是什么。总体而言，机器学习的目标就是要能根据输入，得到一个尽量接近事实的输出值。比如通过西瓜的外表，来预测西瓜是否是一个好瓜。\n\n    那么，在我们训练出模型之后，我们要在测试集上，来测试我们的模型的效果是否满意，就需要比对训练集对于测试集上数据（这些数据有已经得到的输入和输出对$(x_i, y_i)$，我们可以认为测试集的$y_i$是一个 ground truth，也就是标准答案）的输出（$f(x_i)$）和真实值（$y_i$）之间的差距。于是乎，我们的损失函数，就是用来做这件事情的。损失函数越小，就代表我们的模型拟合的越好。\n\n    一般而言，常用的损失函数有：（1）0-1 损失函数(0-1 loss function)，（2）平方损失函数(quadratic loss function)，（3）绝对损失函数(absolute loss function)，（4）对数损失函数(logarithmic loss function)。\n\n-   风险函数\n\n    由于损失函数度量的是某一次预测结果的好坏，我们希望衡量一下平均情况，这个平均情况也被称为经验风险（empirical risk）或者说经验损失（empirical loss）。\n\n    $$R_{emp}(f) = \\frac{1}{N} \\sum_{i=1}^{N}L(y_i, f(x_i))$$\n\n    除了经验损失以外，策略还包含结构风险（structural risk）。\n\n    因为样本容量较小时，容易产生过拟合的现象，需要用结构风险来度量过拟合。于是结构风险最小化（structural risk minimization SRM）也就成了策略的目标之一。结构风险的定义如下：\n\n    $$R_{emp}(f) = \\frac{1}{N} \\sum_{i=1}^{N}L(y_i, f(x_i)) + \\lambda J(f)$$\n\n    其中$J(f)$表达了模型的复杂度。$\\lambda J(f)$是整个结构风险的一个罚项（penalty term），因为模型越简单，复杂度就越小，过拟合的风险就越小，故而通过模型复杂度来衡量过拟合的风险。\n\n### 算法（algorithm）\n\n算法，指的就是如何找出最佳参数组合，求解最优$f$的过程，也就是可以理解为调参的过程。算法的目标就是找到全局最优解，以及求解过程的高效率和低开销。\n","tags":["Course Notes","Machine Learning"]},{"title":"杂谈：浙江大学-数据挖掘课程-复习笔记","url":"/blog/2017/11/10/2017-11-10 数据挖掘复习/","content":"\n## 1. 介绍\n\n### 什么是数据挖掘：抽取 interesting pattern\n\n### 数据挖掘的过程：knowledge discovery 过程 KDD\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/10999007.jpg)\n\n### 可以被挖掘的 pattern\n\n1. generalization(概括)\n\n    - Information integration 信息聚合，数据仓库的构建（数据清洗、变换、聚合和多维数据模型）\n    - Data cube technology 数据立方技术\n    - Multidimensional concept description 多维概念描述（分类和识别）\n\n2. association and correlation analysis(关联分析和相关分析)\n\n    - 发掘 Frequent pattern\n    - association correlation vs causality（关联，相关和因果关系）\n\n3. classification(分类)\n\n    - 建立基于训练样本的模型\n    - 描述，区分不同的类别\n    - 预测一些未知的类别标记\n\n4. cluster analysis(聚类)\n\n    - 无监督学习（比如：不知道类别标签）\n    - 将结果进行分类成不同的类别\n    - 原则：最大化类内的相似度，并且最小化类间相似度\n\n5. outlier analysis(离群点分析)\n\n    - outlier(离群点)：指的是不符合数据一般表现的数据个体\n    - 噪音？异常？\n    - 方法：聚类、回归分析\n\n6. Time and Ordering: Sequential Pattern, Trend and Evolution Analysis（时序数据，趋势分析和演变分析）\n\n    - Sequence, trend and evolution analysis（序列，趋势和演化分析）\n    - 挖掘数据流\n\n7. Structure and Network Analysis(结构分析和网络分析)\n\n    - graph mining：图数据挖掘\n    - web mining：网络数据挖掘\n    - 信息网络分析\n\n### 数据挖掘的主要问题\n\n1. 挖掘方法\n    - 挖掘多种不同的知识\n    - 在多维空间中挖掘知识\n    - 跨学科\n    - 提高在网络环境中挖掘数据的能力\n    - 噪声、不确定性、数据的不完整性\n    - pattern 演变\n    - 有约束条件的挖掘\n2. 用户交互（和领域背景知识的结合）\n3. 可视化（Efficiency and Scalability 高效、可扩展）\n4. 数据类型的多变性\n5. 数据挖掘与社会影响\n\n## 2. 数据\n\n### 数据对象和属性类型\n\n1. 数据集的类型\n    - 记录（record）：关系记录，矩阵，文档数据，交易数据\n    - 图和网络（graph and network）\n    - 有序数据（ordered）：视频、时序数据、基因序列数据\n    - 空间、图像和多媒体\n2. 结构化数据的重要特征：\n    - 维度（dimensionality）\n    - 稀疏度（sparsity)\n    - 分辨率（resolution）\n    - 分布（distribution）\n3. 数据对象\n    - 一个数据对象代表一个实体\n    - 也被叫做 samples, examples, instances, data points, objects, tuples\n    - 数据对象用属性来表述\n    - rows：数据对象；columns：属性\n4. 属性（Attribute or dimensions, features, variables）\n    - nominal：枚举属性（类别数据），类别，状态，是可数的，比如 Hair_color = {auburn, black, blond, brown, grey, red, white}\n    - ordinal：序数属性（有序数据），属性值有一个有意义的顺序，但相邻两级之间的差距是未知的\n    - binary：二元属性\n        - 对称二元属性（等价，同权，比如男女）\n        - 非对称二元属性（不等价，如艾滋病毒的阴性和阳性，将重要的（往往是稀有的）编码为 1）\n    - numeric：数值属性\n        - 数值（quantity）\n        - 区间属性（interval）：用相等的单位尺度的单元来表示，而且值是有序的。没有绝对的零值，并没有倍数关系（比如不能说 10℃ 是 5℃ 的两倍温暖）\n        - 比率属性（ratio）：有零值\n\n### 数据的基本统计描述\n\n-   中位数，最大值，最小值，分位数，离群值，方差等等（median, max, min, quantiles, outliers, variance, etc.）\n\n    -   mean，均值（代数意义上的）\n    -   mode，众数，可能有多个众数\n    -   median，中位数\n\n-   对称的和倾斜的数据：对称，正倾斜（众数小于中位数），负倾斜（众数大于中位数）\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/67206708.jpg)\n\n-   分位数，离群值和盒须图\n\n    -   分位数（Quartiles）：Q1（25 分位数），Q3（75 分位数）\n    -   四分位数间距（inter-quartile range），IQR=Q3-Q1\n    -   盒须图的五个点：min, Q1, median, Q3, max\n\n-   方差和标准差\n\n    -   有偏估计方差\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/19846478.jpg)\n\n    -   无偏估计方差\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/91244837.jpg)\n\n-   可视化\n\n    -   盒须图\n\n    -   统计直方图\n\n    -   分位数图（Quantile Plot），横轴是百分比，纵轴是数值\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/49705672.jpg)\n\n    -   Q-Q Plot，比较两组数据是否来自同一分布\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/65227165.jpg)\n\n    -   散点图（Scatter plot）\n\n### 数据相似度和相异度\n\n-   数据矩阵：n\\*p 矩阵，n 是数据对象个数，p 是属性个数。\n\n-   相异度矩阵：n\\*n 矩阵\n\n-   枚举属性（nominal attribute）的相异度度量：\n\n    -   简单的匹配，相异度 d(i,j)=(p-m)/p，p 是属性个数，m 是匹配的属性\n    -   将枚举属性转换成二元属性（比如 color={red, green, blue}，可以转换成三个二元属性），用二元属性的相异度度量\n\n-   二元属性（binary attribute）的相异度度量：\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/23023651.jpg)\n\n    -   对称属性的距离：$d=(r+s)/(q+r+s+t)$\n    -   非对称属性的距离：$d=(r+s)/(q+r+s)$\n    -   Jaccard 相关系数（非对称属性的相似度度量）：$sim=(q)/(q+r+s)$\n\n-   数值属性（numeric)：\n\n    -   标准化：\n\n        -   Z-score: $z=(x-\\mu)/\\sigma$，$\\mu$是平均值，$\\sigma$是标准差\n\n        -   平均绝对离差（mean absolute deviation）：计算每个属性的平均值，以及每个属性的标准差，再进行 z-score 标准化，更鲁棒\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/33167128.jpg)\n\n    -   欧几里得距离（Euclidean Distance）：$d=\\sqrt{(x_{i1}-x_{j1})^2+(x_{i2}-x_{j2})^2+…+(x_{ip}-x_{jp})^2}$\n\n    -   曼哈顿距离$d=|x_{i1}-x_{j1}|+|x_{i2}-x_{j2}|+…+|x_{ip}-x_{jp}|$\n\n    -   闵可夫斯基距离（Minkowski distance）：$d=\\sqrt[h]{|x_{i1}-x_{j1}|^h+|x_{i2}-x_{j2}|^h+…+|x_{ip}-x_{jp}|^h}$\n\n        范数\n\n    -   上确界距离（$L_{max}$，切比雪夫距离）\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/9919791.jpg)\n\n    ​\n\n-   有序属性（ordinal）\n\n    -   标准化，映射到[0,1]，$r_{if}$是原始值的排序值，$M_f$是属性$f$的状态数\n\n        $z_{if}=\\frac{r_{if}-1}{M_{f}-1}$\n\n    -   用数值属性提到的四种距离来计算\n\n-   混合类型\n\n    -   将所有属性，映射到共同的区间[0,1]\n\n    -   计算距离：\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-13/64012434.jpg)\n\n        -   指示符$\\delta_{ij}=0$ 表示，对象 i 或对象 j 缺少属性 f,或者$x_{if} = x_{jf} = 0$且 f 是非对称的二元属性；否则为 1。\n        -   $d_{ij}^{(f)}$，表示 i 和 j 在属性 f 上的距离：\n            -   二元属性或者枚举属性：相同为 0，不同为 1；\n            -   有序属性，用有序属性标准化的方式进行标准化\n            -   数值属性，两者的差/（属性 f 的最大值-属性 f 的最小值）\n\n-   余弦相似度（Cosine Similarity），一般用于计算文档，每个文档都有一个词频向量。\n\n    cos(d1, d2) = (d1· d2) /||d1|| ||d2|| ，两个向量之间的余弦值，||x||是 x 的欧几里得范式\n\n## 3. 数据处理\n\n### 数据质量\n\n-   **准确性（accuracy）**\n-   **完备性（completeness）**\n-   **一致性（consistency）**，有些修改了，有些没修改\n-   时效性（timeliness）\n-   可信性（believability）\n-   可解释性（interpretability）\n\n### 数据处理的主要任务\n\n-   数据清洗（datac cleaning）：填补缺失值，平滑噪声，去除异常值，解决不一致性\n-   数据集成（data integration）：将多源数据进行集成\n-   数据简化（data reduction）：降维、数量归约（使用回归，聚类等方法，用较小的表示取代数据）、数据压缩\n-   数据变换和离散化（Data transformation and data discretization），进行标准化\n\n### 数据清洗\n\n1. 缺失值\n    - 忽略\n    - 手动\n    - 添加为新的类别，比如 unknown\n    - 用平均值或者中位数来填充\n    - 用同一类的样本的均值或者中位数来填充\n    - 最有可能的值：贝叶斯形式化方法（Bayesian formula）或者决策树\n2. 噪声\n    - 分箱，划分成等频率的箱，用箱的均值或者中位数，或者最近边界来平滑数据\n    - 回归\n    - 聚类：检测并去除离群值\n    - 人机合作\n3. 不一致性（如何检测？）\n    - 用元数据（定义域，值域，分布等）\n    - 字段过载(field overloading)，用了其他属性的未使用的部分的位置\n    - 检查唯一性规则（每个值都应该不同），连续性规则（最低和最高之间没有确缺失值），空值规则\n    - 使用商业工具\n4. 伪造\n\n### 数据集成\n\n多源数据的结合：模式集成（schema integration， e.g. nA.cust-id = B.cust-#），个体识别（entity identification，识别有不同名称的相同的个体），检测和解决数据值冲突。\n\n-   数据集成中的冗余（redundancy）问题\n\n    -   两种冗余：同一个属性或者对象有着不同的名称；可被推导出来的值\n\n    -   可以通过相关分析（correlation analysis）和协方差分析（covariance analysis）进行冗余检测\n\n        -   相关分析：$\\chi^2$卡方检验\n\n            $\\chi^2=\\sum\\frac{(Observed-Expected)^2}{Expected}$\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-14/41219297.jpg)\n\n            括号中的是它的期望值，比如，90=450\\*300/(300+1200)，于是\n\n            $\\chi^2=\\frac{(250-90)^2}{90}+\\frac{(50-120)^2}{210}+\\frac{(200-360)^2}{360}+\\frac{(1000-840)^2}{840}$\n\n            卡方越大越相关。\n\n        -   相关分析：皮艾森系数（Pearson's product moment coefficient）\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-14/12962797.jpg)\n\n            ​\n\n        -   协方差分析：针对数值型数据\n\n            协方差：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-14/80220904.jpg)\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-14/48564062.jpg)\n\n            协相关系数（correlation coefficient:）：\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-14/63996666.jpg)\n\n            协方差为正，说明 A B 趋向于一起改变，A 大于期望的时候，B 也很可能大于它的期望\n\n            协方差为负，说明当一个属性小于它的期望，另一个则趋向于比期望更大\n\n            协方差为 0，说明两者独立，因为$E(A · B) = E(A)·E(B)$\n\n### 数据简化（reduction）\n\n-   降低维度（Dimensionality Reduction）\n\n    -   动机：维数灾难，当维度增加，数据变得稀疏，\n\n    -   方法：\n\n        1. 小波变换（wavelet transforms）\n\n            - 将一个信号分解为不同频率的子带，保留数据对象之间的相对距离，只保留一小部分小波系数最强的信息，和傅立叶变换类似，但空间局部性更好，有助于保留局部细节\n\n            - 为什么选择小波变换\n\n                有效移除离群值，多分辨率（在不同缩放率下都可以检测任意形状的聚类），高效（时间复杂度 O(N)），但只适用于低维数据\n\n        2. PCA 主成分分析\n\n            找出 k 个最能代表数据的 n 维正交向量（k<=n），也就是找到一个投影能够捕捉到数据中最主要的变换。\n\n            - 先标准化输入数据，使得所有属性都投影到同一区间。\n            - 计算 K 个标准正交向量，这些向量作为规范化输入数据的基，称为主成分。输入数据即为主成分的线性组合\n            - 对于主成分，按照重要程度或者强度进行排序\n            - 去掉排序靠后的，不重要的，方差较小的那些正交向量\n\n        3. 属性子集选择（attribute subset selection）\n\n            通过删除不相关或者冗余的属性来减少数据量。\n\n            启发式搜索（贪心算法），属性的好坏，可以用统计显著性检验来确定\n\n            - 逐步选择：每次从属性集里选出一个最好的属性，添加到目标集合中\n            - 逐步删除：每次从属性集中删除一个最差的属性\n            - 两者结合：每次都选出一个最好属性，并删除一个最差的\n\n            ​\n\n-   简化数量（Numerosity Reduction）\n\n    -   参数化方法\n\n        假设数据会符合某些模型，这样就可以只记录模型参数，忽略数据（x，y 表示数值属性）\n\n        -   线性回归：简单直线（$y=wx+b$）\n        -   多元回归：用多个自变量的线性函数对因变量 Y 进行建模（$y=b_0+b_1x_1+b_2x_2+...+b_kx_k$）\n        -   对数线性模型：对于离散属性值，可以用对数线性模型，基于维组合的一个较小子集，估计多维空间中每个点的概率。\n\n    -   非参数化方法\n\n        未假设模型的存在\n\n        -   直方图：等宽分割（宽度接近）和等频分割（高度接近）\n        -   聚类\n        -   采样\n            1. 无放回简单随机采样\n            2. 有放回简单随机采样\n            3. 分层抽样（stratified sampleing）：分割数据集。对倾斜数据比较有效\n        -   数据立方聚集\n\n-   数据压缩（Data Compression）\n\n    -   字符串压缩\n    -   音频/视频压缩\n\n### 数据变换和数据离散化\n\n-   数据变换\n\n    1. 光滑（去除噪声）\n\n    2. 属性构造（ 由已有的属性构造出新属性添加到属性集中）\n\n    3. 聚集（汇总）\n\n    4. 规范化（标准化）\n\n        - min-max，标准化到[new_min, new_max]\n\n            $v'=\\frac{v-min}{max-min}*(new\\_max-new\\_min)+new\\_min$\n\n        - z-score\n\n            $v'=\\frac{v-\\mu}{\\sigma}$\n\n        - 小数定标 decimal scaling\n\n            $v'=\\frac{v}{10^j}$，其中 j 是使得 v'最大绝对值小于 1 的最小的整数\n\n    5. 离散化\n\n-   离散化\n\n    1. 分箱：无监督，自顶向下分裂，指定箱的个数；容易受离群值影响；有等宽和等深频\n    2. 直方图：无监督，自顶向下分裂，等宽/等频\n    3. 聚类：无监督，自顶向下分裂/自下向上合并\n    4. 决策树：有监督，自顶向下分裂。\n    5. 相关性分析。有监督，自下向上合并\n\n    -   概念分层\n\n        -   通过用户或专家，显式的说明部分或者所有的属性层次序列\n\n        -   通过显示数据分组，说明分层结构的一部分，比如定义{浙江，江苏，福建}属于华东地区\n\n        -   自动根据每个属性的不同值个数产生概念分层\n\n            ​\n\n## 4. 数据仓库和联机分析处理\n\n## 5. 数据立方技术\n\n## 6. 挖掘频繁模式、关联和相关性\n\n### 基本概念\n\n1. 动机：找到数据的内在规律\n\n2. 项集（itemset）\n\n3. 事务（transaction），为一个非空项集\n\n4. 频度（frequency），\n\n5. 关联规则（association rules），X=>Y，X，Y 是两个不相交的非空项集。\n\n6. 强关联规则：支持度和置信度都高于阈值\n\n7. 支持度（support）：包含$X \\cup Y$的事务的出现概率\n\n8. 置信度（confidence）：包含 X 的事务同时也包含 Y 的概率，P(Y|X)\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/1487277.jpg)\n\n    $support(Beer \\Rightarrow Diaper)=count(10,20,30) / 5 = 60\\%, confidence(Beer \\Rightarrow Diaper)=count(10,20,30) / count(10,20,30) = 100\\%$\n\n    $support(Diaper \\Rightarrow Beer)=count(10,20,30) / 5 = 60\\%, confidence(Diaper \\Rightarrow Beer)=count(10,20,30) / count(10,20,30,50) = 75\\%$\n\n9. 因为长项集的子项集组合过多，比如包含 100 项的相机，它的子集组合就有$2^{100}-1$个。故而把问题转换成挖掘其中的闭频繁项集和极大频繁项集：\n\n    - closed pattern：如果不存在 X 的真超项集 Y，使得 Y 和 X 在数据集 D 中有着相同的频度，那么称 X 为闭的（closed）\n    - Max-Patterns：如果 X 是频繁的，且不存在 X 的超项集 Y，并且 Y 是频繁的\n\n10. 时间复杂度：最坏情况$M^N$，M 是不同的项个数，N 是事务的最大长度\n\n###\n\n### Apriori 算法：\n\n基于一个先验性质，频繁项集的所有非空子集也一定是频繁的，反而言之，如果一个项集是不频繁的，那么它的任何超集也都不用再进行验证。\n\n-   第一次生成一项集，排除里面支持度小于阈值的项集。\n-   根据上一次生成的项集，形成 N+1 项集\n-   排除 N+1 项集中，支持度小于阈值的项集，重复上一步，直到所有项集的支持度都低于阈值\n\n案例：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/11954617.jpg)\n\n### 提高 Apriori 算法：\n\n-   问题：多次扫描数据库中的事务，庞杂的候选项，计数候选项支持度的开销大\n-   解决：\n    1. 划分（partition）：只需要两次扫描数据库。第一次，将数据库 D 中的事务，划分成 n 个非重叠分区，计算每个分区的局部最小支持度计数阈值（min_sup \\* 分区事务个数）。若项集超过这个局部最小支持度计数，那么认为这个项集是局部频繁项集。全局的频繁项集一定出现在局部频繁项集中，故而将局部频繁项集作为 D 的候选项集；第二次，再次扫描 D，评估候选项集的实际支持度，删除低于阈值的项集。\n    2. 散列（hash，DHP）：利用散列哈希，如果哈希结束后，桶中的项集个数比阈值还小，那么这个桶中的项集就一定会被淘汰。而桶中项集个数大于阈值，也不一定就是频繁项集。\n    3. 采样（sampling）：牺牲精度换取可行性。利用 D 的一个采样 S，找出 S 中的频繁项集（故而阈值也会重新计算，此时的频繁是相对 S 的频繁），但 S 中的频繁项集并不一定是 D 中的频繁项集，会有丢失。故而要用低于最小支持度的阈值来搜索 S，从而提高精度。\n    4. 动态项集计数（DIC）\n\n### 模式增长方法（Pattern-Growth Approach）\n\n1. 构建 fp tree：\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/53320418.jpg)\n\n2. 条件模式基（conditional pattern bases）\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/10773567.jpg)\n\n3. 寻找条件模式树（conditional FP-tree，类似于寻找最长公共子序列）\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/19614960.jpg)\n\n4. 简化，前缀可以被简化成一个节点\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/95693211.jpg)\n\n5. fp-tree 的优势\n\n    - 完全性（completeness）：包含了 fp mining 需要的所有信息，不拆分任何一个事务的长 pattern\n    - 紧密型（compactness）：去除了无关信息（非频繁的项被省去）；高频项被放在前面；不会比初始数据库更大\n\n6. 挖掘方法\n\n    - 对每个频繁项，构造它的条件模式基（conditional pattern-base），进而构造它的条件频繁模式树（conditional FP-tree）\n    - 对每个 conditional FP-tree，重复以上步骤\n    - 直到 FP-tree 是空的，或者只有一条路径（单一路径的所有子路径，组成了频繁模式）\n\n7. 分割投影\n\n    为了让 fp-tree 能放进主存，需要将数据库划分成投影数据库的集合。比如 4 图中，就可以先分成两个以 r1 为前缀项集的投影数据库$\\{b1\\}，\\{ \\{c1,c2\\},\\{c1,c3\\}\\}$\n\n### 用等价类变换（ECLAT）进行垂直数据格式挖掘\n\n前面的方法都是 TID 项集格式的挖掘方式，这种数据格式称为水平数据格式；而垂直数据格式刚好是它的一个转置。$t(X)= {T1,T2,T3},  t(XY) = {T1, T3}$\n\n加速：比如上方，$Diffset(XY,X)={T2}$，这样就不用记录$t(XY)$的两个项，而只要存储差集的一个项就行了。\n\n### 挖掘闭频繁模式和极大模式\n\n1. 挖掘闭模式\n\n    - **项合并**：如果包含频繁项集$X$的事务都包含$Y$，且不包含$Y$的任何真超集，那么$X \\cup Y$形成一个闭频繁项集，并且可以不再搜索包含$X$且不包含$Y$的任何项集。\n    - **子项集剪枝**：如果 X 是一个已发现的闭频繁项集 Y 的真子集，且$support\\_count(X)=support\\_count(Y)$(说明，X 没有单独出现在任何事务中)，那么 X 和 X 的子集都不可能是闭频繁项集\n    - **项跳过**：在头表不同层，某个局部频繁项都有着一样的 support，那么这一项就可以从头表中删除\n\n2. 挖掘极大模式\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-15/71303397.jpg)\n\n### 找出 interesting pattern\n\n强关联规则并不一定准确。需要其他度量\n\n-   correlations（相关性）。\n\n    -   提升度 lift\n\n        假如 A 项集和 B 项集的出现是独立事件，那么$P(A \\cup B) = P(A)P(B)$；否则，两者相互依赖（dependent）和相关（correlated），可以通过提升度（lift）来表示\n\n        $lift(A, B) = \\frac{P(A \\cup B)}{P(A)P(B)}=\\frac{P(B|A)}{P(B)}$\n\n        如果提升度小于 1，说明发生 A 时发生 B 的概率，比光是发生 B 的概率要小，A 和 B 负相关；\n\n        如果提升度大于 1，说明发生 A 时发生 B 的概率，比光是发生 B 的概率还大，A 和 B 正相关；\n\n        如果提升度等于 1，说明发生 A 时发生 B 的概率，和光是发生 B 的概率一致，说明两者无关独立。\n\n    -   卡方$\\chi^2$\n\n-   不平衡比（Imbalance Ratio）\n\n    $IR(A, B) = \\frac{|sup(A)-sup(B)|}{sup(A)+sup(B)-sup(A \\cup B)}$\n\n    分子是支持度之差的绝对值；分母是包含 A 或 B 的事务个数。越大越不平衡。\n\n## 7. 高级模式挖掘\n\n## 8. 分类\n\n预测问题包括分类和数值预测。\n\n### 分类：一个两步过程\n\n1. 模型建构\n    - 每个样本都假设属于一个预定义的类\n    - 模型可能表现为：分类规则，决策树或者数学公式\n2. 模型使用\n    - 评价模型精确程度\n    - 假如精确度可接受，那么就可以用来标记新数据\n    - 监督学习和无监督学习\n        - 监督学习：训练数据是有标记的\n        - 无监督学习：训练数据无标记，目标是进行聚类\n\n### 决策树归纳\n\n-   决策树的构建算法：自顶向下的递归分治算法\n\n    1. 一开始所有训练样本都在根节点上，所有的属性都是有类别的（假如是连续的，需要提前离散化）\n    2. 基于参数中给定的分裂准则，用选定的属性对样本进行划分，不断迭代\n    3. 直到满足以下任一条件：\n        - 给定节点中的所有样本都是同一类的\n        - 没有剩余的属性可以被用来做进一步分割\n        - 没有剩余的样本了\n\n-   决策树构建中的分裂准则\n\n    1. 信息增益（Information Gain)\n\n        选择具有最高信息增益的属性作为节点 N 的分裂属性\n\n        - 对 D 中的元组进行分类所需要的期望信息，也被称为 D 的熵：\n\n            $Info(D)=-\\sum p_ilog_2(p_i)$\n\n            $p_i$是$D$中任意元组属于类$C_i$的概率（非 0）\n\n        - 利用某个属性对 D 进行分区，得到的分区不一定是准确的分类，所以需要计算，要得到准确的分类，我们还需要多少信息：\n\n            $Info_A(D)=\\sum \\frac{|D_j|}{|D|} \\times Info(D_j)$\n\n            其中$\\frac{|D_j|}{|D|}$充当第 j 个分区的权重。$Info_A(D)$是基于 A 划分 D 所需要的期望信息，所需的期望信息越小，分区的纯度越高。\n\n        - 信息增益：\n\n            $Gain(A）=Info(D)-Info_A(D)$\n\n            选择最高信息增益的属性作为分裂属性，也就是说选择$Info_A(D)$最小。\n\n        - 计算连续值得的信息增益\n\n            A 的值进行递增序排序，每对相邻的中值作为一个可能的分裂点（$(a_i+a_{i+1})/2$），对于 A 的给定的 v 个值，则需要计算 v-1 个可能的划分。\n\n            对每个分裂点计算$Info_A(D)$，对每个分裂点，分区个数是 2，选出最小期望信息需求的点作为分裂点。\n\n    2. 增益率\n\n        $GainRate(A) = \\frac{Gain(A)}{splitInfo_A(D)}$\n\n        其中，\n\n        $splitInfo_A(D)=-\\sum \\frac{|D_j|}{|D|} \\times log_2(\\frac{|D_j|}{|D|})$\n\n    3. 基尼指数(Gini index)，针对二元分裂\n\n        - 基尼指数，度量 D 的数据分区的不纯度：\n\n            $Gini(D) = 1 - \\sum p_i^2$\n\n        - 利用属性 A，将 D 划分为两个分区，从而得到的基尼指数：\n\n            $Gini_A(D)=\\frac{|D_1}{|D|}Gini(D_1)+\\frac{|D_2}{|D|}Gini(D_2)$\n\n        - 基尼指数下降：\n\n            $\\Delta Gini(A)=Gini(D)-Gini_A(D)$\n\n-   过拟合和剪枝\n\n    -   因为噪声跟离群点的关系，有许多分支反映了训练数据中的一场，需要进行剪枝来处理这种过拟合的问题。\n    -   先剪枝和后剪枝\n        -   先剪枝（prepruning），通过提前停止树的创建来剪枝\n        -   后剪枝（postpruning），删除节点的分支而用叶节点代替\n\n-   大数据库的分类\n\n    -   可伸缩的决策树算法，RainForest：\n\n        -   AVG-set：在每个节点上，对每个属性都维护一个 AVC-set。\n\n        -   AVC-group：节点上的所有 AVC-set 的集合。\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-16/54708839.jpg)\n\n### 贝叶斯分类方法\n\n1. 贝叶斯定理\n\n    - 先验概率，$P(H)$是 H 的先验概率\n\n    - 后验概率：$P(H|X)$是在条件 X 下，H 的后验概率\n\n    - 贝叶斯定理：\n\n        $P(H|X)=\\frac{P(X|H)P(H)}{P(X)}$\n\n2. 朴素贝叶斯分类\n\n    - 最大化$P(C_i|X)$：假定一个 tuple 用一个 n 维属性向量$X=\\{x_1,x_2,...x_n\\}$表示，且假定有 m 个类，那么配件单贝叶斯分类法中，预测$X$属于$C_i$的概率为：$P(C_i|X)$，只要找到这个最大值对应的$C_i$即可。\n\n    - 最大化$P(X|C_i)$：而根据贝叶斯公式，只要找到$P(X|C_i)P(C_i)$的最大值即可。加入类的先验概率未知，我们通常假设所有类的先验概率一致，于是我们只要找到$P(X|C_i)$的最大值即可\n\n    - 假设$X$的各个属性之间相互独立，不存在依赖关系，那么\n\n        $P(X|C_i)=\\prod P(x_k|C_i)$\n\n        - 如果属性$x_k$是分类属性，那么概率即为训练集中属性值为$x_k$，且属于$C_i$的 tuple 在$C_i$中的比例\n\n        - 如果属性是连续值，一般假设属性服从高斯分布。\n\n            $P(x_k|C_i)=g(x_k,\\mu_{C_i},\\sigma_{C_i})$![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-16/66390485.jpg)\n\n    - example\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-16/32057659.jpg)\n\n    - 关于 0 概率：拉普拉斯校准\n\n        假设训练集很大，对每个计数都加 1，也不会对概率产生太大变化，从而避免 0 概率\n\n    - 优缺点\n\n        - 优点：容易实现，在大部分情况下结果不错\n        - 缺点：基于分类条件独立假设，可以用贝叶斯信任网络来解决这个问题\n\n### 模型评估与选择\n\n1. 混淆矩阵：对于给定 m 个类，混淆矩阵至少是一个 m\\*m 的表。以下是一个 2\\*2 的混淆矩阵，纵向是实际分类，横向是预测分类。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-16/68799474.jpg)\n\n    - 准确率：$accuracy=(TP+TN)/(P+N)$\n    - 错误率：$error\\ rate=(FP+FN)/(P+N)$\n    - 有些数据是不平衡的，比如在癌症检测，显然 cancer=yes 的元组才是我们关注的，于是有了以下两个度量：\n        - 灵敏性（正确识别的正元组的比例）：$sensitivity=TP/P$，反映了识别正例的能力\n        - 特效性（正确识别的负元组的比例）：$specificity=TN/N$，反映了识别反例的能力\n    - 精度（正确识别的正元组在预测为正元组中的比例）：$precision=(TP)/(TP+FP)$\n    - 召回率：$recall=TP/P$，其实也就是灵敏性\n    - $F$度量：$F=(2 \\times precision \\times recall)/(precision+recall)$\n    - $F_\\beta$度量：$F_\\beta=((1+\\beta^2) \\times precision \\times recall)/(\\beta^2 \\times precision+recall)$\n\n2. 保持方法和随机二次抽样\n\n    - 保持方法（holdout）：将数据随机的分成训练集跟检验集（通常 2/3 作为训练集）\n    - 随机二次抽样（random subsampling）：将保持方法重复 k 次，结果取平均值。\n\n3. 交叉验证（cross-validation）\n\n    - k 折交叉验证（k-fold cross-validation），将数据随机分成 k 个相互不相交的子集（折），进行 k 次训练和检验。其中第 i 次迭代，用分区 i 作为检验集而用其余的作为训练集。准确率计算是用 k 次迭代的总数进行计算。\n\n4. 自助法（bootstrap）\n\n    在小数据集下比较好。\n\n    - $.632$自助法：对于给定的包含 d 个元组的数据集，有放回抽样 d 次，产生 d 个样本的自主样本集或训练集，其余作为验证。平均情况下，63.2%的数据会被用于训练。\n\n        准确率计算：\n\n        $Acc(M)=\\sum(0.632 \\times Acc(M_i)_{test\\_set} + 0.368 \\times Acc(M_i)_{train\\_set})$\n\n        $Acc(M_i)_{test\\_set}$是对于检验集 i 的准确率，$Acc(M_i)_{train\\_set})$是对于源数据的准确率\n\n5. 选择模型的标准：\n\n    - 准确率\n    - 速度\n    - 鲁棒性\n    - 可扩展性（对于大数据库的高效性）\n    - 可解释性\n\n### 提高分类准确率\n\n1. 装袋（bagging）：对于不同的训练集 Di（每个训练集都是一个自助样本）训练的分类模型 Mi。为了对一个未知元组 X 进行分类，每个分类器 Mi 都会返回它的预测结果，算作投票中的一票，统计最终的票，将最高的得票赋予 X。\n2. 提升（boosting）：迭代学习。初始所有训练集的元组权重都一致，每一轮迭代，提升上一次测试中出错的元组的权重，降低正确的元组的权重。\n3. 随机森林（random forest）\n\n## 9. 高级分类方法\n\n### 惰性学习法\n\n-   k-最近邻分类\n\n    ​\n\n## 10. 聚类\n\n### 聚类质量\n\n1. 高类内相似度，低类外相似度\n2. 聚类质量依赖于：相似度度量；聚类的实现；能够发掘隐藏 pattern 的能力\n3. 聚类质量的度量方法：相异度/相似度矩阵\n4. 聚类分析需要考量的因素：\n    - 划分准则：单层划分和多层划分（互相之间有层级关系）\n    - 簇的分离性：互斥（一个客户只能属于一个组）和不互斥（一个文档可能有多个主题）\n    - 相似度度量：基于距离和基于连通性\n    - 聚类空间\n    - 可伸缩性\n    - 处理不同类型属性的能力\n    - 有约束条件的聚类\n\n### 主要聚类方法\n\n1. 划分方法\n\n    - 将数据划分成 k 个分区，保证每个分区最少有一个对象；例如 k-means，k-medoids，CLARANS\n    - 发现球形互斥的簇\n    - 对中小规模数据集有效\n\n2. 层次方法\n\n    - 凝聚或者分裂的方法。层次聚类方法可以是基于距离或者密度和连通性的。\n    - 无法纠正错误的合并或划分\n\n3. 基于密度的方法\n\n    基于对象之间的距离进行聚类，只能发现球状簇。主要思想：只要“邻域”中的密度超过某个阈值，就继续增长。对于给定簇中的每个数据点，在给定半径的邻域中至少包含最少数目的点。\n\n4. 基于网格的方法\n\n    用网格化的方法把对象空间量化为有限个单元。\n\n### 划分方法\n\n一种度量簇质量的方法：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-17/11929324.jpg)\n\n$c_i$是簇$C_i$的代表（形心）\n\n1. k-means：局部最优，但不一定收敛到全局最优\n\n    将簇的形心定义为簇内点的均值。\n\n    - 初始选取 k 个点，每个点代表一个簇的初始均值或中心。\n    - 其余点根据欧氏距离，分配给距离最近的簇。\n    - 更新迭代簇内均值，再分配。\n    - 直到不再变化。\n\n    优点是高效；缺点是只在连续 n 维空间中有效，需要提前确定 k，对噪声和离群值敏感，无法处理非凸形状的数据\n\n2. k-medoids\n\n    将簇的形心定义为簇内某个实际的点。\n\n    - 初始选取 k 个点，每个点代表一个簇的初始均值或中心。\n    - 其余点根据欧氏距离，分配给距离最近的簇。\n    - 随机选择一个非代表对象$O_{random}$代替$O_j$，观察绝对误差标准是否降低\n    - 如果降低，那么说明应该进行替换，并且重新形成簇\n    - 直到不再变化\n\n    其中，绝对误差标准（absolute-erro criterion）的计算方法：如上。\n\n### 层次方法\n\n### 基于密度的方法\n\n-   主要特点：\n\n    -   可以发现任意形状的簇\n    -   能应对噪声\n    -   只扫描一遍\n    -   需要密度参数作为终止条件\n\n-   参数和基本概念：\n\n    -   Eps：邻域的最大半径（确定领域大小）\n\n    -   MinPts：邻域最大半径内的最小点数量（确定邻域最大密度）\n\n    -   核心对象（core object）：eps 邻域内至少包含 MinPts 个对象（MinPts 由参数给定）\n\n    -   直接密度可达（directly density-reachable）：p 在 q 的 eps 邻域内，说明 p 是 q 直接密度可达的\n\n    -   密度可达的（Density-reachable）：存在对象链 p1,…,pn，后一个是前一个直接密度可达的，那么说明 pn 是 p1 密度可达的；密度可达并不是一个等价关系，只有当 p1,pn 都是核心对象时，才一定保证可逆。\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-17/31501679.jpg)\n\n    -   密度相连的（Density-connected）：存在 p1，p2，q，p1 和 q 以及 p2 和 q 都是密度可达的，那么 p1 和 p2 是密度相连的。密度相连是等价关系。\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-17/63923841.jpg)\n\n-   DBSCAN（Density-Based Spatial Clustering of Applications with Noise）\n\n    对每个核心对象，将它的所有密度可达的（但未被访问过的）对象添加到自身集合中作为它的簇。\n\n    未被添加的点，就是噪声\n\n### 基于网格的方法\n\n### 聚类评估\n\n-   评估聚类趋势（assessing clustering tendency）\n\n    -   只有对有非随机结构的数据集进行聚类，才有可能产生有意义的聚类。所以聚类要求数据的非均匀分布。\n\n    -   霍普金斯统计量（Hopkins Statistic）\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-11-17/66309480.jpg)\n\n-   确定簇数量（determine the number of clusters）\n\n-   测定聚类质量\n","tags":["Course Notes","Data Mining"]},{"title":"A Survey on Graph Visualization","url":"/blog/2017/10/03/2017-10-03 A Survey on Graph Visualization/","content":"\n## 布局方法\n\n### 节点链接法\n\n#### 树状布局\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-6/47663107.jpg)\n\n三种不同方法：经典树状布局、径向布局、气泡布局，它们的相关发展：\n\n-   经典\n    -   1981 年，[Tidier Drawings of Trees]([Tidier Drawings of Trees - IEEE Journals & Magazine](http://ieeexplore.ieee.org/document/1702828/?reload=true))，提出了一种较美的树图，但是空间利用率低。\n    -   [A Compact Explorer For Complex Hierarchies](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=567745)将树的分支进行部分重叠以压缩大图，但是会损失信息\n    -   [Compact layout of layered trees](https://pdfs.semanticscholar.org/5f26/d395668644ed9ffc1b17a7780d01bb253715.pdf)提出了一种不用把父节点放中间的方法\n-   径向\n    -   Radial layout(Eades's algorithm)[A parent-centered radial layout algorithm for interactive graph visualization and animation](https://pdfs.semanticscholar.org/9b3c/8f88bc4ce150f82fa736a92555143a6c251e.pdf) and variations\n-   气泡\n    -   Ballon layout[Interacting with Huge Hierarchies: Beyond Cone Trees](https://pdfs.semanticscholar.org/972c/884f590643a2dcee25d87747fc53399dea7a.pdf)\n\n#### 树+链接布局\n\n-   [Munzner 的方法](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=636718&tag=1)适合可视化最小生成树。\n-   TreePlus\n-   最常见的方法：找到最小生成树，然后用经典树布局、径向树布局、treemap 等进行可视化，并且把剩余的边加回来。\n\n#### 弹簧布局\n\n-   Newton-Raphson method：[Automatic Display of Network Structures for HumanUnderstanding.](http://www.sciencedirect.com/science/article/pii/0020019089901026)\n-   simulated annealing method: [Drawing graphs nicely using simulated annealing.](http://dl.acm.org/citation.cfm?id=234538)\n-   GEM method: [A Fast Adaptive Layout Algorithm for Undi-rected Graphs.](https://link.springer.com/chapter/10.1007/3-540-58950-3_393)\n-   可以用来解决一些节点重叠的问题：\n    -   [Layout Adjustment and the MentalMap.](http://www.sciencedirect.com/science/article/pii/S1045926X85710105)，水平和垂直方向进行扫描，看看有没有重叠的点，然后迭代的移到不重叠的位置\n    -   [Using spring algorithms to remove node overlapping.](http://dl.acm.org/citation.cfm?id=1082334)，\n-   力引导布局，单次迭代时间是$O(n^2 + m)$，n 是节点数，m 是边数，一般需要迭代$O(n)$次达到一个理想的布局，时间复杂度经常是$O(n^3)$，甚至$O(n^4)$，而且同一个算法，同一个数据跑出来经常是不同的两个布局\n\n### 空间分割布局（Space Division Layout）\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-19/58338331.jpg)\n\n-   包含父子关系和兄弟关系。\n-   上图（[Focus+Context Display and Navigation Techniques for Enhancing Radial, Space-Filling Hierarchy Visualizations](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.1262&rep=rep1&type=pdf)）是一个 centre-out 布局，空间利用率高，但是节点的大小很难控制，实际上有很多节点的节点也会变得很大，空间浪费\n\n### 空间嵌套布局（Space Nested Layout）\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-19/56805624.jpg)\n\n-   最具代表性的：treemap，也有圆形的，circle packing（[Visualization of Large Hierarchical Data by Circle Packing ](http://delivery.acm.org/10.1145/1130000/1124851/p517-wang.pdf?ip=222.205.10.36&id=1124851&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E0E9E463C2E5391F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=986598184&CFTOKEN=23238908&__acm__=1505822649_835fd4ba085641ce5dce5587c7b044f4)），几个缺点：\n    -   很容易出现很细的矩形，导致交互问题\n    -   跟树状布局一比，层次结构比较难分辨\n    -   容易误导，相邻的两个矩形，在数据中不一定相近\n\n### 矩阵布局\n\n-   NodeTrix 和 MatLink，矩阵和节点连接图的结合\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-19/94041646.jpg)\n\n-   [Matrix Zoom: A Visual Interface to Semi-external Graphs](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1382907)用层次聚合方法来对大的矩阵进行可视化和导航（聚合树）\n\n## 图可视化技术\n\n### 降低视觉杂乱\n\n三种方法：边位移、点聚类、采样。\n\n#### 边位移\n\n-   直接优化：直接优化边的交叉是一个 NP 问题。有一些妥协的用来降低边交叉的方法：\n\n    -   [Simple and Efficient Bilayer Cross Counting](http://jgaa.info/accepted/2004/BarthMutzelJuenger2004.8.2.pdf)设计了一个二分图的边交叉减少的算法\n    -   [Overlaying Graph Links on Treemaps](https://pdfs.semanticscholar.org/2f43/a4490ef40fb15f23068a8f6dcca125207c8a.pdf)用一种非对称曲线，使得 treepmap 中的曲线向 source 方向偏移的方法，来提高辨识度\n    -   [Applying crossing reduction strategies to layered compound graphs](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D687A25729FFFCB26A7358A79679B80D?doi=10.1.1.59.3610&rep=rep1&type=pdf)提出了一种用来降低分层复合图的边交叉的方法。\n    -   [Two new heuristics for two-sided bipartite graph drawings](ftp://ftp.ifi.savba.sk/pub/imrich/gd02.1.pdf)提出了两个启发性的用以降低二部图的边交叉的策略\n\n-   合流绘制：[Confluent Layered Drawings](https://arxiv.org/pdf/cs/0507051.pdf)并不是直接降低边交叉，而是用曲线来使得边交叉部分变得平滑。基本思想是在交叉的地方，将边捆绑在一起，两个点只能通过平滑曲线才能相连。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-19/1595741.jpg)\n\n-   边聚类（Edge clustering）:[Flow Map Layout ](http://graphics.stanford.edu/papers/flow_map_layout/flow_map_layout.pdf)提出一种生成 flow map 布局的算法，但是只能应用于一组有共同端点边，然后把它们换成二叉树布局：\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-19/89575106.jpg)\n\n-   边捆绑（[Edge bundles](Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data)）：关注于 tree+link 布局，如果两条边共享一个 tree path，那么它们就会被聚合在一起。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-20/18431469.jpg)\n\n-   边扭曲的方法，使得能空出一部分空间。\n\n    -   [EdgeLens](http://ieeexplore.ieee.org/document/1249008/):在视野点将边进行扭曲，而不改变点的位置。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-20/46201953.jpg)\n\n    -   [Edge Plucking](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.169.5887&rep=rep1&type=pdf)：像百叶窗一样拉扯\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-20/6024163.jpg)\n\n    ​\n\n#### 点聚类\n\n聚类的意义是将整个图分割成几个小的子图。有很多种不同的技术，它们主要的区别是，点与点之间距离的定义或者是相似度的定义，有两类不同的定义方法：\n\n1. 基于内容的（content-based），用图中元素的语义信息来进行聚类。但是基于内容的方法，依赖于对应的应用场景，不具备太多的通用性。\n2. 基于结构的（structure-based），会将内部边比外部边更密集的一部分点，聚类为一个聚类。三类方法：\n    - **Graph Theoretical**：基于相似度矩阵，[spectral bisection](http://web.mit.edu/ehliu/Public/sclark/Golub%20G.H.,%20Van%20Loan%20C.F.-%20Matrix%20Computations.pdf)，[spectral quadrisection and octasection](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9AD9E9E4D61FA96D03AF7454C18D4527?doi=10.1.1.38.376&rep=rep1&type=pdf)，[multilevel spectral bisection](http://ieeexplore.ieee.org/document/1383163/)\n    - **Single-pass**：通过往一个初始节点上加入新节点，形成足够大的聚类。[graph growing](https://www.cs.princeton.edu/~bwk/btl.mirror/new/partitioning.pdf)，[greedy cluster]()\n    - **Iterative algorithms**：使用其他聚类算法产生的聚类，作为起点，将小的聚类合成大的聚类，所以是一种层次聚类的方法（hierarchical）。三个主要步骤：\n        - coarsening graph：粗粒度化\n        - partitioning graph：切割\n        - projecting and refining graph：投影和提炼\n\n时间复杂度是节点聚类算法的另一大难题，找到最优聚类仍然是一个 NP 问题，经典的启发式聚类算法[graph growing-1970](https://www.cs.princeton.edu/~bwk/btl.mirror/new/partitioning.pdf)需要$O(m^2n)$的时间复杂度。[Newman 的快速聚类算法](https://arxiv.org/pdf/cond-mat/0309508.pdf)要$O((m+n)n)$的时间复杂度。\n\n[聚类的美学目标](http://www.ics.uci.edu/~goodrich/pubs/dgk-bartt-98.pdf)：\n\n1. Balanced cluster：每个聚类的大小应该差不多，分布应该均匀\n2. Small cluster depth：聚类层次深度应该较浅\n3. Convex cluster drawings：每一个聚类的绘制都应该是一个简单凸区域\n4. Balanced aspect ratio：每个聚类区域不要太瘦\n5. Efficiency：高效的计算和绘制效率\n6. Symmetry：最大化对称性\n\n#### 采样\n\n-   随机采样：最普遍的方法，Rafiei 和 Curial 在[Effectively Visualizing Large Networks Through Sampling](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1532819)中阐述了多种基于采样的方法，显示在大多数情况下，在采样之后，网络的拓扑属性可以被保留下来。引入了“focus”的概念，来加入人的决策以提升采样结果。对 focus 区域和非 focus 区域权重不一。\n-   随机采样具有不可预测性，于是：\n    -   [Measuring data abstraction quality in multiresolution visualizations]()提出了两种方法（Histogram Difference Measure and Nearest Neighbor Measure.）来测量数据的抽象质量以判断采样策略是否优质。\n    -   [Sampling from large graphs](http://www.cs.cmu.edu/~jure/pub/sampling-paper.pdf)比较了已有的采样算法，给出了两种不同的采样目标：the back-in-time goal（采样后的图 S 要和原始图 G 在 S 的尺寸下相似） and the scale-down goal（要尽可能保留原始图的属性）\n\n### 交互和导航\n\n基于交互的目的，可以分成七类：\n\n-   **选择**：帮助用户高亮特定目标，或者让计算机去处理一些特定的项目\n-   **探索**：它用于将当前视图点跟改为相同布局表示中的另一部分数据，比如平移和旋转\n-   **再配置**：用于在相同表示方案（矩阵形式、节点链接形式等）的不同布局（力引导布局、树状布局等）之间进行切换，比如替换图中的节点，以及根据不同的标准重新排列数据\n-   **编码**：它用于切换不同的表示方案，例如将布局从节点链接形式更改为轮廓表示\\*\\*\\*\\*\n\n-   **抽象/具象**：它调整数据表示的抽象级别，为用户提供对数据的不同见解，例如缩放和聚类\n\n-       **过滤**：它可以减少显示的数据量，并根据用户的要求使剩余的内容更具可读性\n-       **连接**：它用于突出显示与焦点相关的内容，或者内容之间的连接。\n\n其中，探索，抽象/具象，以及过滤，这三个方法最有效。\n\n#### 缩放与平移\n\n-   基本介绍：\n\n    缩放和平移是探索大图的基础方法。平移意味着平稳移动观察点，而缩放则能让用户在数据的抽象或具象视图之间切换。这两个方法互为补充，都不可或缺。\n\n-   进阶\n\n    语义缩放（ zooming）：意味着当用户放大或缩小时，信息内容会随之发生变化。当用户放大到特定区域时，会显示更多详细信息，当用户缩小时，隐藏详细信息，只显示抽象信息。\n\n-   问题\n\n    当用户在观察地图的时候，可能它们已经放大到了杭州地区，但是此时用户想查看深圳的细节，通常需要将地图缩小，平移到深圳，再进行放大。中间的这些放大缩小的步骤，和用户想要的目标并不相关，但缺少这些步骤，显然需要更长的时间才能找到深圳。此外，用户必须在不同的缩放级别下，用户还需要调整自己的认知，以便在不同的缩放级别下识别同一个项目。\n\n    -   解决：[SPACE-SCALE DIAGRAIVIS: UNDERSTANDING MULTISCALE INTERFACES](http://delivery.acm.org/10.1145/230000/223934/p234-furnas.pdf?ip=222.205.21.60&id=223934&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E0E9E463C2E5391F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=987427103&CFTOKEN=36647399&__acm__=1505977720_a411faba79f88252b62dd47f63754a21)提出空间尺度图的概念，通过堆叠不同放大级别的原始二维表示的副本，来构造一个抽象空间，于是各种缩放和平移操作，可以描述为这个堆叠空间中的路径。例如，平移的交互操作指的是相同层中的路径，而缩放操作则是从一个层到另一个层的路径。\n\n    ​\n\n#### 过滤\n\n-   基本介绍：过滤是指从视图中隐藏或强调部分内容。\n\n-   多种方法：\n\n    -   [动态查询过滤器](http://delivery.acm.org/10.1145/200000/191775/p313-ahlberg.pdf?ip=222.205.21.60&id=191775&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E0E9E463C2E5391F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=987427103&CFTOKEN=36647399&__acm__=1505978709_8f6a923e3cedf886b50662198b7b6e9d)：查询参数可以通过滑块，按钮等快速调整。这些原则的关键在于利用人类视觉信息处理的巨大能力来帮助快速过滤观看项目。\n\n    -   LensBar：[LensBar-Visualization for Browsing and Filtering Large Lists of Data](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=6CEB89A93F982D989156BE4B0569476B?doi=10.1.1.77.2648&rep=rep1&type=pdf)一个由 Masui 提出的接口工具，提供了另一种简化过滤过程的思路。浏览和查询的操作都集成在 LensBar 中变成一个简单的滚动滑块，用户可以通过关键词过滤来控制显示的数据量。\n\n    -   Magic Lenses：[Toolglass and Magic Lenses: The See-Through Interface](https://research.tableau.com/sites/default/files/1993-ToolglassMagicLenses.pdf)也提供了一种简化过滤过程的思路。用户可以在显示界面上移动 Magic lens，无论移动到何处，它覆盖的区域将显示对应的信息。改进：[sampling lens](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4015422)，采样透镜，用于显示覆盖区域的采样结果，见下图：\n\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-21/26279921.jpg)\n\n    -   解释性语言：[GUESS: a language and interface for graph exploration.](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.162.2367&rep=rep1&type=pdf)提出了用解释性语言来帮助探索性任务，而不是点击或者滚动。通过将解释语言与图形前端相结合，用户可以通过键入命令来过滤和浏览图结构\n\n#### 焦点+上下文\n\n-   基本介绍：焦点+上下文技术，常见特点是，它们都允许用户能够放大一个或者多个特定部分，而不会丢失在整个数据集中的位置。\n\n-   方法：\n\n    -   非失真方法：\n\n        -   老方法：用不同的分辨率，在不同区域分别显示。\n        -   [Powers of Ten Thousand: Navigating in Large Information Spaces](http://delivery.acm.org/10.1145/200000/192434/p15-lieberman.pdf?ip=222.205.1.205&id=192434&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E0E9E463C2E5391F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=987427103&CFTOKEN=36647399&__acm__=1505985135_af231860c505da6d00bb328a2bd776b0)将概览放在与焦点相同的空间中。通过使概览层和焦点层半透明地进行堆叠，用户可以同时在同一个显示中看到它们。\n\n    -   失真的方法：\n\n        -   通过结构的扭曲，实现类似鱼眼镜头的方法，[GRAPHICAL FISHEYE VIEWS OF GRAPHS](http://delivery.acm.org/10.1145/150000/142763/p83-sarkar.pdf?ip=222.205.1.205&id=142763&acc=ACTIVE%20SERVICE&key=BF85BBA5741FDC6E%2E0E9E463C2E5391F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=987427103&CFTOKEN=36647399&__acm__=1505985617_d22e036fc180776ba0269908571fc48e)\n\n            ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-21/89574906.jpg)\n\n        -   [The Generalized Detail-In-Context Problem](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=729558)：扩展和推广了鱼眼技术，这种拓展不仅仅提供了不同级别进行失真的手段（例如，替换掉带有图标的节点）还构建了对应的未失真图像的其他版本的图像（例如，为鱼眼扭曲提供附加的颜色描述）\n\n        -   [Topological fisheye views for visualizing largegraphs](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1432691)：提出了另一种大规模图的拓扑鱼眼的方法。他们的鱼眼显示了一个焦点，其周围具有完整的详细网络，离焦点越来越远的节点，分辨率越来越粗糙。\n\n-   缺点\n\n    -   鱼眼技术会扭曲整个图像，甚至是感兴趣的区域\n    -   有时候图形硬件不能很好地支持这种失真效果\n\n#### 动画\n\n动画最重要的功能就是帮助用户了解数据集，因为它隐含地将时间作为额外的维度来帮助挖掘数据。\n\n-   [Cone Trees: animated 3D visualizations of hierarchical information](http://www2.parc.com/istl/groups/uir/publications/items/UIR-1991-06-Robertson-CHI91-Cone.pdf)认为，动画可以帮助用户减少思考，因为它将部分认知任务转移到人类的视觉系统。与不同视图之间直接转换相比，动画转换可以更好地提供关于数据关系的线索，并帮助用户关联系统的两个状态。\n    -   过度使用动画，会使用户分心。[Animation: can it facilitate](https://www.tc.columbia.edu/faculty/bt2158/faculty-profile/files/_Morrison_Betrancourt_AnimationCanitfacilitate.pdf)的研究表示，只要静态的表示是直观清晰的，那么即便数据包含了时间维度，使用静态的布局也是一个不错的选择。\n-   动画会过度消耗时间，为了实现运动的平滑性，每秒 10 帧通常被认为是最小所需帧速率。\n\n## 图可视化的任务\n\n根据[Network Visualization by Semantic Substrates](https://www.cs.umd.edu/~ben/papers/Shneiderman2006Network.pdf)和[Graph Signatures for Visual Analytics](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1703362)定义了以下几种任务：\n\n-   对于整个图，统计节点数量\n-   对于给定节点，统计它的边数\n-   对于给定节点，统计它的邻接节点\n-   对于一个给定节点，找到可以在一定步数内找到的点或者某一种路径\n-   对于整个图，找到中间人节点\n-   对于整个图，找到强连接集合\n-   对于整个图，找到共享某些特定属性的所有节点链接\n","tags":["Visualization","Graph Visualization"]},{"title":"A Machine Learning Approach to Large Graph Visualization","url":"/blog/2017/09/03/2017-09-03 A Machine Learning Approach to Large Graph Visualization/","content":"\n-   论文原标题：What Would a Graph Look Like in This Layout? A Machine Learning Approach to Large Graph Visualization\n\n为了为图数据挑选一个合适的布局，论文提出了一种机器学习方法，基于用 graph kernel 计算的图拓扑相似度。这种方法可以显示图结构在不同的布局方法下的外观，并且可以估计这些图在布局下的美学度量。文章的贡献点是提出了一个可以用来设计 graph kernel 的框架。\n\n## 个人评述\n\n这篇文章简直是一篇集大成的文章，提出了一个重要的思想：用已有的数据集来生成新的可视化效果。竟然不是 2017VIS 的 best paper？通篇下来我竟然没有看出什么特别的缺点，要有的可能只是：\n\n1. 特征向量只和 DGK 进行了比较，可能不够丰富\n\n启发：\n\n1. 本文的所有结果基于一个假设：拓扑相似的两个图，布局结果也应该相似。那么我们是否可以引申？比如图的傅里叶变换结果是否可以用于计算拓扑；如果有探索交互数据，拓扑相似的图，其探索交互过程也应该相似，就可以用来做交互推荐。\n\n## 一、介绍\n\n**挑战**：给定图数据，特别是大规模的图数据，生成其节点链接布局耗时繁琐，开销巨大。\n\n**解决**：一种比较好的解决方案是通过一些**预测方法**（predivctive methods)，在机器学习里面，已经有很多预测方法用于预测图的属性，最知名的方法就是**图核**（graph kernel），可以用图核来支持一些核化机器学习（kernelized machine learning），比如 SVM。\n\n**贡献**：\n\n1. 一种快速、精准展示图在不同布局算法下的结果的方法；\n2. 一种快速、精准的可以评估图的布局结果美学指标（aesthetic metrics）的方法；\n3. 一个基于 graphlets 的设计图核的框架；\n4. 一次示范，以证明图核对大规模图可视化的有效性\n\n## 二、背景\n\n给定图数据$G$，如何得到某种图布局？\n\n如果已经有一个数据集${G_1, G_2, \\ldots, G_N}$，其中包含了大量的图数据和对应的图布局结果。\n\n假如可以从中找到一份图数据$G_k$，它的拓扑结构跟$G$最相似，那我们就可以用它的图布局来当做$G$的结果。\n\n![6月-26-2018 09-51-54](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-26-015231.gif)\n\n那么问题来了，如何度量两份图数据之间的拓扑相似度？\n\n### 拓扑相似度度量\n\n也叫做：_graph matching, graph comparison, network alignment_。\n\n-   **老方法**：_isomorphsim relation, graph edit distance, graph measures_。但复杂度太高，或者普适性不强。\n-   **新方法**：**图核（Graph kernel）**：可以支持 kernelized machine learning，对图之间进行成对比较，得到图和图之间的拓扑相似度。可以支持 SVM 等方法。\n\n> kernel，或者叫做 kernel function，是一个比较两个输入$\\chi$之间相似度的函数$\\chi \\times \\chi \\mapsto \\Bbb{R}$，经常被定义为特征空间$\\cal{H}$中两个向量的内积：\n>\n> $$\n> k(x, x') = \\langle\\phi(x), \\phi(x')\\rangle = \\langle\\bf{x}, \\bf{x'}\\rangle\n> $$\n>\n> 其中$\\phi$将输入$x$映射到高维特征空间：$x\\mapsto \\cal{H}$\n\n现有的图核：_walks, shortest pathes, subtress, cycles, graphlets_，前面几个都有较高的时间复杂度（$O(|V|^3)$或者更高），或者不适合无标记图。*graphlets kernel*被引入已解决上述的问题。\n\n-   _graphlets_：图元，指的是一系列异构的（_isomorphism_）导出（_indeced_）子图。\n\n> _isomophism_: two graphs $G = (V,E)$ and $G' = (V', E')$ are _isomorphic_ if there exists a bijection $f: V \\rightarrow V'$, called isomorphism, such that$ (v_i, v_j) \\in E \\Leftrightarrow (f(v_i),f(v_j)) \\in E' \\text{ for all }v_i,v_j \\in V​$.\n\n> _indeced_: Given a graph $G$, a graph $G' = (V',E')$ is a subgraph of $G$ if $V'\\subseteq V$ and $E' \\subseteq E$. A subgraph $G' = (V',E')$ is called an _induced_(or _vertex-induced_) subgraph of $G$ if $E' = \\{(v_i,v_j)|(v_i,v_j) \\in E \\text{ and }v_i, v_j \\in V'\\}$, that is, all edges in $E$, between two vertices $v_i,v_j \\in V'$, are also present in $E'$.\n\n下图是一个导出子图的示例：\n\n![image-20180625165552358](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/2018-06-25-085552.png)\n\n下图列举了所有 3 节点、4 节点、5 节点的 graphlets：\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-1/21892478.jpg)\n\n$\\phi$：如何对输入$x$，生成其高维特征空间$\\cal H$的特征向量$\\phi(x)$，以便进行内积，生成 graph kernel？这里，$x$也就是图$G$。\n通过计数图中相互独立的图元的个数，统计它们的频率分布，将图元的频率分布向量，得到图的特征向量。\n\n## 三、方法\n\n### 设计 graphlet kernel 的框架\n\n一个 graphlet kernel 的设计，需要以下步骤：\n\n1. 采样图元，统计个数（采样方法）\n2. 计算图元频率向量（频率计算方法）\n3. 求两个图元频率向量的内积（内积方法）\n\n#### 采样图元\n\n穷举所有图元开销过大，要穷举所有 k 节点图元，开销是$O(|V|^K)$。故而采用随机采样方法，主要有两种：\n\n-   随机节点采样（Random vertex sampling (RV)）：为了找一个 k 节点图元，通过随机找 k 个节点，用它们原有的边连接。但对于真实世界的网络，$|E|\\ll O(|V|^2)$，那么大部分随机采样的图元将会是不连通的。当只想采样连通图元的话，就需要很多轮迭代才能采到足够数量的图元，时间开销会很大。\n-   随机游走采样（Random walk sampling (RW)）：基于随机游走的采样方法，还没被用于设计 graphlet kernel，这种采样方法可以用来采集连通图元。\n\n#### 计算图元频率向量\n\n图元频率被定义为每种图元$g_{i}$的相对频率，以此构成的频率向量，作为图的一个特征向量。一共有两种方法用来计算频率向量：\n\n-   线性比例变换（linear scale, LIN）：也被叫做图元浓度（graphlet concentration），是每种图元在图中的百分比，一些工作用每种图元的加权数量$w_i$来定义它（文中并未指定权重$w_i$的定义）：\n\n    $$\n    x_i = \\frac{w_i}{\\sum w_i}\n    $$\n\n-   对数比例变换（Logarithmic scale, LOG）：类似于节点度分布，图元频率分布也经常服从幂律分布，这会导致缺少关键信息的图元会远高于那些信息丰富的图元，故而一些工作用了一个对数变换来解决这个问题，其中$w_b$是一个基础权重，来防止$log(0)$:\n\n    $$\n    x_i = log(\\frac{w_i+w_b}{\\sum (w_i+w_b)})\n    $$\n\n#### 定义内积\n\n文章引用了以下几个计算特征空间中的内积的 kernel 函数，内积结果即为两个图的相似度：\n\n-   余弦相似度（Cosine similarity，COS）：现有最多的 graphlet kernel 使用欧氏空间中的两个向量的点积后产生的点积产生的矩阵的归一化结果作为核函数，也就是两个向量的余弦相似度，也是两个向量的\n\n    $$\n    \\langle \\bf{x, x'} \\rangle = \\frac{\\bf{x \\cdot x'^T}}{||\\bf x|||| \\bf x' ||}\n    $$\n\n-   高斯径向基函数核（Gaussian radial basis function kernel, RBF）：经常被用在机器学习中，$\\sigma$是一个自由参数\n\n    $$\n    \\langle \\bf{x, x'} \\rangle = exp(-\\frac{||\\bf{x - x'}||^2}{2\\sigma ^ 2})\n    $$\n\n-   拉普拉斯核（Laplacian kernel，LAPLACIAN）：是 RBF 核的一种变种：\n    $$\n    \\langle \\bf{x, x'} \\rangle = exp(-\\frac{||\\bf{x - x'}||_1}{\\sigma})\n    $$\n\n### 预测图的布局结果（WGL）\n\n文章把这个方法称为**WGL**（What Would a Graph Look Like in This Layout? ）\n\n文章基于相似度，设计了一个类似*kNN*的最近邻算法，用来找出和输入图$G_{input}$拓扑结构最相似的 k 个图，并展示他们已存在的布局结果给用户。用户就可以通过观察这些拓扑相似的图来预测$G_{input}$的结果，步骤一共分三步：\n\n1. 计算准备好的已存在的图（每个图都预先计算好了布局结果）和输入图$G_{input}$的相似度\n2. 移除不满足约束条件的图（因为有些图，虽然它的特征向量和$G_{input}$很相似，但是因为节点过多或者过少，事实上应该不算做相似图，比如下图：[图元频率分布的四个例子](#元频率分布的四个例子)，文章中设置了一个约束条件，即相似图的节点数，不能多于$G_{input}$的 2 倍，或者少于$G_{input}$的 1/2）\n3. 选出$k$个最相似图\n\n###### 图元频率分布的四个例子\n\n下图中，x 轴表示了图元的种类，y 轴表示了图元的频率。图 a 和 c 的图元频率分布相似，且节点数量也相近，我们可以认为它们两者是拓扑相似图；但是，虽然图 b 和 d 的图元频率分布相似，但是因为节点数量相差过大，它们事实上不应该算作相似图。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-3/37262850.jpg)\n\n### 预测图的美学指标（EAM）\n\n文章把这个方法称为**EAM**(Estimating Aesthetic Metrics)\n\n美学指标是用来评判一幅图布局的良好状况的一系列指标，既然计算一个图的实际布局结果非常耗时，我们可以训练一个回归模型，用于预测某个新的输入图的美学指标，而不用实际计算布局结果，训练步骤一共分三步：\n\n1. 准备训练数据（一系列的图，以及它们在不同布局下的布局结果和相关的美学指标）\n2. 用 graph kernel 计算训练数据中的图和图之间的相似度\n3. 训练回归模型\n\n之后，我们就可以通过计算新的输入图和训练数据中的其他图的相似度，用已有的回归模型，估算输入图的美学指标。\n\n## 四、评估\n\n### 估算布局的美学指标\n\n#### 评估目的\n\n为了回答一下几个问题：\n\n1. 精确？在不计算实际布局的情况下，是否能够精确地估算布局的美学指标？\n2. 快速？能否快速的获得估算结果？\n3. 更强？由上述框架产生的 graph kernel 是否能够在计算时间和精度方面都优于最先进的 graph kernel？\n\n#### 实验设计\n\n##### 数据集\n\n1. 收集了包括并不限于社交网络、网络文档网络、几何网络的 3700 个图。在不失一般性的情况下，把具有多个连通部件的图拆成几个分离的图（一个连通部件对应一个图）。\n2. 之后剔除少于 100 个节点的图，因为这些图的计算会特别快，从而影响实验结果。\n3. 最后剩下 8263 个图，节点数范围从 100\\~一亿一千万，边数范围从 100\\~18 亿。因为某些图在计算布局的时间上花了 10 天以上或者内存跑完了，这些图就被抛弃了。\n\n##### kernel 选取\n\n一共十二个（2×2×3）核函数，是由[生成 graph kernel 的框架](#设计graphlet-kernel的框架)中提到的 2 种采样方法（随机选点 RV 和随机游走 RW）×2 种图元频率计算方法（线性 LIN 和对数 LOG）×3 种内积函数（COS, RBF 和 LAPLACIAN）组合而成。\n\n并且，选取了一个目前已有的最先进的 graph kernel，DGK（Deep Graph Kernel）进行比较。\n\n对于所有的 kernel，每幅图都采样了 10000 个有三个、四个、五个节点的图元（一共 49 种图元，其中 29 种是连通的）。因为计算开销的问题，这三种图元用的比较多，而 6 节点以上的图元一般比较稀有。并且 RW 采样只考虑连通图元，RV 采样考虑非连通和连通的图元。\n\n##### 布局方法选取\n\n这里只考虑二维平面，用直线绘制边的布局方法。\n\n因为时间问题，不可能计算所有的布局方法。所以根据(1)使用的广泛性，(2)是否有公开实现，(3)是否被证明优于同类其他方法，文章选取了 5 种布局方法类别中的 8 个具有代表性的布局方法。\n\n-   **力引导（Force-directed methods）**：电子模型中选取了 Fruchterman-Reingold (FR)，能量模型中选取了 Kamada-Kawai (KK)\n-   **基于降维的方法（Dimension reduction based method）**：选取了 High-Dimensional Embedder (HDE)\n-   **谱方法（Spectral method）**：选取了 Koren 的方法\n-   **多层方法（Multi-Level methods）**：选了 sfdp 和 FM3\n-   **基于聚类的方法（Clustering based methods）**：选了 Treemap based layout 和 the Gosper curve based layout\n\n##### 美学指标的选取\n\n文章选取了其中四个有标准形式，具有一般性的，切能够在合理时间内计算得到的美学指标：\n\n-   **Crosslessness ($m_c$)**：在很多研究中，边的交叉数量被作为一种最重要的审美标准，边交叉越少越好：\n\n    $$\n    m_c = \\begin{cases} 1 - \\frac{c}{c_{max}}, & \\text {if $c_{max} > 0$} \\\\ 1, & \\text{ otherwise} \\end{cases}\n    $$\n\n    其中，$c$是边的交叉数，$c_{max}$是边交叉数的近似上界，被定义为：\n\n    $$\n    c_{max} = \\frac{|E|(|E| - 1)}{2} - \\frac{1}{2}\\sum_{v \\in V}(deg(v)(deg(v) - 1))\n    $$\n\n-   **Minimum angle metric ($m_a$)**：被定义为点$v$上的边的最小夹角和理想的最小夹角的平均绝对离差：\n\n    $$\n    m_a = 1 = 1 - \\frac{1}{|V|}\\sum_{v \\in V}|\\frac{\\theta (v) - \\theta_{min}(v)}{\\theta(v)}|\n    $$\n\n    其中，理想最小夹角，定义为点上的所有边刚好平分 360°：\n\n    $$\n    \\theta(v) = \\frac{360°}{deg(v)}\n    $$\n\n-   **Edge length variation ($m_l$ )**：根据边长的变异系数计算得到：\n\n    $$\n    m_l = \\frac{l_{cv}}{\\sqrt{|E| - 1}},\\quad l_{cv} = \\frac{l_{\\sigma}}{l_{\\mu}} = \\sqrt{\\frac{\\sum_{e \\in E}(l_e - l_\\mu)^2}{|E| \\cdot  l_{\\mu}^2}}\n    $$\n\n    其中:\n\n    -   $l_{cv}$是边长的变异系数\n    -   $l_\\sigma$是边长的标准差\n    -   $l_\\mu$是边长的平均值\n\n-   **Shape-based metric($m_s$)**：可以用 mean Jaccard similarity(MJS)方法，比较某个图和标准图（一般认为标准图的结构良好，属于较美的图）的相似度，定义该图的$m_s$\n\n    $$\n    m_s = MJS(G_{input}, G_S), \\quad MJS(G_1, G_2) = \\frac{1}{|V|} \\sum_{v \\in V} \\frac{|N_1(v) \\bigcap N_2(v)|}{|N_1(v) \\bigcup N_2(v)|}\n    $$\n\n    其中，$G_1=(V, E_1)$和$G_2 = (V, E_2)$是所有节点都相同的两个图，$N_i(v)$是图$G_i$中$v$节点的相邻节点。采用[Gabriel graph](https://en.wikipedia.org/wiki/Gabriel_graph)作为标准图，用于比较。\n\n#### 如何评判估算结果是否精确\n\n为了评价在某种布局下，上述步骤**估算出来的美学指标**和这幅图在这种布局下**实际上的美学指标**的吻合情况（也就是估算精度），需要计算一下输入图$G_{input}$在经过布局方法布局后，真实的美学指标。之后，可以用以下两种方法比较**估算结果**和**实际测量结果**的吻合程度：\n\n-   **均方根误差（Root-Mean-Square Error (RMSE)）**，结果越小越好\n\n    $$\n    RMSE(\\cal Y, \\tilde{\\cal Y}) = \\sqrt{\\frac{1}{n}\\sum_{i}(y_i - \\tilde{y_i})^2}\n    $$\n\n    其中：\n\n    -   $\\cal Y = \\{y_1,…,y_n\\}$是经过实际布局后，测量出来的真实结果；\n    -   $\\tilde{\\cal Y} = \\{\\tilde{y_1},…,\\tilde{y_n}\\}$是回归模型的估算结果。\n\n-   **测定系数（coefficient of determination (R ) ）**：结果越小越好\n\n    $$\n    R^2(\\cal Y, \\tilde{\\cal Y}) = 1 - \\sum_{i}(y_i - \\tilde{y_i})^2 / \\sum_{i}(y_i - y_\\mu)^2\n    $$\n\n    其中$y_\\mu$是测量结果$y_i$的平均值\n\n#### 实验结果\n\n##### 估算精度方面\n\n###### 部分精度评估结果\n\n上图展示了四个不同的 kernel（RW-LOG-LAPLACIAN, RW-LOG-RBF, RV-LIN-COS, DGK）在八种不同的布局方法（$sfdp, FM^3, FR, KK, Spectral, HDE, Treemap, Gosper$）的四种不同美学指标（$m_c, m_a, m_l, m_s$）的两种不同估算精度度量（$RMES, R^2$）的结果。加粗部分是最佳结果。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-3/78771086.jpg)\n\n-   从上图可以看到，除了在$FM^3$布局下的$m_c$指标以外，RW-LOG-LAPLACIAN kernel 的表现都是最佳。而 RW-LOG-RBF kernel 则在$FM^3$布局下的$m_c$指标表现最佳。DGK 排名为第十二名，说明框架产生的 kernel 大部分都优于这个对照组，也就回答了第三个问题。\n-   总体而言，RW 采样方法得到的结果精确度要高于 RV 采样方法，LOG 变换比 LIN 变化的精度更高，用 LAPLACIAN 的核也比其他两者精度更高。\n\n##### 计算时间方面\n\n因为有一些算法是并行计算的，而有一些不是。故而，这里只汇报了 CPU 时间。Estimation time 只考虑[预测图的美学指标](#3-2预测图的美学指标（EAM）)中提到的计算时间（不考虑训练模型的时间）。\n\n结果显示，精度最高的核 RW-LOG-LAPLACIAN kernel 也跑的最快，平均每幅图 0.14093 秒（标准差为 1.9559）的时间进行估算。\n\n时间开销最大的是在采样图元的时候。\n\n-   RW 采样计算速度最快，每幅图平均 0.14089 秒 (标准差为 1.9559)。\n-   DGK 的图元采样速度比 RW 要慢，每幅图平均 3.38 秒（标准差为 7.88）。\n-   RV 采样计算速度最慢，每幅图平均 6.81 秒（标准差为 7.04）。\n\n###### 计算时间和图规模之间的关系\n\n下图显示了拥有最高精度的 RW-LOG-LAPLACIAN kernel，实际计算和估算八种布局结果以及四种美学指标的时间。左图展示了八种布局的**平均实际布局时间以及估算时间（y）**和图**节点数量(x)**之间的关系，右图则展现了不同美学指标的**平均计算时间以及估算时间(y)**与图**节点数量（x）**之间的关系。随着图的规模变大，实际布局计算时间以及美学指标的计算时间和估算时间之间也就拉开了距离。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-8-31/39145853.jpg)\n\n#### 讨论\n\n-   RW 采样方法比 RV 采样方法精度高，因为 RW 只采样连通图元，故而我们推测，连通图元对展现图的结构信息更重要，故而估算结果的精度也更高。\n-   事实上，在用 RV 采样的过程中，每个图采样 10000 个图元，发现只有 1.913%是连通图元，而有 35.77%的图没有采样到连通图元，即便它们这些图本身都是连通的，这就使得这些图本身就很难用于比较。\n-   使用 LOG 变换的核，比使用 LIN 变换的核，平均而言有着更高的估算精度，可能是因为图元的分布也经常呈现出幂率分布。\n-   因为在估算过程中，不用再计算实际的布局结果，所以估算布局结果和美学指标的速度会很快。\n-   发现除了 DGK 以外，其他核矩阵的计算时间都很短，而且相差不大，平均 5.99 秒，标准差 3.26。而 DGK 因为要计算语言模型 language modeling，需要平均 182.96 秒。\n\n### 预测图的布局结果\n\n#### 评估目的\n\n此次评估是为了验证文章提到的[WGL 方法](#3-1预测图的布局结果（WGL）)评价出来的图和图的相似情况是否和人类心理上认为的相似情况接近。\n\n#### 实验设计\n\n此次试验是一个排序实验，是为了比较[WGL 方法](#3-1预测图的布局结果（WGL）)得到的训练数据中的图和目标图的拓扑相似度的排序结果（$r_T$）和人类主观评价出来的相似度排序结果（$r_P$）是否匹配。\n\n##### 任务\n\n如图：[用户调研中的其中一个任务示例](#用户调研中的其中一个任务示例)所示，参与者都会面对一个目标图（Target）和九个选项（Choices），他们需要从这些选项中，挑选出和目标最像的三个图，并按照相似度进行排序。\n\n为了避免偏见，实验并没有定义什么叫做“相似”，并且也没有告诉用户，这些图都是用同一种布局方法进行布局的。\n\n实验采用了九个图数据，八种布局方法进行组合，一共是 72 个任务。\n\n###### 用户调研中的其中一个任务示例\n\n每个任务中，参与者都会面对一个目标图（Target）和九个选项（Choices），他们需要从这些选项中，挑选出和目标最像的三个图，并按照相似度进行排序。a, b, c 三个图的中心节点被展示在右边。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-8-31/55830450.jpg)\n\n##### 图的选取\n\n-   目标图（Target）：一共选取了 9 个目标图，选择过程如下：\n    1. 将已有的 8000+图，利用谱聚类（spectral clustering）的方法分成 9 类\n    2. 对于每一类，选出相互之间拓扑相似度最高的十个图，作为这一类的代表图\n    3. 从这十个代表图中随机挑选一个作为目标图（Target)\n-   选项图（Choice）：每幅目标图，都要挑选九幅选项图：\n    1. 利用每幅图和目标图之间的相似度，利用[Jenks natuarak breaks 方法](https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)（一种一维的 K 均值分类方法）将所有图分成 9 类\n    2. 从与目标图最相似的聚类中，选出和目标图相似度最高的图，作为其中一张选项图\n    3. 剩余八类中，每一类都选出相互之间拓扑相似度最高的十个图，再从这十张图中随机挑选一张，作为剩余八张选项图\n    4. 当然在挑选过程中，需要过滤掉那些节点数大于目标图两倍，或者小于目标图一半的图\n\n#### 实验结果\n\n###### 用户调研的总结\n\n蓝色表示用户挑选其作为最相似图的比率，绿色表示用户挑选其作为第二相似图的比率，浅绿色表示用户挑选其作为第三相似图的概率。\n\n左图(a)显示了用户主观的相似图判断和算法结果的匹配程度\n\n中图(b)显示了，在不同布局下，算法选出的最相似图（$r_T = 1$）和用户的选择的匹配程度\n\n右图(c)显示了，对于不同的目标图，算法选出的最相似图（$r_T = 1$）和用户的选择的匹配程度\n\n![](/Users/jackie/Repository/blog/papers/source/_posts/assets/3869351.jpg)\n\n-   如图：[用户调研的总结](#用户调研的总结)，发现有 80.46%的情况，参与者认为最相似的选项图（$r_P=1$）和系统选出来的最相似的图（$r_T=1$）刚好吻合（图 a 最左边的蓝色长条）；90.27%的情况下，参与者认为的最相似（$r_P=1$）和第二相似（$r_P=2$）的选项图和系统选出的最相似图（$r_T=1$）吻合；而 93.8%的情况下，参与者选出的第 1、2、3 相似的图（$r_P={1,2,3}$）和系统选出的最相似图（$r_T=1$）吻合。\n-   除了 treemap 布局和 spectral 布局以外，有 78.52%\\~93.33%的情况下，参与者选出来的最相似图和算法得到的最相似图一致，有 94.44%\\~99.26%的情况下，参与者选出来的最相似的三幅图和算法得到的最相似图吻合。\n-   目标图中，除了$G_{2331}$和$G_{3833}$，有 79.58%\\~98.33%的情况下，参与者选出来的最相似图和算法得到的最相似图一致，有 92.08%\\~99.99%的情况下，参与者选出来的最相似的三幅图和算法得到的最相似图吻合。\n\n#### 讨论\n\n-   为什么 Spectral 和 Treemap 布局比其他的布局方法结果要差？\n    -   spectral：参与者根据线的形状、节点的个数来判断相似程度，我们发现，谱布局，经常会有很多节点重叠，故而会让参与者判断不准\n    -   treemap：因为它的几何限制，经常产生相似的图形，参与者几乎都提到，“这些图怎么长的都一样？”，他们经常会根据边的密度，整体边的走向来判断相似程度，故而判断不准\n-   为什么 G2331 情况比较糟糕？[图 5](#图5：用户调研中的其中一个任务示例)所示情况，参与者在 b 和 c 图中徘徊不定：\n    -   参与者选择 c 的原因：密度、形状、边的数量\n    -   参与者选择 b 的原因：中心节点的数量\n    -   系统选择 c 的原因：大体上结构和目标相似\n\n## 五、讨论\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-9-3/42643278.jpg)\n\n上图是 8263 幅图用 RW-LOG-LAPLACIAN kernel 计算得到的相似度的一个投影，这一对对的图是 9 对拓扑结构最相似但却非同构的图。\n\n这篇论文，为我们进行大图可视化提供了一个新的思路，为了应对大图中高的计算代价，可以通过机器学习的方法，用预计算的代价来代替实时计算。这样就甚至能把大图的某些计算效率提高到实时的级别。\n","tags":["Visualization","Machine Learning","Graph Visualization","Large Graph"]},{"title":"杂谈：Python入门学习笔记基础","url":"/blog/2017/08/21/2017-08-21 Python入门学习笔记/","content":"\n# Python 学习笔记基础\n\n## 基础\n\n1. 语法\n\n- `#`开头，注释\n- 缩进的语句视为代码块\n- 大小写敏感\n\n2. 数据类型和变量\n\n   - `True`和`False`首字母大写\n   - `and`、`or`和`not`\n   - 空值：`None`\n\n3. 字符串格式化`%`\n\n   - `%d`整数\n\n   - `%f`浮点数\n\n   - `%s`字符串\n\n   - `%x`十六进制整数\n\n   - 补位\n\n     ```python\n     >>> '%2d-%02d' % (3, 1)\n     ' 3-01'\n     >>> '%.2f' % 3.1415926\n     '3.14'\n     ```\n\n4. 数组：`list`和`tuple`\n\n   - `list`数组\n     - `len(list)`得到长度\n     - `list[-2]`获得倒数第二个元素\n     - `list.append(ele)`往 list 中追加元素到末尾\n     - `list.insert(1, ele)`，把元素插入到指定的位置，比如索引号为`1`的位置\n     - `list.pop()`，删除 list 末尾的元素，用`pop()`方法\n     - `list.pop(i)`删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置\n     - 元素的数据类型也可以不同，`L = ['Apple', 123, True]`\n   - `tuple`数组：`classmates = ('Michael', 'Bob', 'Tracy')`\n     - `tuple`一旦初始化就不能修改，代码更安全\n\n5. 条件判断和循环\n\n   - `if` `elif` `else`\n\n   - `for in`\n\n   - `while`\n\n   - `range()`函数\n\n     ```python\n     >>> range(1,5) #代表从1到5(不包含5)\n     [1, 2, 3, 4]\n     >>> range(1,5,2) #代表从1到5，间隔2(不包含5)\n     [1, 3]\n     >>> range(5) #代表从0到5(不包含5)\n     [0, 1, 2, 3, 4]\n     ```\n\n   - `raw_inpit(str)`读取的内容永远以字符串的形式返回\n\n6. `dict`和`set`\n\n   - `dict`就是`map`，用 key-value 的形式存储。\n\n     ```python\n     d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n     ```\n\n   - 根据`key`获得`value`\n\n     - `[]`：一旦`key`不存在就会报错\n     - `get()`函数：如果 key 不存在，可以返回 None，或者自己指定的 value（作为第二个参数传入）\n\n   - `set`是一组 key 的集合，但不存储 value，key 不能重复。\n\n     - 需要 list 作为输入\n     - `add(key)`函数用来往里面添加元素，自动忽略重复\n     - `remove(key)`函数用来删除元素\n     - `&`操作用来做交集\n     - `|`操作用来做并集\n\n## 函数\n\n1. Python 内置数据类型转换函数：如`int()`\n\n2. Python 可以给函数赋别名，如：`a = abs`\n\n3. 定义函数，`def`：\n\n   ```python\n   def my_abs(x):\n   \tif x >= 0:\n   \t\treturn x\n   \telse:\n   \t\treturn -x\n   ```\n\n   如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。`return None`可以简写为`return`。\n\n4. 空函数，`pass`：\n\n   ```python\n   def nop():\n   \tpass\n   ```\n\n5. 类型检查，`isinstance`：\n\n   ```python\n   def my_abs(x):\n       if not isinstance(x, (int, float)):\n           raise TypeError('bad operand type')\n       if x >= 0:\n           return x\n       else:\n           return -x\n   ```\n\n6. Python 函数可以返回多个值：\n\n   ```python\n   import math\n\n   def move(x, y, step, angle=0):\n       nx = x + step * math.cos(angle)\n       ny = y - step * math.sin(angle)\n       return nx, ny\n   ```\n\n   ```python\n   >>> x, y = move(100, 100, 60, math.pi / 6)\n   >>> print x, y\n   151.961524227 70.0\n   ```\n\n   事实上，它并没有返回多个值，而是返回了一个 tuple\n\n7. Python 具有默认参数：\n\n   ```python\n   def power(x, n=2):\n       s = 1\n       while n > 0:\n           n = n - 1\n           s = s * x\n       return s\n   ```\n\n   **默认参数必须指向不变对象**，不然默认参数就会不断变化，例子：\n\n   ```python\n   def add_end(L=[]):\n       L.append('END')\n       return L\n   ```\n\n   ```python\n   >>> add_end()\n   ['END']\n   >>> add_end()\n   ['END', 'END']\n   >>> add_end()\n   ['END', 'END', 'END']\n   ```\n\n8. 可变参数，`*`：\n\n   ```python\n   def calc(*numbers):\n       sum = 0\n       for n in numbers:\n           sum = sum + n * n\n       return sum\n   ```\n\n   ```python\n   >>> calc(1, 2)\n   5\n   >>> calc()\n   0\n   ```\n\n   在函数内部，参数`numbers`接收到的是一个 tuple。\n\n   如果已经有一个 list 或者 tuple，可以这么写：\n\n   ```python\n   >>> nums = [1, 2, 3]\n   >>> calc(*nums)\n   14\n   ```\n\n9. 关键字参数：`**`，会把多与参数自动组装成一个`dict`：\n\n   ```python\n   def person(name, age, **kw):\n       print 'name:', name, 'age:', age, 'other:', kw\n   ```\n\n   ```python\n   >>> person('Michael', 30)\n   name: Michael age: 30 other: {}\n   >>> person('Bob', 35, city='Beijing')\n   name: Bob age: 35 other: {'city': 'Beijing'}\n   >>> person('Adam', 45, gender='M', job='Engineer')\n   name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n   ```\n\n   ```python\n   >>> kw = {'city': 'Beijing', 'job': 'Engineer'}\n   >>> person('Jack', 24, **kw)\n   name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n   ```\n\n10. 参数定义的顺序必须是：**必选参数、默认参数、可变参数和关键字参数**\n\n## 高级特性\n\n### 切片（Slice ）\n\n```python\n>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n>>> L[0:3]\n['Michael', 'Sarah', 'Tracy']\n```\n\n- `L[0:3]`表示，从索引 0 开始取，直到索引 3 为止，但不包括索引 3。即索引 0，1，2，正好是 3 个元素。\n- 如果第一个索引是 0，还可以省略。\n- `L[-1]`取倒数第一个元素，也支持倒数切片：`L(-2:)`\n- 只写`[:]`就可以原样复制一个 list\n- `L[:10:2]`表示前十个元素，每两个取一个：`[0,2,4,6,8]`\n- tuple 也可以用切片，操作结果也是 tuple\n- 字符串也支持切片\n\n### 迭代（Iteration）\n\n- 只要是可迭代对象（list，tuple，dict，set，字符串）都可以用`for...in...`迭代\n\n- 默认情况下，dict 迭代的是 key。\n\n  - 如果要迭代 value，可以用`for value in d.itervalues()`\n  - 如果要同时迭代 key 和 value，可以用`for k, v in d.iteritems()`。\n\n- 判断一个对象是否是可迭代对象：\n\n  ```python\n  from collections import Iterable\n  isinstance('abc', Iterable) # str是否可迭代 True\n  isinstance([1,2,3], Iterable) # list是否可迭代 True\n  isinstance(123, Iterable) # 整数是否可迭代 False\n  ```\n\n- 拥有下标的循环：\n\n  ```python\n  for i, value in enumerate(['A', 'B', 'C']):\n  \tprint i, value\n  ```\n\n- `for`循环同时引用两个变量：\n\n  ```python\n  for x, y in [(1, 1), (2, 4), (3, 9)]:\n  \tprint x, y\n  ```\n\n### 列表生成式（List Comprehensions）\n\n- `[x * x for x in range(1, 11)]`→`[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]`\n- 加上判断：`[x * x for x in range(1, 11) if x % 2 == 0]`→`[4, 16, 36, 64, 100]`\n- 两层循环（可以用来生成全排列）：`[m + n for m in 'ABC' for n in 'XYZ']`→`['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']`\n\n### 生成器（Generator）\n\n生成器里面装了用来生成一个 list 的算法，这样就不必创建完整的 list，从而节省大量的空间，一边循环，一边计算。\n\n```python\ng = (x * x for x in range(3))\ng.next() # 0\ng.next() # 1\ng.next() # 4\ng.next() # StopIteration\n```\n\n也可以用`for`循环：\n\n```python\ng = (x * x for x in range(10))\nfor n in g:\n\tprint n\n```\n\n- 定义 generator 的另一种方法，`yield`：\n\n  ```python\n  # print Fibonacci list\n  def fib(max):\n      n, a, b = 0, 0, 1\n      while n < max:\n          print b\n          a, b = b, a + b\n          n = n + 1\n  ```\n\n  改写成 generator：\n\n  ```python\n  # Fibonacci generator\n  def fib(max):\n      n, a, b = 0, 0, 1\n      while n < max:\n          yield b\n          a, b = b, a + b\n          n = n + 1\n  ```\n\n  ```python\n  >>> fib(6)\n  <generator object fib at 0x104feaaa0>\n  ```\n\n- generator 的执行顺序：\n\n  > 变成 generator 的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。\n\n  ```python\n  >>> def odd():\n  ...     print 'step 1'\n  ...     yield 1\n  ...     print 'step 2'\n  ...     yield 3\n  ...     print 'step 3'\n  ...     yield 5\n  ...\n  >>> o = odd()\n  >>> o.next()\n  step 1\n  1\n  >>> o.next()\n  step 2\n  3\n  >>> o.next()\n  step 3\n  5\n  >>> o.next()\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n  StopIteration\n  ```\n\n## 函数式编程（Functional Programming）\n\nPython 对函数式编程提供部分支持。由于 Python 允许使用变量，因此，Python 不是纯函数式编程语言。\n\n### 高阶函数\n\n- `map`第一个参数是函数，第二个参数是可迭代对象，返回一个 list\n- `reduce`第一个参数是函数，第二个参数是可迭代对象，函数的两个参数（result, item）\n- `filter`\n- `sorted`第一个参数是可迭代对象，第二个参数是比较函数（有默认值）\n\n### 返回函数\n\n- Python 也有闭包的概念\n\n### 匿名函数（lambda）\n\n`lambda x: x * x`等同于：\n\n```python\ndef f(x):\n    return x * x\n```\n\n### 装饰器（Decorator）\n\n`@`\n\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        return func(*args, **kw)\n    return wrapper\n```\n\n```python\n@log\ndef now():\n    print '2017-08-14'\n```\n\n相当于执行了：\n\n```python\nnow = log(now)\n```\n\n但此时，`now.__name__`已经被替换成了`wrapper`，所以完整的写法：\n\n```python\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        return func(*args, **kw)\n    return wrapper\n```\n\n### 偏函数（Partial function）\n\n可以固定某个参数的默认值，比如下方的例子，固定了`int`函数的`base`参数。\n\n```python\nint2 = functools.partial(int, base=2)\n```\n\n## 模块\n\n[Python 所有内置函数](https://docs.python.org/2/library/functions.html)\n\n模块：一个文件就是一个模块\n\n包：就是不同的文件夹，但每个包目录下面都要有一个`__init__.py`的文件，否则就是一个普通目录而不是一个包。`__init.__.py`可以是空文件，也可以有代码，因为`__init__.py`本身就是一个模块，它的模块名就是它的父目录。比如如下的文件结构：\n\n![](https://www.liaoxuefeng.com/files/attachments/00138836605526535c9bebcbf414c3dae2430c50bbeef29000/0)\n\n文件`www.py`的模块名就是`mycompany.web.www`，两个文件`utils.py`的模块名分别是`mycompany.utils`和`mycompany.web.utils`。\n\n### 引入模块\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n' a test module '\n\n__author__ = 'Michael Liao'\n\nimport sys\n\ndef test():\n    args = sys.argv\n    if len(args)==1:\n        print 'Hello, world!'\n    elif len(args)==2:\n        print 'Hello, %s!' % args[1]\n    else:\n        print 'Too many arguments!'\n\nif __name__=='__main__':\n    test()\n```\n\n第 1 行和第 2 行是标准注释，第 1 行注释可以让这个`hello.py`文件直接在 Unix/Linux/Mac 上运行，第 2 行注释表示.py 文件本身使用标准 UTF-8 编码；\n\n第 4 行是一个字符串，表示模块的文档注释，任何模块代码的**第一个字符串**都被视为模块的文档注释；\n\n第 6 行使用`__author__`变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；\n\n`sys.argv`用 list 存储了命令行的所有参数。`python hello.py`对应`['hello.py']`，`python hello.py Michael`对应 `['hello.py', 'Michael]`。\n\n最后两行：当用命令行运行`hello`模块时，Python 解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该`hello`模块时，则不会。\n\n- 别名：`cStringIO`是 C 写的，速度更快，这样就可以优先导入`cStringIO`。如果有些平台不提供`cStringIO`，还可以降级使用`StringIO`。\n\n  ```python\n  try:\n      import cStringIO as StringIO\n  except ImportError: # 导入失败会捕获到ImportError\n      import StringIO\n  ```\n\n  还有类似`simplejson`这样的库，在 Python 2.6 之前是独立的第三方库，从 2.6 开始内置\n\n  ```python\n  try:\n      import json # python >= 2.6\n  except ImportError:\n      import simplejson as json # python <= 2.5\n  ```\n\n- 作用域：\n\n  前缀`_`表示私有函数，**不应该**被外部引用。\n\n### 安装第三方模块\n\n`pip`\n\n`pip install`是全局安装\n\n默认情况下，Python 解释器会搜索当前目录、所有已安装的内置模块和第三方模块。搜索路径存放在`sys`模块的`path`变量中，可以添加要搜索的目录：\n\n```python\nimport sys\nsys.path.append('/Users/michael/my_py_scripts')\n```\n\n### `__future__`模块\n\nPython 提供了`__future__`模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性，比如：\n\n```python\n# still running on Python 2.7\n\nfrom __future__ import unicode_literals\n\nprint '\\'xxx\\' is unicode?', isinstance('xxx', unicode)\nprint 'u\\'xxx\\' is unicode?', isinstance(u'xxx', unicode)\nprint '\\'xxx\\' is str?', isinstance('xxx', str)\nprint 'b\\'xxx\\' is str?', isinstance(b'xxx', str)\n```\n\n```python\nfrom __future__ import division\n\nprint '10 / 3 =', 10 / 3\nprint '10.0 / 3 =', 10.0 / 3\nprint '10 // 3 =', 10 // 3\n```\n\n## 面向对象编程\n\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def print_score(self):\n        print '%s: %s' % (self.name, self.score)\n\nbart = Student('Bart Simpson', 59)\nlisa = Student('Lisa Simpson', 87)\nbart.print_score() # Bart Simpson: 59\nlisa.print_score() # Lisa Simpson: 87\n```\n\n### 类和实例\n\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n```\n\n`class`后面紧接着是类名，即`Student`，类名通常是大写开头的单词，紧接着是`(object)`，表示该类是从哪个类继承下来的。\n\n`__init__`函数是构造函数。\n\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量`self`，并且，调用时，不用传递该参数。\n\n### 访问限制\n\n- 在 Python 中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。\n- 变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用`__name__`、`__score__`这样的变量名。\n- 以一个下划线开头的实例变量名，比如`_name`，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。\n- 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为 Python 解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量\n\n### 继承与多态\n\nOOP 的特性，不作多余解释。\n\n### 获取对象信息\n\n- `type()`\n\n  ```python\n  >>> type(123)\n  <type 'int'>\n  >>> type('str')\n  <type 'str'>\n  >>> type(None)\n  <type 'NoneType'>\n  >>> type(abs)\n  <type 'builtin_function_or_method'>\n  >>> type(a)\n  <class '__main__.Animal'>\n  ```\n\n  `types`模块`types.StringType`、`types.UnicodeType`、`types.ListType`、`types.TypeType`(所有类型本身的类型就是`TypeType`)\n\n- `isinstance()`\n\n  ```python\n  # object -> Animal -> Dog -> Husky\n  a = Animal()\n  d = Dog()\n  h = Husky()\n\n  isinstance(h, Husky)\t# True\n  isinstance(h, Dog)\t\t# True\n  isinstance(h, Animal)\t# True\n  ```\n\n  判断一个变量是否是某些类型中的一种\n\n  ```python\n  isinstance('a', (str, unicode))\t\t# True\n  isinstance(u'a', (str, unicode))\t# True\n  ```\n\n- `dir()`：获得对象的所有属性和方法，返回一个 list\n\n  类似`__xxx__`的属性和方法在 Python 中都是有特殊用途的。比如`__len__`方法返回长度，实际上，在`len()`函数内部，它自动去调用该对象的`__len__()`方法：\n\n  ```python\n  class MyObject(object):\n  \tdef __len__(self):\n  \t\treturn 100\n\n  obj = MyObject()\n  len(obj) # 100\n  ```\n\n- `hasattr`、`setattr`、`getattr`\n\n  ```python\n  hasattr(obj, 'x')\t\t# 有属性'x'吗？\n  setattr(obj, 'y', 19)\t# 设置一个属性'y'\n  getattr(obj, 'z')\t\t# 获取属性'z'\n  ```\n\n  ​\n\n### `__slots__`\n\n- 给 class 绑定新的方法，`MethodType`：\n\n  ```python\n  def set_score(self, score):\n  \tself.score = score\n\n  Student.set_score = MethodType(set_score, None, Student)\n  ```\n\n- 限制类能添加的属性，`__slots`：\n\n  ```python\n  class Student(object):\n  \t__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n  ```\n\n  对子类不起作用。\n\n### `@property`\n\n```python\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n\n```python\ns = Student()\ns.score = 60\t# OK，实际转化为s.set_score(60)\ns.score\t\t\t# OK，实际转化为s.get_score() 60\ns.score = 9999\n# Traceback (most recent call last):\n# ValueError: score must between 0 ~ 100!\n```\n\n不定义 setter 的话，就是一个只读属性\n\n### 多重继承\n\n```python\nclass Dog(Mammal, Runnable):\n    pass\n\nclass Bat(Mammal, Flyable):\n    pass\n```\n\n### 定制类\n\n- `__str__()`方法用于自动类型转换\n\n  ```python\n  class Student(object):\n  \tdef __init__(self, name):\n          self.name = name\n  \tdef __str__(self):\n          return 'Student object (name: %s)' % self.name\n  ```\n\n- `__iter__()`，配合`next()`方法，可以对类进行`for...in`操作。\n\n  ```python\n  class Fib(object):\n      def __init__(self):\n          self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n      def __iter__(self):\n          return self # 实例本身就是迭代对象，故返回自己\n\n      def next(self):\n          self.a, self.b = self.b, self.a + self.b # 计算下一个值\n          if self.a > 100000: # 退出循环的条件\n              raise StopIteration();\n          return self.a # 返回下一个值\n  ```\n\n  ```python\n  for n in Fib():\n      print n\n  ```\n\n- `__getitem__()`：可以类似 list 那样，用方括号`[]`取出对应的元素。\n\n  ```python\n  class Fib(object):\n      def __getitem__(self, n):\n          a, b = 1, 1\n          for x in range(n):\n              a, b = b, a + b\n          return a\n  ```\n\n  ```python\n  f = Fib()\n  f[0] \t# 1\n  f[1] \t# 1\n  f[10] \t# 89\n  f[:10]\t# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  f[:10:2]\t# 未对step做处理，[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  ```\n\n  `__getitem__()`也没有对负数进行处理。\n\n  `__getitem__()`也可以将对象处理成一个 dict：\n\n  ```python\n  class Test(object):\n      def __init__(self, a, b):\n          self.a = a\n          self.b = b\n\n      def __getitem__(self, n):\n          if n == 'a':\n              return self.a\n          else:\n              return self.b\n  ```\n\n  ```python\n  f = Test('aa', 'bb')\n  print f['a'] # 'aa'\n  ```\n\n  与之对应的是`__setitem__()`方法，把对象视作 list 或 dict 来对集合赋值。\n\n  还有一个`__delitem__()`方法，用于删除某个元素。\n\n- `__getattr__()`，用于处理对象没有的属性或方法：\n\n  ```python\n  class Test(object):\n      def __init__(self, name):\n          self.name = name\n\n      def __getattr__(self, attr):\n          print 'Test doesn\\'t have attribute: %s' % attr\n  ```\n\n  ```python\n  test = Test('aa')\n  test.age\t# Test doesn't have attribute: age\n  ```\n\n  同样也可以返回方法。\n\n  只有在没有找到属性的情况下，才调用`__getattr__`。\n\n- `__call__()`使得实例本身可以称为一个函数。\n\n  ```python\n  class Student(object):\n      def __init__(self, name):\n          self.name = name\n\n      def __call__(self, age):\n          self.age = age\n          print('My name is %s and my age is %s' % self.name, age)\n  ```\n\n  ```python\n  student = Student('Jackie')\n  student(25) # My name is Jackie and my age is 25\n  ```\n\n  可以用`callbale()`来判断一个对象是否能被调用。\n\n### 元类\n\n- `type()`不仅可以用来查看某个对象的类型，也可以用来创建新的类：\n\n  ```python\n  def fn(self, name='world'): # 先定义函数\n  \tprint('Hello, %s.' % name)\n\n  Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class\n  h = Hello()\n  h.hello()\t# Hello, world.\n  print(type(Hello))\t# <type 'type'>\n  print(type(h))\t# <class '__main__.Hello'>\n  ```\n\n  传入三个参数：\n\n  - 类名\n  - 继承的父类的 tuple\n  - 属性和方法的 dict\n\n  通过`type()`函数创建的类和直接写 class 是完全一样的\n\n- `metaclass`元类，暂时不学\n\n## 错误、调试和测试\n\n### 错误处理\n\n#### `try...except...finally...`\n\n```python\ntry:\n    print 'try...'\n    r = 10 / int('a')\n    print 'result:', r\nexcept ValueError, e:\n    print 'ValueError:', e\nexcept ZeroDivisionError, e: # 可以写多条except\n    print 'ZeroDivisionError:', e\nelse: # 未出错就会执行\n    print 'no error!'\nfinally:\n    print 'finally...' # 无论是否出错，都会执行\nprint 'END'\n```\n\n`except`还会捕获异常的子类，所有的错误类型都继承自`BaseException`，所以在使用`except`时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。\n\n[Exception hierarchy 异常继承关系](https://docs.python.org/2/library/exceptions.html#exception-hierarchy):\n\n```\nBaseException\n +-- SystemExit\n +-- KeyboardInterrupt\n +-- GeneratorExit\n +-- Exception\n      +-- StopIteration\n      +-- StandardError\n      |    +-- BufferError\n      |    +-- ArithmeticError\n      |    |    +-- FloatingPointError\n      |    |    +-- OverflowError\n      |    |    +-- ZeroDivisionError\n      |    +-- AssertionError\n      |    +-- AttributeError\n      |    +-- EnvironmentError\n      |    |    +-- IOError\n      |    |    +-- OSError\n      |    |         +-- WindowsError (Windows)\n      |    |         +-- VMSError (VMS)\n      |    +-- EOFError\n      |    +-- ImportError\n      |    +-- LookupError\n      |    |    +-- IndexError\n      |    |    +-- KeyError\n      |    +-- MemoryError\n      |    +-- NameError\n      |    |    +-- UnboundLocalError\n      |    +-- ReferenceError\n      |    +-- RuntimeError\n      |    |    +-- NotImplementedError\n      |    +-- SyntaxError\n      |    |    +-- IndentationError\n      |    |         +-- TabError\n      |    +-- SystemError\n      |    +-- TypeError\n      |    +-- ValueError\n      |         +-- UnicodeError\n      |              +-- UnicodeDecodeError\n      |              +-- UnicodeEncodeError\n      |              +-- UnicodeTranslateError\n      +-- Warning\n           +-- DeprecationWarning\n           +-- PendingDeprecationWarning\n           +-- RuntimeWarning\n           +-- SyntaxWarning\n           +-- UserWarning\n           +-- FutureWarning\n\t   +-- ImportWarning\n\t   +-- UnicodeWarning\n\t   +-- BytesWarning\n```\n\n#### `logging`\n\nPython 内置的`logging`模块可以非常容易地记录错误信息。\n\n```python\n# err.py\nimport logging\n\ndef foo(s):\n    return 10 / int(s)\n\ndef bar(s):\n    return foo(s) * 2\n\ndef main():\n    try:\n        bar('0')\n    except StandardError, e:\n        logging.exception(e)\n\nmain()\nprint 'END'\n```\n\n```bash\n$ python err.py\nERROR:root:integer division or modulo by zero\nTraceback (most recent call last):\n  File \"err.py\", line 12, in main\n    bar('0')\n  File \"err.py\", line 8, in bar\n    return foo(s) * 2\n  File \"err.py\", line 5, in foo\n    return 10 / int(s)\nZeroDivisionError: integer division or modulo by zero\nEND\n```\n\n#### 自己编写错误\n\n```python\n# err.py\nclass FooError(StandardError):\n    pass\n\ndef foo(s):\n    n = int(s)\n    if n==0:\n        raise FooError('invalid value: %s' % s)\n    return 10 / n\n```\n\n#### 继续向上抛出异常\n\n```python\n# err.py\ndef foo(s):\n    n = int(s)\n    return 10 / n\n\ndef bar(s):\n    try:\n        return foo(s) * 2\n    except StandardError, e:\n        print 'Error!'\n        raise\n\ndef main():\n    bar('0')\n\nmain()\n```\n\n### 调试\n\n#### 断言`assert`\n\n```python\n# err.py\ndef foo(s):\n    n = int(s)\n    assert n != 0, 'n is zero!'\n    return 10 / n\n\ndef main():\n    foo('0')\n```\n\n`assert`语句本身会抛出异常，`AssertionError`\n\n可以用`-O`参数关闭 assert：`python -O err.py`\n\n#### 日志`logging`\n\n几个级别：`debug`，`info`，`warning`，`error`。\n\n可以指定级别，当我们指定`level=INFO`时，`logging.debug`就不起作用了。\n\n```python\nimport logging\nlogging.basicConfig(level=logging.INFO)\n```\n\n### 单元测试\n\n#### `unittest`模块\n\n```python\n# mydict_test.py\n\nimport unittest\nfrom mydict import Dict\n\nclass TestDict(unittest.TestCase):\n\n    def test_init(self):\n        d = Dict(a=1, b='test')\n        self.assertEquals(d.a, 1)\n        self.assertEquals(d.b, 'test')\n        self.assertTrue(isinstance(d, dict))\n\n    def test_key(self):\n        d = Dict()\n        d['key'] = 'value'\n        self.assertEquals(d.key, 'value')\n\n    def test_attr(self):\n        d = Dict()\n        d.key = 'value'\n        self.assertTrue('key' in d)\n        self.assertEquals(d['key'], 'value')\n\n    def test_keyerror(self):\n        d = Dict()\n        with self.assertRaises(KeyError):\n            value = d['empty']\n\n    def test_attrerror(self):\n        d = Dict()\n        with self.assertRaises(AttributeError):\n            value = d.empty\n```\n\n- 测试类：从`unittest.TestCase`继承。\n\n- 以`test`开头的方法才会被认为是测试方法，才能被执行\n\n- 用断言来判断是否符合期望，`assertEquals()` `assertTrue()` ，以及抛出异常：\n\n  ```python\n  with self.assertRaises(AttributeError):\n      value = d.empty\n  ```\n\n#### 运行单元测试\n\n1. 在单元测试文件`mydict_test.py`下加上两行代码：\n\n   ```python\n   if __name__ == '__main__':\n       unittest.main()\n   ```\n\n   这样就可以像正常脚本一样运行了`$ python mydict_test.py`\n\n2. 用参数`-m unittest`：`$ python -m unittest mydict_test.py`\n\n#### `setUp()`和`tearDown()`\n\n分别会在每调用一个测试方法的前后分别被执行。\n\n### 文档测试\n\n`doctest`模块：\n\n```python\n# mydict.py\nclass Dict(dict):\n    '''\n    Simple dict but also support access as x.y style.\n\n    >>> d1 = Dict()\n    >>> d1['x'] = 100\n    >>> d1.x\n    100\n    >>> d1.y = 200\n    >>> d1['y']\n    200\n    >>> d2 = Dict(a=1, b=2, c='3')\n    >>> d2.c\n    '3'\n    >>> d2['empty']\n    Traceback (most recent call last):\n        ...\n    KeyError: 'empty'\n    >>> d2.empty\n    Traceback (most recent call last):\n        ...\n    AttributeError: 'Dict' object has no attribute 'empty'\n    '''\n    def __init__(self, **kw):\n        super(Dict, self).__init__(**kw)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:\n            raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\nif __name__=='__main__':\n    import doctest\n    doctest.testmod()\n```\n\n运行测试：`python mydict.py`\n\n## IO 编程\n\n### 文件读写\n\n```python\nf = open('/Users/michael/test.txt', 'r')\nf.read()\t# 一次读取文件的全部内容，用一个str对象表示\nf.close()\t# 文件使用完毕后必须关闭\n```\n\n由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。最好用`try...finally`来写：\n\n```python\ntry:\n    f = open('/path/to/file', 'r')\n    print f.read()\nfinally:\n    if f:\n        f.close()\n```\n\nPython 引入了`with`语句来帮助调用：\n\n```python\nwith open('/path/to/file', 'r') as f:\n    print f.read()\n```\n\n- `read(size)`可以读取 size 个字节的内容\n- `readline()`可以读取一行内容\n- `readlines()`一次读取所有内容并按行返回`list`\n\n### 操作文件和目录\n\n`os`模块\n\n```python\nimport os\n# 系统\nos.name\t\t\t\t# 操作系统名字，posix->(Linux/Unix/Mac OS X)，nt->Windows\nos.uname()\t\t\t# 详细系统信息，Windows不提供该接口\nos.environ\t\t\t# 系统环境连梁\nos.getenv('PATH')\t# 获取某个环境变量的值\n\n# 文件和目录\nos.path.abspath('.')\t# 查看当前目录的绝对路径\nos.mkdir(os.path.join(os.path.abspath('.'), 'testdir'))\t# 创建新目录\nos.rmdir(os.path.join(os.path.abspath('.'), 'testdir'))\t# 删除该目录\n# 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数\n# 要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数\n# 这样可以正确处理不同操作系统的路径分隔符。\n\n# os.path.splitext()可以直接让你得到文件扩展名\nos.path.splitext('/path/to/file.txt') # ('/path/to/file', '.txt')\n```\n\n- `os`模块不提供拷贝文件的接口，而`shutil`模块提供了`copyfile()`的函数。\n\n### 序列化（pickling）\n\n序列化：把变量从内存中变成可存储或传输的过程。\n\n`cPickle`和`pickle`\n\n```python\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n```\n\n```python\nd = dict(name='Bob', age=20, score=88)\n\n# pickle.dumps()方法把任意对象序列化成一个str\ns = pickle.dumps(d) # \"(dp0\\nS'age'\\np1\\nI20\\nsS'score'\\np2\\nI88\\nsS'name'\\np3\\nS'Bob'\\np4\\ns.\"\n# pickle.load(s() 反序列化\npickle.loads(s) # {'age': 20, 'score': 88, 'name': 'Bob'}\n\n# pickle.dump()直接把对象序列化后写入一个file-like Object\nf = open('dump.txt', 'wb')\ns = pickle.dump(d, f)\nf.close()\n# pickle.load() 反序列化\nf = open('dump.txt', 'rb')\npickle.load(f)\nf.close()\n```\n\n#### JSON\n\n内置的`json`模块\n\n```python\nimport json\nd = dict(name='Bob', age=20, score=88)\njson.dumps(d) # '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n# dump则可以用于写入\n# loads、load等\n```\n\n#### 定制 JSON 序列化\n\n将某个 class 的实例序列化成 JSON：\n\n```python\nimport json\n\nclass Student(object):\n\tdef __init__(self, name, age, score):\n\t\tself.name = name\n\t\tself.age = age\n\t\tself.score = score\n\tdef student2dict(std):\n\t\treturn {\n\t\t\t'name': std.name,\n\t\t\t'age': std.age,\n\t\t\t'score': std.score\n\t\t}\n\ns = Student('Bob', 20, 88)\nprint(json.dumps(s, default=student2dict))\n```\n\n- 偷懒的方法：利用`__dict__`属性，它就是一个`dict`，用来存储实例变量。\n\n反序列化：\n\n```python\ndef dict2student(d):\n    return Student(d['name'], d['age'], d['score'])\n\njson_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\nprint(json.loads(json_str, object_hook=dict2student))\n```\n\n## 进程和线程\n\n### 多进程（multiprocessing）\n\nUnix/Linux 操作系统提供了一个`fork()`系统调用，子进程永远返回`0`，而父进程返回子进程的 ID。子进程只需要调用`getppid()`就可以拿到父进程的 ID。\n\n```python\n# multiprocessing.py\nimport os\n\nprint 'Process (%s) start...' % os.getpid()\npid = os.fork()\nif pid==0:\n    print 'I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())\nelse:\n    print 'I (%s) just created a child process (%s).' % (os.getpid(), pid)\n```\n\n#### `multiprocessing`模块 - 跨平台\n\n```python\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print 'Run child process %s (%s)...' % (name, os.getpid())\n\nif __name__=='__main__':\n    print 'Parent process %s.' % os.getpid()\n    p = Process(target=run_proc, args=('test',))\n    print 'Process will start.'\n    p.start()\n    p.join() # join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n    print 'Process end.'\n```\n\n```\nParent process 928.\nProcess will start.\nRun child process test (929)...\nProcess end.\n```\n\n#### Pool 进程池\n\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print 'Run task %s (%s)...' % (name, os.getpid())\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print 'Task %s runs %0.2f seconds.' % (name, (end - start))\n\nif __name__=='__main__':\n    print 'Parent process %s.' % os.getpid()\n    p = Pool()\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print 'Waiting for all subprocesses done...'\n    p.close()\t# 调用close()之后就不能继续添加新的Process了\n    p.join()\t# 调用join()之前，一定要调用close()\n    print 'All subprocesses done.'\n```\n\n`Pool`默认大小是 CPU 核数，当创建多于`Pool`大小的进程数时，后面的进程就会等待前面的进程执行完成再执行。\n\n```\nParent process 669.\nWaiting for all subprocesses done...\nRun task 0 (671)...\nRun task 1 (672)...\nRun task 2 (673)...\nRun task 3 (674)...\nTask 2 runs 0.14 seconds.\nRun task 4 (673)...\nTask 1 runs 0.27 seconds.\nTask 3 runs 0.86 seconds.\nTask 0 runs 1.41 seconds.\nTask 4 runs 1.91 seconds.\nAll subprocesses done.\n```\n\n也可以设置`p = Pool(5)`同时运行 5 个进程。\n\n#### 进程间通讯\n\n`Queue`策略\n\n```python\nfrom multiprocessing import Process, Queue\nimport os, time, random\n\n# 写数据进程执行的代码:\ndef write(q):\n    for value in ['A', 'B', 'C']:\n        print 'Put %s to queue...' % value\n        q.put(value)\n        time.sleep(random.random())\n\n# 读数据进程执行的代码:\ndef read(q):\n    while True:\n        value = q.get(True)\n        print 'Get %s from queue.' % value\n\nif __name__=='__main__':\n    # 父进程创建Queue，并传给各个子进程：\n    q = Queue()\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n    # 启动子进程pw，写入:\n    pw.start()\n    # 启动子进程pr，读取:\n    pr.start()\n    # 等待pw结束:\n    pw.join()\n    # pr进程里是死循环，无法等待其结束，只能强行终止:\n    pr.terminate()\n```\n\n还有`Pipes`等策略\n\n### 多线程\n\n`threading`高级模块对`thread`模块进行了封装，较常使用。\n\n```python\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print 'thread %s is running...' % threading.current_thread().name\n    n = 0\n    while n < 5:\n        n = n + 1\n        print 'thread %s >>> %s' % (threading.current_thread().name, n)\n        time.sleep(1)\n    print 'thread %s ended.' % threading.current_thread().name\n\nprint 'thread %s is running...' % threading.current_thread().name\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint 'thread %s ended.' % threading.current_thread().name\n```\n\n```\nthread MainThread is running...\nthread LoopThread is running...\nthread LoopThread >>> 1\nthread LoopThread >>> 2\nthread LoopThread >>> 3\nthread LoopThread >>> 4\nthread LoopThread >>> 5\nthread LoopThread ended.\nthread MainThread ended.\n```\n\n#### Lock\n\n```python\nimport time, threading\n\n# 假定这是你的银行存款:\nbalance = 0\n\ndef change_it(n):\n    # 先存后取，结果应该为0:\n    global balance\n    balance = balance + n\n    balance = balance - n\n\nlock = threading.Lock()\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n\nt1 = threading.Thread(target=run_thread, args=(5,))\nt2 = threading.Thread(target=run_thread, args=(8,))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint balance\n```\n\n#### 多核 CPU\n\nPython 因为存在 global interpret lock（GIL 锁）的关系，虽然可以多线程执行，但无法真正利用多核。每个进程最多利用 2 两个核。\n\n### ThreadLocal\n\n为每个线程单独建立作用域\n\n```python\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    print 'Hello, %s (in %s)' % (local_school.student, threading.current_thread().name)\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start() # Hello, Alice (in Thread-A)\nt2.start() # Hello, Bob (in Thread-B)\nt1.join()\nt2.join()\n```\n","tags":["Coding","Course Notes"]},{"title":"杂谈：《软技能》学习篇阅读笔记","url":"/blog/2017/08/07/2017-08-07 《软技能》学习篇阅读笔记/","content":"\n## 章节\n\n1. 学习怎样学习：如何自我教育\n   - 最好的方法就是立即付诸实践。\n2. 十步学习法\n   - 快速学习的“十步学习法”\n   - 为了掌握技术需要了解的三个要点\n     - 如何开始（想要开始使用，需要哪些基础知识）\n     - 学科范围\n     - 基础知识（基本的案例和常见问题，哪个 20%能满足 80%的日常应用）\n   - “十步学习法”的基本思想\n     - 对自己要学的内容有基本了解\n     - 用这些信息勾勒出学习范围\n     - 找到相应资源帮助自己学习\n     - 创建自己的学习计划，筛选学习材料\n\n- 第一步到第六步：这些步骤只做一次\n  - 了解全局 → 确定范围 → 定义目标 → 寻找资源 → 创建学习计划 → 筛选资源\n- 第七步到第十步：循环往复\n  - 开始学习浅尝辄止 → 动手操作边玩边学 → 全面掌握学以致用 → 乐为人师融会贯通\n- 寻找导师\n- 开山收徒\n- 传道授业\n- 你需要一个学位吗\n- 发现自己的知识短板\n\n## 总结\n\n学习新技能最好的方法就是立即付诸实践，但最好在这之前做一些调研。\n\n### 只做一次\n\n#### #1 了解全局\n\n做基础性研究，通过网络搜索（Google，知乎等），或者如果手头正好有一本相关主题的书，就可以根据它的章节来粗略浏览一下内容，有一个全局性的了解。\n\n#### #2 确定范围\n\n> 学习过程中，大家很容易犯的一个错误就是试图解决太大的问题而把自己搞得不堪重负。\n\n可以为学习添加一个理由，阐述学习的理由能够帮助你明确学习的范围，一次只学一样东西，潜心学习。\n\n#### #3 定义目标\n\n清晰描绘出成功的样子（比如，知道数码相机的所哟功能，清晰描述这些功能是什么，并知道何时何地使用）\n\n#### #4 寻找资源\n\n与头脑风暴类似，尽可能多渠道。\n\n#### #5 创建学习计划\n\n可能会与一本书的目录非常相似（其实也可以是某个 MOOC 的课程安排等）\n\n#### #6 筛选资源\n\n第四步中寻找的资源浏览一遍，找出哪些内容可以覆盖你的学习计划，看看评论。\n\n### 循环往复\n\n#### #7 开始学习，浅尝辄止\n\n目标是获得足够多的与所学主题相关的信息，让你开始学习（玩游戏之前快速浏览一遍用户手册，只需要知道基本用法即可，玩一会之后再完整阅读）\n\n#### #8 动手操作，边玩边学\n\n先创建一个小项目来测试，把暂时没有答案的问题记录下来。\n\n#### #9 全面掌握，学以致用\n\n这一步的目的是让你找回好奇心驱动的学习，利用先前搜集的资料，来回答上一步产生的问题。\n\n只需要阅读或观看与当前所学相关的部分。\n\n#### #10 乐为人师，融会贯通\n\n走出舒适区，用教别人的方法来确定自己是否的确掌握了某些知识。\n\n---\n\n当然上述的方法，不一定每一步都要做，根据自己的实际情况进行调整。在这个过程中，还要发现自己的短板，并进行补足。\n\n#### 发现短板\n\n> 准确识别它们的最佳方式之一就是看看自己在哪些工作上花费了大量的时间，或者一直进行重复性劳动。\n\n1. 彻查自己需要做的重复性工作里面是否有自己不理解的地方（比如，你经常使用的一个应用的键盘快捷键）\n2. 维护一份清单，将自己不了解或者需要研究的事物记录，追踪有哪些主题经常出现。\n","tags":["Reading"]},{"title":"杂谈：《软技能》生产力篇阅读笔记","url":"/blog/2017/08/07/2017-08-07 《软技能》生产力篇阅读笔记/","content":"\n### 一切开始于专注\n\n- 花一些时间先把所有的事务在脑中过一遍，然后才能达到思维高峰以完成任务。\n- 专注模式不是一个“即插即用”的开关，无法瞬间切换到专注模式。\n- 你要激发自己的斗志，对抗各种让你分心的事情，将自己送入巡航状态。\n\n### 生产力提升计划\n\n- 基本思路:把一周的时间分配给一个个用时不超过两小时的小任务。\n- 值得推荐的应用：[看板](https://kanbanflow.com)\n- 用“番茄工作法”保持专注，并且用其来估算和衡量每一个任务要花多长时间\n- 磨刀不误砍柴工：制定季度计划、月计划（花一天时间制定这个月的计划）、周计划（每周一上午）、日计划\n- 为每一项任务分配一个卡片，工作相关的约会也可以创建卡片，每天大概会有 9 个番茄钟用于工作。\n- 要事先控制自己的时间，而不是回头看\n- 日计划：\n  - 保证每天先完成最重要的事情\n  - 确保工作前明确自己在做什么，标准是什么\n- 将邮件、社交软件放在一个时间统一处理。\n- 记得休息和休假\n\n### 番茄工作法\n\n（25m+5m）的工作法\n\n- 跟踪自己一天内完成了多少个番茄钟，并为每天要完成的番茄钟的数量设定目标，每周进行调整。\n- 总为自己没有做更多的事情感到内疚？根源在于，你无法准确评估每天到底自己完成了多少任务，也没有为自己每天到底要完成多少任务设定明确的目标。\n\n### 定额工作法\n\n用来确保自己每天、每周都朝着自己最重要的目标取得明确的、可度量的进展（健身、博客都是很好的例子）\n\n- 对自己做的任何**重复性工作**的频率进行量化，比如每周健身 X 次，每周写 X 篇博客\n- 将大任务分解成小的模块或章节，从而进行定额。\n- 核心是“承诺”，不要找借口，一旦违背承诺，定额工作法就会变得一文不值。\n- 假如的确每周定额的量有点大，但这周也必须完成，下周再进行调整。保持对自己的承诺的尊重。\n\n### 对自己负责\n\n自我激励的核心：自我责任感。\n\n- 首先让自己的生活尽然有序，创建自己的规则来管理自己的生活。要在自己思维清晰，大脑尚未被错误的判断蒙蔽的时候，提前制定好规则。\n- 外部问责：监督伙伴。\n\n### 要不要多任务并行\n\n答案：大部分情况下，不要\n\n- 我们大多数情况下，只是不停切换任务，而不是多任务并行。\n- 将类似的事情，批量处理，效率更高（如收发邮件）\n- 真正的多任务并行：将不费脑的人物和需要精神集中的事情组合（比如边听音乐边工作、听有声读物进行健身）\n\n### 职业倦怠\n\n在开始前，就制定好计划，那时兴趣和动机都处于最高点\n\n### 时间是怎样被浪费的\n\n追踪自己的时间：rescureTime\n\n### 形成惯例的重要性\n\n生产力真正的秘诀：长期坚持做一件小事。\n\n每天生活越条理，越能把控自己的生活。如果一直对外界做出反应，那只是在被动的处理事情而非主动规划。\n\n- 一个好的惯例始于一个大的目标\n- 弄清楚怎样才能每天或每周前进，实现目标\n- 围绕这一目标安排自己的日程\n\n### 培养习惯\n\n习惯的构成：暗示、惯例和奖励。\n\n- 暗示：比如到了电影院就得到了买爆米花的暗示\n- 惯例\n- 奖励：可能只是一种满足感\n\n找到坏习惯：\n\n- 设法找到日常生活中令你感到内疚的事情或惯例。\n- 找到这个习惯被什么触发，你这么做有什么表现，以及是什么奖励激励你产生冲动要这样做。\n\n培养新习惯：\n\n- 选定了要养成的习惯之后，想想有助于激励你养成这一习惯的奖励。\n- 为你的新习惯找出暗示，是什么触发你的习惯？\n\n### 分解任务：如何吃掉一头大象\n\n- 大型任务给人带来沉重的心理负担\n- 大型任务往往也很难估算完成时间\n- 在分配大任务之后，第一件事就是去了解是否能将它分解成一连串的小任务\n\n---\n\n## 总结\n\n- 工作之前提前制定好计划，并将大任务进行分解\n- 行成好的习惯有利于完成那些需要日积月累的目标（健身、写书等）\n- 利用番茄工作法提高效率\n- 专注最重要\n","tags":["Reading"]},{"title":"JavaScript闭包","url":"/blog/2017/07/27/2017-07-27 JavaScript闭包/","content":"\n## JavaScript 闭包\n\n一般而言，因为存在作用域链的关系，JavaScript 函数内部可以访问函数外部的变量，而函数外部往往无法访问到函数内部的变量。\n\n而 JavaScript 闭包的作用，就是通过改变作用域链的方式，使得函数外部可以访问到函数内部的作用域。详见下方的例子：\n\n```js\nvar f = function () {\n    var x = \"x in f\"\n    var getX = function () {\n        return x\n    }\n    return getX\n}\n\nvar get = f()\nconsole.log(get()) // 'x in f'\n```\n\nJavaScript 闭包，指的是一个函数内部的函数，通过将这个内部函数暴露给外界（如作为返回值返回、立即执行函数等），外界即可访问到这个函数内部的作用域。关于作用域的解释，可以详见我的另一篇博客：[JavaScript 执行环境和作用域](http://jackieanxis.coding.me/2017/07/24/JavaScript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/)。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-7-28/97746191.jpg)\n\n上图中：\n\n-   灰色部分表示了作用域链的构成，从最内部的`getX`到最外层的全局作用域`Global`。只能由作用域链顶端访问作用域链底端。\n-   蓝色部分表示了一次赋值，此时将`f`内部的函数赋值给了作用域链底端的全局作用域，于是全局作用域链又能访问到`f`内部的变量了。\n\n## 变量的生命周期\n\n全局变量，会被当做 Global 变量的一个属性一直保存下来，于是它的生命周期是永久的。\n\n局部变量，指的是函数内部的变量，一般情况下，当函数调用结束后，该变量就会被垃圾回收机制回收，再次调用该函数的时候，会再创建一个变量。\n\n闭包的一个关键作用，就是能延长一个变量的生命周期。\n\n```js\nvar f = function () {\n    var count = 0\n    return function () {\n        count++\n        return count\n    }\n}\n\nvar count = f()\nconsole.log(count()) // 1\nconsole.log(count()) // 2\nconsole.log(count()) // 3\n```\n\n事实上，变量依附于它存在的作用域，一旦该作用域从作用域链中弹出，这个作用域中的变量也随即销毁。\n\n## 闭包经典问题\n\n### 问题一：\n\n需要给多个按钮绑定不同的事件：\n\n```html\n<button id=\"email\"></button>\n<button id=\"name\"></button>\n<button id=\"age\"></button>\n```\n\n```js\nvar text = [\n    { id: \"email\", text: \"jackie@mail.com\" },\n    { id: \"name\", text: \"Jackie\" },\n    { id: \"age\", text: \"18\" },\n]\nfor (var i = 0; i < text.length; i++) {\n    var item = text[i]\n    document.getElementById(item.id).onclick = function () {\n        alert(item.text)\n    }\n}\n```\n\n这时你会发现，点击任何一个 button，输出的都是 18，这和 JavaScript 的作用域机制有关，那么要怎么达到我们想要的效果，使得这几个回调函数不共享一个作用域：\n\n```js\nvar text = [\n    { id: \"email\", text: \"jackie@mail.com\" },\n    { id: \"name\", text: \"Jackie\" },\n    { id: \"age\", text: \"18\" },\n]\nvar click = function (item) {\n    return function () {\n        alert(item.text)\n    }\n}\nfor (var i = 0; i < text.length; i++) {\n    var item = text[i]\n    document.getElementById(item.id).onclick = click(item)\n}\n```\n\n当然，es6 标准中提出了更便捷、规范的解决方案，就是用`let`关键字：\n\n```js\nvar text = [\n    { id: \"email\", text: \"jackie@mail.com\" },\n    { id: \"name\", text: \"Jackie\" },\n    { id: \"age\", text: \"18\" },\n]\nfor (var i = 0; i < text.length; i++) {\n    let item = text[i]\n    document.getElementById(item.id).onclick = function () {\n        alert(item.text)\n    }\n}\n```\n\n### 问题二：\n\n循环内的异步调用（本质和前者无区别）\n\n```js\nfor (var i = 0; i < 3; i++) {\n    setTimeout(function () {\n        console.log(i)\n    }, i * 1000)\n}\n```\n\n对应的正确解决方法，利用匿名函数存储变量 i\n\n```js\nfor (var i = 0; i < 3; i++) {\n    ;(function (i) {\n        setTimeout(function () {\n            console.log(i)\n        }, i * 1000)\n    })(i)\n}\n```\n\n## 闭包的负面影响\n\n闭包对脚本性能具有负面影响，包括处理速度和内存消耗。故而，在没有必要创建闭包的时候，就最好不要创建闭包。例子来自[MDN 闭包](https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures)：\n\n```js\nfunction MyObject(name, message) {\n    this.name = name.toString()\n    this.message = message.toString()\n    this.getName = function () {\n        return this.name\n    }\n\n    this.getMessage = function () {\n        return this.message\n    }\n}\n```\n\n改写如下：\n\n```js\nfunction MyObject(name, message) {\n    this.name = name.toString()\n    this.message = message.toString()\n}\nMyObject.prototype.getName = function () {\n    return this.name\n}\nMyObject.prototype.getMessage = function () {\n    return this.message\n}\n```\n","tags":["FrontEnd","JavaScript"]},{"title":"JavaScript中的this关键字","url":"/blog/2017/07/25/2017-07-25 JavaScript中的this关键字/","content":"\n## `this`的五种不同情形\n\n### 默认情况\n\n默认情况下，纯粹函数调用时，因为没有调用该方法的对象，故而此时的`this`是`undefined`，JavaScript 解释器会自动把这个对象指向全局对象 Global，在浏览器环境下，也即 window 对象。\n\n```js\nwindow.x = \"Jackie\";\n\nfunction func() {\n  console.log(this.x);\n}\n\nfunc(); // Jackie\n```\n\n阮一峰老师的博客中提到：\n\n> 在严格模式（`\"use strict\"`）下，会禁止`this`指向全局对象，此时的`this`会是`undefined`。\n\n事实上，[ES5 的规范](http://es5.github.io/#x10.4.3) 中修改了描述，仅当非严格模式下才会有 `this` 指向的转变。所以此时`this`无法改变指向，就会是`undefined`，但并不是说无法指向全局对象。\n\n```javascript\n\"use strict\";\nfunction foo() {\n  console.log(this);\n}\nfoo.call(this); // Window\n```\n\n### 作为对象的方法调用\n\n此时`this`指向调用这个方法的对象。\n\n```js\nvar x = \"Property of Window\";\n\nvar obj = {};\nobj.x = \"Property of obj\";\nobj.f = function () {\n  console.log(this.x);\n};\n\nobj.f(); // Property of obj\n\n// 值得注意的情况\nvar f = obj.f;\nf(); // Property of Window\n```\n\n### `call`、`apply`和`bind `的显式绑定\n\n`call`、`apply`和`bind`都可以改变一个函数的`this`指向。\n\n#### `call`和`apply`\n\n`call`和`apply`会将它们的调用对象的`this`指向它们的第一个参数。\n\n```js\nfunction f() {\n  console.log(this.x);\n}\n\nvar x = \"Property of Window\";\n\nvar obj = {\n  x: \"Property of obj\",\n};\n\nf.apply(obj); // \"Property of obj\"\n```\n\n当传入的第一个参数为 undefined，或者不传入参数时，在非严格模式下，自动会将`this`指向全局对象 Global，在浏览器里是`window`对象，严格模式下则会是`undefined`：\n\n```js\nfunction f() {\n  console.log(this);\n}\n\nf.apply(); // window\nf.apply(undefined); // window\n\nfunction ff() {\n  \"use strict\";\n  console.log(this);\n}\nff.apply(); // undefined\nff.apply(undefined); // undefined\n```\n\n`call`和`apply`没有本质区别。唯一的区别在于：\n\n> `call()`方法接受的是**若干个参数的列表**，而`apply()`方法接受的是**一个包含多个参数的数组**。\n\n#### `bind`\n\n`bind`和前面两者也并未有什么本质的区别，只不过`bind`将第一个参数绑定当调用函数的`this`上，并将这个函数返回（不执行）。\n\n```js\nfunction f() {\n  console.log(this.x);\n}\n\nvar x = \"Property of Window\";\n\nvar obj = {\n  x: \"Property of obj\",\n};\n\nvar ff = f.bind(obj);\nff(); // \"Property of obj\"\n```\n\n### 构造函数\n\n当一个函数被当做**构造函数**，用`new`关键字新建一个对象的时候，这个函数内部的`this`以及原型链上的`this`都会指向这个新建的对象。\n\n```js\nfunction Jackie(para) {\n  this.para = para;\n  console.log(this);\n}\nJackie.prototype.log = function () {\n  console.log(this);\n};\n\nJackie(\"hehe\"); // Window\nvar p = new Jackie(\"haha\"); // Jackie {para: \"haha\"}\np.log(); // Jackie {para: \"haha\"}\n```\n\n### 其他值得注意的绑定\n\n#### 放在超时代码里\n\nJavaScript 中超时调用的代码，函数中 this 的值会指向 window 对象，在严格模式下也一样。因为超时调用的代码都会有一个隐式绑定：`setTimeout(f, time) == setTimeout(f.bind(window), time)`。\n\n```js\n\"use stric\";\nvar x = \"Property of Window\";\n\nvar obj = {};\nobj.x = \"Property of obj\";\nobj.ff = function () {\n  setTimeout(function () {\n    console.log(this.x);\n  }, 100);\n};\n\nobj.ff(); // Property of Window\n\n// 可以这么解决问题\nobj.fff = function () {\n  var that = this;\n  setTimeout(function () {\n    console.log(that.x);\n  }, 100);\n};\nobj.fff(); // Property of obj\n```\n\n#### 事件监听函数中的 this\n\n事件监听函数中的`this`指向监听对象。\n\n```js\nvar one = document.getElementById(\"one\");\none.onclick = function () {\n  console.log(this);\n};\n\none.click(); // <div id=\"one\"></div>\n```\n\n#### 箭头函数\n\n箭头函数中`this`的指向，在函数定义时即绑定完毕，且后续无法更改。（即，会跟它的上级作用域的`this`指针保持一致）\n\n```json\nvar obj = {\n  x: 1\n}\n\nvar f1 = () => {\n  console.log(this)\n}\nf1.apply(obj) // Window\n\nvar f2 = function () {\n  var f3 = () => {\n    console.log(this)\n  }\n  return f3\n}\n\nvar f4 = f2.apply(obj)\nf4() // Object {x: 1}\n```\n\n一个更神奇的例子，超时调用的代码在定义时，绑定了`this`的指向。\n\n```js\nfunction foo() {\n  setTimeout(() => {\n    console.log(\"id:\", this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 }); // id: 42\n```\n\n## 绑定的优先级\n\n```js\nvar obj = { x: 0, name: \"obj\" };\nvar robj = { x: -1, name: \"robj\" };\nvar factory = function (x) {\n  this.x = x;\n  console.log(this);\n};\n\nvar factoryBind = factory.bind(obj);\nrobj.factory = factoryBind;\nrobj.factory(2); // Object {x: 2, name: \"obj\"}，作为方法的绑定的优先级低于bind的显式绑定\n\nfactoryBind.call(robj, 3); // Object {x: 3, name: \"obj\"}，call的优先级低于bind\nconsole.log(robj); // Object {x: -1, name: \"robj\", factory: function}，未对robj进行修改\nconsole.log(obj); // Object {x: 3, name: \"obj\"}，修改的是obj，因为this指针指向未变化\n\nvar p = new factoryBind(4); // factory {x: 4}\nconsole.log(p); // factory {x: 4}\nconsole.log(obj); // Object {x: 3, name: \"obj\"}，构造函数绑定的优先级高于bind的显式绑定\n```\n\n可以见得，优先级从高到低：\n\n1. `new`，构造绑定\n2. `bind`，显式绑定\n3. `call`/`apply`，显示绑定\n4. 作为方法绑定\n5. 默认绑定\n","tags":["FrontEnd","JavaScript"]},{"title":"JavaScript执行环境和作用域","url":"/blog/2017/07/24/2017-07-24 JavaScript执行环境和作用域/","content":"\n# JavaScript 执行环境和作用域\n\n## 重要概念\n\n- **执行环境**（excution context，有时候也称之为“环境”）\n\n- **环境栈**：当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。执行之后，再从环境栈中弹出。\n\n- **作用域链**(scope chain):保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。\n\n- 请谨记：\n\n  > JavaScript 中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里。\n  >\n  > ——《JavaScript 权威指南》\n\n## 变量对象 和 活动对象\n\n### 变量对象\n\n**变量对象**（variable object，每个执行环境都有一个与之关联的变量对象），变量对象保存了以下三个内容：\n\n1. 形参（如果执行环境是一个函数的话）\n2. `var`声明的**变量**。\n\n   - 用`let`和`const`声明变量只存在于块级作用域内，无法放入执行环境栈的变量对象中。\n   - 直接声明的变量，比如`a=10`，其实不能称之为变量，它只是全局对象的一个属性，也无法保存进变量对象中。\n\n   ```js\n   console.log(a); // undefined\n   console.log(b); // Uncaught ReferenceError: b is not defined\n   b = 10;\n   var a = 20;\n   ```\n\n3. 函数声明，不包括函数表达式。**函数声明**和**函数表达式**的区别，在我的另一篇博客里有说明：[JavaScript 函数表达式和函数声明](http://jackieanxis.coding.me/2017/05/19/JavaScript%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/)。\n\n### 活动对象\n\n**活动对象**（activation object），如果所在环境是函数，那么就会把这个函数的**活动对象**作为变量对象(在函数中，变量对象==活动对象)。它一开始只包含`arguments`对象。一般而言，函数执行过程，可以分成两步：1.进入执行环境；2.执行代码。\n比如，下面这个`test`函数：\n\n```JavaScript\nfunction test(a, b) {\n\tvar c = 10;\n\tfunction d() {}\n\tvar e = function _e() {};\n\t(function f() {});\n\tg = 10;\n}\n\ntest(10);\n```\n\n在执行`test(10)`的时候，分成了两步：\n\n1. 进入执行环境。\n   此时，会用`arguments`对象初始化活动对象（AO, activation object）。并且，会把形参、`var`声明的变量和函数声明放入活动对象 AO 中。\n   ```JS\n   AO: {\n     arguments: {\n         callee: test,\n         length: 1,\n         0: 10\n     },\n     a: 10,\n     b: undefined,\n     c: undefined,\n     d: <reference to FunctionDeclaration \"d\">,\n     e: undefined\n   }\n   ```\n2. 执行代码。AO 会变成：\n   ```JS\n   AO: {\n     arguments: {\n         callee: test,\n         length: 1,\n         0: 10\n     },\n     a: 10,\n     b: undefined,\n     c: 10,\n     d: <reference to FunctionDeclaration \"d\">,\n     e: <reference to FunctionDeclaration \"_e\">\n   }\n   ```\n\n## 作用域链\n\n**作用域链**与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。\n\n**作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。**\n\n**全局执行环境的变量对象始终都是作用域链中的最后一个对象。**\n\n### 函数生命周期\n\n#### 函数创建（定义）\n\n- 在一个函数被**定义**的时候, 会将它**定义时刻**的 scope chain 链接到这个函数对象的`[[Scopes]]`属性，函数可以通过这个属性来访问更高层的作用域。\n\n- `[[Scopes]]`是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。\n\n- `[[Scopes]]`在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。\n\n- `[[Scopes]]`存储的是定义时刻的作用域链，是函数本身**所依赖的变量对象**+其所在环境的`[[Scopes]]`组成的。值得注意的是，`[[Scopes]]`不会存储函数本身不依赖的变量对象（也就是不存在冗余），例子如下：\n\n  ```js\n  var func = function () {\n    var x = 0;\n    var y = 1;\n    var f = function () {\n      console.log(x);\n    };\n    return f;\n  };\n  func();\n  ```\n\n  `f`函数的`[[Scopes]]`属性：\n\n  ```js\n  [[Scopes]] = [\n    {\n      x: 0,\n    },\n    Global(Window),\n  ];\n  ```\n\n  故而，`[[Scopes]]`属性和作用域链有微小的区别，但是使用起来可以当做一致，本文后面也将它们视作一致。\n\n- 与作用域链对比，`[[Scopes]]`是函数的一个属性而不是上下文。\n\n- 一个简单的例子：\n  ```js\n  var a = 0;\n  var f = function () {\n    console.log(a);\n  };\n  var f1 = function () {\n    var a = 1;\n    f();\n  };\n  f1(); // 0\n  ```\n\n#### 函数激活（执行）\n\n```\nscope chain = VO/AO + [[Scopes]]\n```\n\n- 一个详细的例子（转载自：[Javascript 作用域原理@Laruence](http://www.laruence.com/2009/05/28/863.html)）\n\n  ```js\n  function factory() {\n    var name = \"laruence\";\n    var intro = function () {\n      alert(\"I am \" + name);\n    };\n    return intro;\n  }\n\n  function app(para) {\n    var name = para;\n    var func = factory();\n    func();\n  }\n\n  app(\"eve\");\n  ```\n\n  1. 调用`app`，刚进入执行上下文时，此时`app`的作用域链（scope chain）应该是活动对象（AO）加上其`[[Scopes]]`属性\n\n     ```js\n     [[Scopes]] = [\n       Global(Window)\n     ]\n\n     scope chain = [{\n       para: 'eve',\n       name: undefined,\n       func: undefined,\n       arguments: [1]\n     }, // AO\n     Global(Window)]\n     ```\n\n  2. 调用`factory`，刚进入执行上下文时，此时`factory`的作用域链：`factory`的活动对象+其`[[Scopes]]`属性\n\n     ```js\n     [[Scopes]] = [\n       Global(Window)\n     ]\n\n     scope chain = [\n     {\n         name: undefined,\n     \tintro: undefined,\n       \targuments: []\n     }, // AO\n     Global(Window)]\n     ```\n\n     此时的作用域链中，不包含 app 的活动对象，因为函数内部只能通过`[[Scopes]]`属性访问上层的作用域。\n\n  3. 定义`intro`函数时候，会将当前的作用域链写入`intro`函数的`[[Scopes]]`属性\n\n     ```js\n     [[Scopes]] = [{\n         name: 'laruence',\n       \tintro: function(),\n       \targuments: []\n     },\n     Global(Window)]\n     ```\n\n  4. 从`factory`函数返回以后，在`app`体内调用`intro`的时候，进入`intro`的执行上下文时，`scope chain`应该是这样的：\n\n     ```js\n     scope chain = [{\n     },   // AO\n     // 下面是[[Scopes]]属性\n     {\n       name: 'laruence',\n       intro: function(),\n       arguments: []\n     }, Global(Window)]\n     ```\n\n  5. 故而，输出是：`I am laruence`\n\n## `eval`函数\n\n代码`eval`的上下文与当前的调用上下文（calling context）拥有同样的作用域链。\n\n唯一的小小的区别是，因为`eval`函数创建的函数，在定义阶段，无法确定函数内部依赖活动对象中的哪些属性，故而会把整个活动对象都写入`[[Scopes]]`属性中。\n\n```js\nfunction factory() {\n  var name = \"laruence\";\n  eval(\"var intro = function () { console.log('I am ' + name); }\");\n  return intro;\n}\nfactory();\n```\n\n`intro`函数的`[[Scopes]]`属性：\n\n```js\n[[Scopes]] = [{\n  arguments: [],\n  intro: function,\n  name: 'laruence'\n}, Global(Window)]\n```\n\n在严格模式下，`eval`语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于`eval`内部。\n\n## `with`语句\n\n- [MDN 上关于 with 的定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with)\n\n- [Javascript 中的 with 关键字](http://luopq.com/2016/02/14/js-with-keyword/)\n\n- 总而言之：`with`语句会将传入的对象，添加到作用域的最前端。\n\n  ```js\n  var x = 10,\n    y = 10;\n\n  with ({ x: 20 }) {\n    var x = 30,\n      y = 30;\n    alert(x); // 30\n    alert(y); // 30\n  }\n\n  alert(x); // 10\n  alert(y); // 30\n  ```\n\n  1. x = 10, y = 10;\n  2. 对象{x:20}添加到作用域的前端;\n  3. 在 with 内部，遇到了 var 声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;\n  4. 在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为 20，变为 30;\n  5. 同样也有变量对象“y”的修改，被解析后其值也相应的由 10 变为 30;\n  6. 此外，在 with 声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30 也从那个对象中移除），即作用域链的结构恢复到 with 得到加强以前的状态。\n  7. 在最后两个 alert 中，当前变量对象的“x”保持同一，“y”的值现在等于 30，在 with 声明运行中已发生改变。\n\n- `catch`也具有相似的效应。\n","tags":["FrontEnd","JavaScript"]},{"title":"JavaScript函数表达式和函数声明","url":"/blog/2017/05/19/2017-05-19 JavaScript函数表达式和函数声明/","content":"\n## 函数表达式和函数声明\n\n1. **函数声明**(Function Declaration):\n\n   - 形如`function <function_name> () {}`，四个元素缺一不可\n   - 不能够是表达式的其中一部分\n\n2. **函数表达式**（Function Expression）:\n   - 最常见的形式：`var func = function () {}`\n   - 函数表达式一般是赋值表达式的一部分，不能单独存在。\n   - 有时候，会给函数加上名字，像这样`var func = function f() {}`，但这实际上没什么用，跟用匿名函数赋值`var func = function() {}`是一样的。\n   ```js\n   var func = function f() {};\n   f(); // Uncaught ReferenceError: f is not defined\n   ```\n   - 还有一种函数表达式，存在于**自执行函数**（self-invoking function）中。比如，下面这种形式，也是函数表达式。\n   ```js\n   (function sayHello() {\n     alert(\"hello!\");\n   })();\n   ```\n\n### 两者之间的异同\n\n- 同：这两个方法都能创建出一个函数，并且这个函数的名字都叫`foo`\n- 异：\n  1.  **函数声明**的方法，存在变量提升的情况，也就是会将这个函数声明提升到作用域最前面。于是，在函数声明前，就能调用这个函数。\n      **函数表达式**的方法，其实也存在变量提升的情况，只不过先声明，但给这个变量赋值为`undefined`。在函数声明前调用这个函数就会报错。\n  ```js\n  (function () {\n    a(); // a\n    b(); // Uncaught TypeError: b is not a function\n    function a() {\n      console.log(\"a\");\n    } // 函数声明\n    var b = function () {\n      console.log(\"b\");\n    }; // 函数表达式\n  })();\n  ```\n  2.  用**函数声明**的方法定义的函数，可以被放入执行环境的变量对象（Variable Object）中；而**函数表达式**定义的函数，不会被放入执行变量的\n","tags":["FrontEnd","JavaScript"]},{"title":"JavaScript中四种不同的属性检测方式比较","url":"/blog/2017/05/16/2017-05-16 JavaScript中四种不同的属性检测方式比较/","content":"\n### JavaScript 中四种不同的属性检测方式比较\n\n1. 用 in 方法\n   ```JavaScript\n   var o = {x:1};\n   \"x\" in o; //true\n   \"y\" in o; //false\n   \"toString\" in o; //true，继承属性可以被检测到\n   \"toString\" in Object.prototype; //true，不可枚举的属性可以被检测到\n   ```\n2. hasOwnProperty()方法\n   ```JavaScript\n   var o = {x:1};\n   o.hasOwnProperty(\"x\"); //true\n   o.hasOwnProperty(\"y\"); //false\n   o.hasOwnProperty(\"toString\"); //false，无法检测继承属性\n   Object.prototype.hasOwnProperty(\"toString\"); //true，不可枚举的属性可以被检测到\n   ```\n3. propertyIsEnumerable()方法\n   ```JavaScript\n   var o = Object.create({y:2});\n   o.x = 1;\n   o.propertyIsEnumerable(\"x\"); //true，x是可枚举的属性\n   o.propertyIsEnumerable(\"y\"); //false，继承属性，不可枚举\n   Object.prototype.propertyIsEnumerable(\"toString\"); //false，不可枚举的属性无法被检测\n   ```\n4. !== undefined 方法\n   ```JavaScript\n   var o = {x : 1};\n   o.x !== undefined; //true，o中有属性x\n   o.toString !== undefined; //true，继承属性也可以被检测到\n   ```\n   这种方法的一个弱点是，无法区分不存在的属性和存在但值为 undefined 的值，如：\n   ```JavaScript\n   var o = {x : undefined};\n   o.x !== undefined; //false\n   \"x\" in o; //true\n   ```\n   注意这里用的是`\"!==\"`而不是`\"!=\"`，因为`\"!==\"`可以区分`undefined`和`null`。\n   但有时候不用区分`\"null\"`和`\"undefined\"`，只要判断一个属性不是`null`或`undefined`即可。\n   ```JavaScript\n   //如果o含有属性x，且x的值不是undefined或null，o.x乘以2\n   if(o.x != null) o.x *= 2;\n   ```\n5. 总结\n   继承属性是不可枚举的，所以能检测继承属性的，肯定也能检测到不可枚举属性。\n   × 表示无法检测，√ 表示可以检测\n\n| 检测方法             | 不可枚举属性？ | 继承属性？   |\n| -------------------- | -------------- | ------------ |\n| in                   | $\\checkmark$   | $\\checkmark$ |\n| hasOwnProperty       | $\\checkmark$   | $\\times$     |\n| propertyIsEnumerable | $\\times$       | $\\times$     |\n| !==                  | $\\checkmark$   | $\\checkmark$ |\n","tags":["FrontEnd","JavaScript"]},{"title":"JavaScript类型转换和相等性","url":"/blog/2017/04/15/2017-04-15 JavaScript类型与相等性/","content":"\n## 类型转换总结列表\n\n| 值                                    | 字符串                                         | 数字     | 布尔值 | 对象                 |\n| :------------------------------------ | :--------------------------------------------- | :------- | :----- | :------------------- |\n| undefined                             | \"undefined\"                                    | NaN      | false  | throwTypeError       |\n| null                                  | \"null\"                                         | 0        | false  | throwTypeError       |\n| true                                  | \"true\"                                         | 1        |        | newBoolean(true)     |\n| false                                 | \"false\"                                        | 0        |        | newBoolean(false)    |\n| \"\"（空字符串）                        |                                                | 0        | false  | newString(\"\")        |\n| \"1.2\"（非空，数字，允许首尾带有空格） |                                                | 1.2      | true   | newString(\"1.2\")     |\n| \"one\"（非空，非数字）                 |                                                | NaN      | true   | newString(\"one\")     |\n| 0                                     | \"0\"                                            |          | false  | newNumber(0)         |\n| -0                                    | \"0\"                                            |          | false  | newNumber(-0)        |\n| NaN                                   | \"NaN\"                                          |          | false  | newNumber(NaN)       |\n| Infinity                              | \"Infinity\"                                     |          | true   | newNumber(Infinity)  |\n| -Infinity                             | \"-Infinity\"                                    |          | true   | newNumber(-Infinity) |\n| 1（非无穷大，非零）                   | \"1\"                                            |          | true   | newNumber(1)         |\n| {}（任意对象）                        | 详见下方                                       | 详见下方 | true   |                      |\n| []（任意数组）                        | \"\"                                             | 0        | true   |                      |\n| [9]（1 个数字元素）                   | \"9\"                                            | 9        | true   |                      |\n| ['a']（其他数组）                     | 使用`join()`方法（默认用逗号连接）             | NaN      | true   |                      |\n| function(){}（任意函数）              | 调用`toString()`方法，通常是转换成源代码字符串 | NaN      | true   |                      |\n\n## 对象如何转换成字符串或数字\n\n1. `toString()`方法：\n    - 调用`toString()`方法，一般是返回`\"[object object]\"`：\n    ```js\n    ;({ x: 1, y: 2 }.toString()) // => \"[object object]\"\n    ```\n    - **数组**是调用`join()`方法：\n    ```js\n    ;[1, 2, 3].toString() // => \"1,2,3\"\n    ```\n    - **函数**则是转换成源代码字符串\n    ```js\n    ;(function (x) {\n        f(x)\n    }.toString()) // => \"function(x){ f(x); }\"\n    ```\n    - **Date 类型**会返回一个可读的日期和时间字符串:\n    ```js\n    new Date(2010, 0, 1).toString() // => \"Fri Jan 01 2010 00:00:00 GMT+0800 (China Standard Time)\"\n    ```\n    - **RegExp 类**则是转换成正则表达式字符串\n    ```js\n    ;/\\d+/g.toString() // => \"/\\\\d+/g\"\n    ```\n2. `valueOf()`方法：\n\n-   如果对象存在任意原始值，默认将对象转换成它的原始值（比如各种原始对象的包装对象）\n-   一般，都是简单的返回对象本身\n-   特殊的是：**Date**类型，日期类的`valueOf()`会返回一个内部表示：从 1970 年 1 月 1 日以来的毫秒数：\n\n```js\nvar d = new Date(2010, 0, 1)\nd.valueOf() // => 1262275200000\n```\n\n3. 对象到字符串的转换步骤：\n   ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-4-18/49990859-file_1492446304461_d920.png)\n\n4. 对象到数字的过程：基本上和上面一致，只不过会先调用`valueOf()`的方法。\n\n## 转换和相等性\n\n1. 用`==`作比较时，为了保持两端的类型一致，会做一些类型转换\n2. 用`===`作比较时，并不会做任何类型转换\n3. 在做转换的时候，一个值能转换成另一个值，并不意味着这两个值相等\n\n### `===`和`==`\n\n#### `===`严格相等\n\n1. 不相等的情况：\n    - 两个值类型不同\n    - 其中一个值为`NaN`或者两个都为`NaN`（需要强调：**`NaN`和任何值都不相等，包括其本身。可以用`x!==x`来判断 x 是否为`NaN`**)。\n2. 相等的情况\n    - 都是`null`或者都是`undefined`\n    - 两个值为数字，且数值相等（包括 0 和-0 的情况）\n    - 两个值都为布尔值，且都是`true`或`false`\n    - 两个值都是字符串，且它们长度一致，对应位上的值都相等\n    - 两个值都是引用值，且他们指向同一个对象。数组或函数\n\n#### `==`相等\n\n1. 两个值类型相同，和严格相等的比较规则一样，即它们严格相等时，才会想等。\n2. 两个值类型不同：\n    - 一个是`null`，一个是`undefined`，认为其相等\n    - 如果一个值是数字，一个是字符串，则会**先将字符串转换成数字**,然后用转换后的值进行比较\n    - 如果一个值是`true`，则将其转换成 1 再比较；如果是`false`，则将其转换成 0\n    - 对象和数字或字符串的比较，遵循上文的规则将对象转换成原始值再进行比较（除了日期类以外，都是先用`valueOf()`再用`toString()`）\n3. 小例子：`\"1\" == true`，答案是相等的，分成两步：一是将`true`转换成`1`；而是将`\"1\"`转换成`1`。\n\n## 显式类型转换\n\n1. 除了`null`和`undefined`之外的任何值都有`toString()`方法\n2. **数字转字符串**：\n    - `Number`的`toString()`的方法可以设置基数，表示转换结果的进制：\n    ```js\n    var n = 17\n    binary_string = n.toString()\n    binary_string = n.toString(2) // Evaluates to \"10001\"\n    octal_string = \"0\" + n.toString(8) // Evaluates to \"021\"\n    hex_string = \"0x\" + n.toString(16) // Evaluates to \"0x11\"\n    ```\n    - `toFixed()`, `toExponential()`和`toPrecision()`，用来控制输出的小数点位置和有效位数：\n    ```js\n    var n = 123456.789\n    n.toFixed(0) // \"123457\"\n    n.toFixed(2) // \"123456.79\"\n    n.toFixed(5) // \"123456.78900\"\n    n.toExponential(1) // \"1.2e+5\"\n    n.toExponential(3) // \"1.235e+5\"\n    n.toPrecision(4) // \"1.235e+5\"\n    n.toPrecision(7) // \"123456.8\"\n    n.toPrecision(10) // \"123456.7890\"\n    ```\n3. **字符串转数字**：`parseInt`和`parseFloat`（这两个函数都会跳过任意数量的前置空格，尽可能解析更多的数值字符，并忽略后面的内容）\n\n```js\nparseInt(\"3 blind mice\") // => 3\nparseFloat(\" 3.14 meters\") // => 3.14\nparseInt(\"-12.34\") // => -12\nparseInt(\"0xFF\") // => 255\nparseInt(\"0xff\") // => 255\nparseInt(\"-0XFF\") // => -255\nparseFloat(\".1\") // => 0.1\nparseInt(\"0.1\") // => 0\nparseInt(\".1\") // => NaN: integers can't start with \".\"\nparseFloat(\"$72.47\") // => NaN: numbers can't start with \"$\"\n```\n\n其中`parseInt()`还可以设置第二个参数，用来表示第一个参数的进制\n\n```js\nparseInt(\"11\", 2) // => 3 (1*2 + 1)\nparseInt(\"ff\", 16) // => 255 (15*16 + 15)\nparseInt(\"zz\", 36) // => 1295 (35*36 + 35)\nparseInt(\"077\", 8) // => 63 (7*8 + 7)\nparseInt(\"077\", 10) // => 77 (7*10 + 7)\n```\n","tags":["FrontEnd","JavaScript"]},{"title":"CSS@12布局篇","url":"/blog/2017/04/03/2017-04-03 CSS@12布局篇/","content":"\n# 居中布局\n\n## 水平居中\n\n### `table` + `margin`\n\n```css\n.child {\n    display: table; /*可以替换成width=xxx;*/\n    margin: 0 auto;\n}\n```\n\n### `inline-block` + `text-align`\n\n```css\n.parent {\n    text-align: center;\n}\n.child {\n    display: inline-block;\n}\n```\n\n-   优点：兼容性非常好，虽然`inline-block`在 IE6 和 IE7 中不支持，但是可以通过其他的方法来模拟。\n-   缺点：子元素会继承父元素的`text-align:center`，子元素的内容也会是`text-algin:center`的。\n\n`display:table`的元素表现上跟`display:block`比较像，但是它的宽度是根据内容决定的。\n\n-   优点：只要设置 child 即可。`display:table`在 IE8 以上的浏览器都是支持的。\n\n### `absolute` + `transform`\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    left: 50%;\n    transform: translateX(-50%);\n}\n```\n\n-   优点：子元素不会对其他元素产生影响\n-   缺点：兼容性，因为`transform`是 CSS3 新增的。\n\n### `flex` + `justify-content/margin`\n\n```css\n.parent {\n    display: flex;\n    justify-content: center;\n}\n/*.child {\n\tmargin: 0 auto;\n}*/\n```\n\n-   缺点：低版本浏览器的不支持\n\n## 垂直居中\n\n### `table-cell` + `vertical align`\n\n```CSS\n.parent {\n\tdisplay: table-cell; /*父元素变成单元格*/\n\tvertical-align: middle;\n}\n```\n\n### `absolute` + `transform`\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n}\n```\n\n-   缺点：仍旧是兼容性的问题\n\n### `flex` + `align-items`\n\n```css\n.parent {\n    display: flex;\n    align-items: center;\n}\n```\n\n-   缺点：兼容性问题\n\n## 水平和垂直同时居中\n\n### `inline-block` + `text-align` + `table-cell` + `vertical-align`\n\n```css\n.parent {\n    text-align: center;\n    display: table-cell;\n    vertical-align: middle;\n}\n.child {\n    display: inline-block;\n}\n```\n\n### `absolute` + `transform`\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translateX(-50%);\n    transform: translateY(-50%);\n}\n```\n\n### `flex` + `justify-content` + `align-items`\n\n```css\n.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n# 多列布局\n\n## 定宽与自适应\n\n### `float` + `margin`\n\n```CSS\n.left {\n\tfloat: left;\n\twidth: 100px;\n}\n.right {\n\tmargin-left: 120px;\n}\n```\n\n```XML\n<div class=\"parent\">\n\t<div class=\"left\">\n\t\t<p>left</p>\n\t</div>\n\t<div class=\"right\">\n\t\t<p>right</p>\n\t\t<p>right</p>\n\t</div>\n</div>\n```\n\n-   缺点：在 IE6 及以下的浏览器中，因为右边的元素是没有浮动的，而左边的元素是浮动的，会有一个历史遗留的 bug，导致 right 元素的文字会有 3px 的缩进。而且在对右边的元素清除浮动时，也会带来一些问题。于是就有了下面这个方法：\n\n### `float` + `margin` + `(fix)`\n\n```css\n.left {\n    float: left;\n    width: 100px;\n    position: relative; /*解决被覆盖的问题*/\n}\n.right-fix {\n    float: right;\n    width: 100%;\n    margin-left: -100px;\n}\n.right {\n    margin-left: 120px;\n}\n```\n\n```xml\n<div class=\"parent\">\n\t<div class=\"left\">\n\t\t<p>left</p>\n\t</div>\n\t<div class=\"right-fix\">\n\t\t<div class=\"right\">\n\t\t\t<p>right</p>\n\t\t\t<p>right</p>\n\t\t</div>\n\t</div>\n</div>\n```\n\n-   备注：因为右元素的层级高于左元素，右边的元素会遮盖左边的元素，导致某些事件无法被触发，所以需要对左元素设置`position: relative;`。\n-   优点：不会存在 IE6 下那个 3px 的问题，也不会存在清除浮动的问题。\n-   缺点：结构比较复杂一些。\n\n### `float` + `overflow`\n\n```css\n.left {\n    float: left;\n    width: 100px;\n    margin-right: 20px;\n}\n.right {\n    overflow: hidden; /* 会触发BFC模式 */\n}\n```\n\n```xml\n<div class=\"parent\">\n\t<div class=\"left\">\n\t\t<p>left</p>\n\t</div>\n\t<div class=\"right\">\n\t\t<p>right</p>\n\t\t<p>right</p>\n\t</div>\n</div>\n```\n\n-   **BFC**: 块级格式化上下文(Block Formatting Context)，BFC 模式下的元素，该元素中的内容，是和外界的元素完全隔离的，外面的东西不会影响到 BFC 里面的内容。\n-   参考: [CSS 之 BFC 详解](http://www.html-js.com/article/1866), [理解 CSS 中的 BFC(块级可视化上下文)](http://www.jianshu.com/p/fc1d61dace7b)\n\n### `table`\n\n```css\n.parent {\n    display: table;\n    width: 100%; /* table 默认是根据内容宽度来变化的，我们希望其撑满父元素 */\n    table-layout: fixed; /* 1.布局优先 2.加速table渲染 */\n}\n.left,\n.right {\n    display: table-cell; /* 将子元素变成单元格 */\n}\n.left {\n    width: 100px;\n    padding-right: 20px; /* table-cell没法设置margin */\n}\n```\n\n-   备注：table 布局的一个特点是，所有列的宽度之和一定等于总和\n\n### `flex`\n\n```css\n.parent {\n    display: flex;\n}\n.left {\n    width: 100px;\n    margin-right: 20px;\n}\n.right {\n    flex: 1; /* 剩余宽度分配给right */\n}\n```\n\n-   缺点：兼容性问题，flex 在 CSS3 中才被支持；因为自适应带来的性能问题（只能用来做小范围的布局）\n\n## 不定宽与自适应\n\n不定宽指的是：不指定宽度，可以是任意宽度，或者也可以是，宽度是由内容决定的。\n\n### `float` + `margin`\n\n```css\n.left {\n    /* 宽度由内容决定 */\n    float: left;\n    margin-right: 20px;\n}\n.right {\n    overflow: hidden; //block formatting context\n}\n```\n\n### `table`\n\n```css\n.parent {\n    display: table;\n    width: 100%; /* table 默认是根据内容宽度来变化的 */\n    table-layout: fixed; /* 布局优先 加速table渲染 */\n}\n.left,\n.right {\n    display: table-cell;\n}\n.left {\n    width: 0.1%; /* 设置很小的值，就能让其跟随内容变动 */\n    padding-right: 20px; /* table-cell没法设置margin */\n}\n```\n\n### `flex`\n\n```css\n.parent {\n    display: flex;\n}\n.left {\n    margin-right: 20px;\n}\n.right {\n    flex: 1; /* 剩余宽度分配给right */\n}\n```\n\n## 等分布局\n\n### `float`\n\n```CSS\n.parent{\n\tmargin-left: -20px;\n}\n.column{\n\tfloat: left;\n\twidth: 25%;\n\tpadding-left: 20px;\n\tbox-sizing: border-box;\n}\n```\n\n```XML\n<div class=\"parent\">\n\t<div class=\"column\"><p>1</p></div>\n\t<div class=\"column\"><p>2</p></div>\n\t<div class=\"column\"><p>3</p></div>\n\t<div class=\"column\"><p>4</p></div>\n</div>\n```\n\n-   备注：存在的一个问题是，这种方法无法根据列数来变化\n\n### `table`\n\n```CSS\n.parent-fix{\n\tmargin-left: -20px; /* table没有margin　只能转嫁给上一级 */\n}\n.parent{\n\tdisplay: table;\n\twidth: 100%;\n\ttable-layout: fixed; /* 布局优先，单元格宽度默认是平分 */\n}\n.column{\n\tdisplay: table-cell;\n\tpadding-left: 20px;\n}\n```\n\n```XML\n<div class=\"parent-fix\">\n\t<div class=\"parent\">\n\t\t<div class=\"column\"><p>1</p></div>\n\t\t<div class=\"column\"><p>2</p></div>\n\t\t<div class=\"column\"><p>3</p></div>\n\t\t<div class=\"column\"><p>4</p></div>\n\t</div>\n</div>\n```\n\n### `flex`\n\n```CSS\n.parent{\n\tdisplay: flex;\n}\n.column{\n\tflex: 1;\n}\n.column+.column{\n\tmargin-left:20px; /* 自动分配 减去margin-left之后的空间 */\n}\n```\n\n```XML\n<div class=\"parent\">\n\t<div class=\"column\"><p>1</p></div>\n\t<div class=\"column\"><p>2</p></div>\n\t<div class=\"column\"><p>3</p></div>\n\t<div class=\"column\"><p>4</p></div>\n</div>\n```\n\n## 等高布局\n\n同行的多个元素，保持相同高度。\n\n### `table`\n\n```CSS\n.parent {\n\tdisplay: table;\n\twidth: 100%;\n\ttable-layout: fixed;\n}\n.left, .right {\n\tdisplay: table-cell;\n}\n.left {\n\twidth: 100px;\n\tpadding-right: 20px;\n}\n```\n\n```XML\n<div class=\"parent\">\n\t<div class=\"left\">\n\t\t<p>left</p>\n\t</div>\n\t<div class=\"right\">\n\t\t<p>right</p>\n\t\t<p>right</p>\n\t</div>\n</div>\n```\n\n### `flex`\n\n```CSS\n.parent{\n    display: flex;\n}\n.left{\n    margin-right: 20px;\n}\n.right{\n    flex: 1;\n}\n```\n\n-   备注：因为`flex`布局，默认的`align-items`是`stretch`。所以就产生了等高的特性\n\n### `float`\n\n```CSS\n.parent {\n    overflow: hidden;\n}\n.left{\n    padding-bottom: 9999px;\n    margin-bottom:-9999px;\n}\n.left{ /* 宽度由内容决定 */\n\tfloat: left;\n\tmargin-right: 20px;\n}\n.right{\n\toverflow: hidden; /* block formatting context */\n}\n```\n\n# 全屏布局\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-4-11/32024972-file_1491843116217_8c83.png)\n\n## `position`\n\n```XML\n<div class=\"parent\">\n\t<div class=\"top\">top</div>\n\t<div class=\"left\">left</div>\n\t<div class=\"right\"><div class=\"inner\">right</div></div>\n\t<div class=\"bottom\">bottom</div>\n</div>\n```\n\n```CSS\nhtml, body, .parent\n{\n    overflow: hidden;\n\n    height: 100%;\n    margin: 0;\n} /*overflow禁用滚动条*/\nbody\n{\n    color: white;\n}\n.top\n{\n    position: absolute;\n    top: 0;\n    right: 0;\n    left: 0;\n    height: 100px;\n    background: blue;\n}\n.left\n{\n    position: absolute;\n    top: 100px;\n    bottom: 50px;\n    left: 0;\n    width: 200px;\n    background: red;\n}\n.right\n{\n    position: absolute;\n    top: 100px;\n    right: 0;\n    bottom: 50px;\n    left: 200px;\n    overflow: auto;\n    background: pink;\n}\n.right.inner\n{\n    min-height: 1000px;\n}\n.bottom\n{\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    height: 50px;\n    background: black;\n}\n```\n\n## `flex`\n\n```XML\n<div class=\"parent\">\n\t<div class=\"top\">top</div>\n\t<div class=\"middle\">\n\t\t<div class=\"left\">left</div>\n\t\t<div class=\"right\"><div class=\"inner\">right</div></div>\n\t</div>\n\t<div class=\"bottom\">bottom</div>\n</div>\n```\n\n```CSS\nhtml,body,.parent{margin:0; height:100%; overflow:hidden;}\nbody{color: white;}\n.parent{display: flex; flex-direction: column;}\n.top{height:100px; background: blue;}\n.bottom{height:50px; background: black;}\n.middle{flex:1; display:flex;}\n.left{width:200px; background: red;}\n.right{flex: 1; overflow: auto; background:pink;}\n.right .inner{min-height: 1000px;}\n```\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@11弹性布局flex","url":"/blog/2017/01/29/2017-01-29 CSS@11弹性布局flex/","content":"\n# `flex`弹性布局\n\n## 一、弹性布局概念\n\n如果一个元素是弹性布局元素，那么它的子元素都可以认为是一个个充满弹性的弹簧。它们能自由地弹性伸缩，来填充可用空间，或将其收缩来避免溢出。\n\n### 例子：\n\n```css\n.parent {\n    width: 400px;\n    outline: 1px dashed red;\n    display: flex; /*对父元素设置flex布局*/\n}\n.child {\n    flex: 1; /*子元素需要设置“弹性”*/\n    background-color: lightseagreen;\n    border: 2px solid white;\n    color: white;\n    text-align: center;\n}\n```\n\n```xml\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">1</div>\n        <div class=\"child\">2</div>\n        <div class=\"child\">3</div>\n    </div>\n</body>\n```\n\n子元素就会撑满整个父元素：\n\n<div style=\"width: 400px;outline: 1px dashed red;display: flex;margin: 10px auto;\"><div style=\"flex: 1;background-color: lightseagreen;border: 2px solid white;color: white;text-align: center;\">1</div><div style=\"flex: 1;background-color: lightseagreen;border: 2px solid white;color: white;text-align: center;\">2</div><div style=\"flex: 1;background-color: lightseagreen;border: 2px solid white;color: white;text-align: center;\">3</div></div>\n\n### 基本概念\n\n我们把设置为`display:flex`的元素叫做弹性容器（flex container)，而它的所有子元素就自动变成了弹性项目（flex item）。其他属性也一一在图中呈现。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-30/46353145-file_1485748885622_b1c4.png)\n\n## 二、`flex-container`的相关属性\n\n**注意**：该节内容所示属性，都是弹性容器（`flex-container`）的相关属性，不是弹性项目（`flex-item`）的\n\n### `flex-direction`主轴方向\n\n> flex-direction: **row** | row-reverse | column | column-reverse\n\n-   `row`：**默认值**，表示弹性项目（flex item）从左往右排列。\n-   `row-reverse`：表示弹性项目（flex item）从右往左排列。\n-   `column`：表示弹性项目（flex item）从上往下排列。\n-   `column-reverce`：表示弹性项目（flex item）从下往上排列。\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-4/98238970-file_1486220966327_16a43.png)\n\n-   `flex-direction`只改变主轴方向，侧轴方向不变\n\n### `flex-wrap` 换行方式\n\n> flex-wrap:**nowrap** | wrap | wrap-reverse\n\n-   `nowrap`：**默认值**，不换行\n-   `wrap`：沿着侧轴方向换行\n-   `no-wrap`：仍是沿着侧轴方向换行，只不过侧轴方向需要逆置\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/89127756-file_1486225449066_d732.png)\n    或许有人会问，为什么`no-wrap`不能直接解释成：逆着侧轴方向换行？原因在`align-content`这一节会得到解释。\n\n### `flex-flow` 同时设置方向和换行\n\n> flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;\n\n只是`flex-direction`和`flex-wrap`的缩写，默认值是`row nowrap`\n\n### `justify-content` 主轴方向的对齐方式\n\n> justify-content:**flex-start** | flex-end | center | space-between | space-around\n\n-   `flex-start`:默认值，向主轴起点（main start）对齐\n-   `flex-end`：向主轴终点（main end）对齐\n-   `center`：居中对齐\n-   `space-between`：两端对齐\n-   `space-around`：分布对齐（每个 item 都平分所有空隙，所以会发现，两个元素间空隙的宽度会是最左边缝隙的宽度的两倍）\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-4/74515341-file_1486222732549_78b6.png)\n\n### `align-items` 侧轴方向的对齐方式\n\n> align-items：flex-start | flex-end | center | **stretch** | baseline\n\n-   `flex-start`：与侧轴起点（cross start）对齐\n-   `flex-end`：与侧轴终点（cross end）对齐\n-   `center`：居中对齐\n-   `stretch`：**默认值**，如果弹性项目未设置高度，那么其将延伸铺满整个弹性容器\n-   `baseline`：让弹性项目的第一行文字的基线对齐\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/49922052-file_1486224363785_4537.png)\n\n### `align-content` 多行在侧轴方向的对齐方式\n\n> align-content: flex-start | flex-end | center | space-between | space-around | **stretch**\n\n-   `flex-start`：所有行都往侧轴起点（cross start）聚集\n-   `flex-end`：所有行都往侧轴终点（cross end）聚集\n-   `center`：居中对齐\n-   `space-between`：两端对齐\n-   `space-around`：分布对齐\n-   `stretch`：**默认值**，如果项目未设置高度，那么将延伸铺满整个容器\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/92072570-file_1486226129510_e9d2.png)\n\n-   那么，如果对弹性容器设置`flex-wrap：wrap-reverse`会怎么样？\n    我们发现，设置为`flex-start`的这个例子中，两行元素聚集于下端，说明侧轴的起点在下面，正好也恰恰说明了，`wrap-reverse`逆置了整个侧轴，而不是对元素换行的做出规定。\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/2452061-file_1486226179320_d907.png)\n\n## 三、`flex-item`的相关属性\n\n### `order` 排列顺序\n\n> order:&lt;interger&gt;\n\n弹性项目会依照`flex-direction`设定的顺序，并按照`order`从小到大排列\n举例：\n\n```css\n.parent {\n    width: 400px;\n    background-color: #ffcc00;\n    padding: 10px;\n    display: flex;\n    flex-wrap: wrap;\n    margin: 10px;\n}\n.child {\n    width: 50px;\n    height: 50px;\n    background-color: #fd3402;\n    margin: 5px;\n    line-height: 50px;\n    color: white;\n    text-align: center;\n}\n```\n\n```xml\n<body>\n    <div class=\"parent\">\n\t\t<!--对item进行乱序-->\n        <div class=\"child\" style=\"order:4;\">4</div>\n        <div class=\"child\" style=\"order:1;\">1</div>\n        <div class=\"child\" style=\"order:5;\">5</div>\n        <div class=\"child\" style=\"order:2;\">2</div>\n        <div class=\"child\" style=\"order:-1;\">-1</div>\n        <div class=\"child\" style=\"order:3;\">3</div>\n    </div>\n</body>\n```\n\n仍然会按照`order`顺序排列好：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/11769597-file_1486227165614_2df.png)\n\n### `flex-basis` 初始宽高\n\n> flex-basis: **content** | &lt;length&gt;\n\n-   这个属性用来设置元素在主轴方向占据的大小\n-   `content`：**默认值**，基于 flex 的元素自动调整大小（也就是项目本身的大小）\n-   `<length>`：可以设置为和`width`和`height`一样的长度值（px, mm, pt...)或百分比，那么项目将有固定的大小。\n-   当同时设置`width`和`flex-basis`时，后者会覆盖前者\n\n### `flex-grow` 放大比例\n\n> flex-grow:&lt;number&gt(非负值);\n\n-   当弹性容器有剩余的空间时，`flex-grow`会按照比例为弹性项目分配剩余空间，这也就变成了一个放大效果，而`flex-grow`规定的，就是放大效果。\n\n-   默认值是 0，下面就是默认的分配情况：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/52349159-file_1486227621289_5082.png)\n\n-   当为所有弹性项目都设置`flex-grow:1;`之后：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/30839986-file_1486227710080_17083.png)\n\n-   如果给项目 2，设置`flex-grow:2;`而其他项目都是 1，那么项目 2 分配到的剩余空间就会是其他项目的两倍：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/13034584-file_1486227814361_b1b3.png)\n\n-   有一个计算公式可以计算一个项目能分配到的剩余空间（项目的宽度 = 基础宽度 + 该项目的 flex-grow 值 / 同一行或列（也就是同一主轴）所有项目的 flex-grow 值的和 \\* 容器的剩余宽度）：\n    `item's length = flex-basis + flex-grow / sum(flex-grow) * remain`\n\n-   例子：\n\n```css\n.parent {\n    width: 250px;\n    background-color: #ffcc00;\n    padding: 10px;\n    display: flex;\n    flex-wrap: wrap;\n}\n.child {\n    width: 60px;\n    height: 50px;\n    flex-grow: 1;\n    background-color: #fd3402;\n    margin: 1.25px;\n    line-height: 50px;\n    color: white;\n    font-family: consolas;\n    text-align: center;\n}\n```\n\n```xml\n<div class=\"parent\">\n\t<div class=\"child\" style=\"flex-grow: 1;\">flex:1;</div>\n\t<div class=\"child\" style=\"flex-grow: 2;\">flex:2;</div>\n\t<div class=\"child\" style=\"flex-grow: 1;\">flex:1;</div>\n\t<div class=\"child\" style=\"flex-grow: 2;\">flex:1;</div>\n\t<div class=\"child\" style=\"flex-grow: 3;\">flex:2;</div>\n</div>\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/46240670-file_1486289303987_14b49.png)\n\n### `flex-shrink` 缩小比例\n\n> flex-shrink:&lt;number&gt(非负值);\n\n-   和`flex-grow`刚好相反，`flex-shrink`可以当做是用来分配剩余的**负空间**的。\n\n-   当一行弹性项目超出了弹性容器的宽度，那么这些超出的宽度就是所谓的**负空间**，那么`flex-shrink`就会和`flex-grow`类似，来分配这些**负空间**，从而让弹性项目仍旧撑满整个容器，而不溢出来。这就好比把元素缩小了。\n\n-   和`flex-grow`不同，`flex-shrink`的默认值是 1，所以不用设置`flex-shrink`也会有缩小效果。\n\n-   同样有一个计算公式可以计算一个项目能分配到的剩余负空间（项目的宽度 = 基础宽度 + 该项目的 flex-shrink 值 / 同一行或列（也就是同一主轴）所有项目的 flex-shrink 值的和 \\* 容器的剩余负宽度）：\n    `item's length = flex-basis + flex-shrink / sum(flex-shrink) * remain`\n\n-   然而，在此时，我发现了一个神奇的现象。当弹性项目的子元素，在主轴方向的尺寸，超过了该弹性项目，就会导致这个弹性项目的`flex-shrink`失效。当然解决方案也已经列在注释中：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/80372936-file_1486300825907_1e48.png)\n\n```css\n.parent {\n    width: 250px;\n    background-color: #ffcc00;\n    padding: 10px;\n    display: flex;\n}\n.child {\n    width: 70px;\n    height: 200px;\n    background-color: #fd3402;\n    margin: 5px;\n    font-family: consolas;\n    text-align: center;\n    /*min-width:0;*/ /*解决方案一*/\n    /*overflow-x: hidden;*/ /*解决方案二*/\n    /*word-break:break-all;*/ /*针对长文字的解决方案*/\n}\n```\n\n```xml\n<div class=\"parent\">\n\t<div class=\"child\"></div>\n\t<div class=\"child\"></div>\n\t<div class=\"child\"><div style='width:200px;height:50px;background-color: white;'></div></div>\n\t<div class=\"child\"></div>\n</div>\n```\n\n### `flex`\n\n> flex: [&lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt;] | none\n\n-   `flex`是`flex-grow`, `flex-shrink`和`flex-basis`的简写。\n-   `flex-shrink`和`flex-basis`是可选值。\n-   默认值是：`0 0 auto`;\n\n### `align-self` 单个项目在侧轴上的对齐方式\n\n> align-self: **auto** | flex-start | flex-end | center | baseline | stretch;\n\n-   设置单个项目在侧轴上的对齐方式，会覆盖`align-items`\n-   默认是`auto`，表示继承父元素的`align-items`，如果没有父元素，就等同于`stretch`\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-2-5/26112348-file_1486301845816_ad8e.png)\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"杂谈：《编写可读代码的艺术》阅读笔记（三）","url":"/blog/2017/01/26/2017-01-26 《编写可读代码的艺术》阅读笔记（三） /","content":"\n# 重新组织代码\n\n## 一、抽取不相关的子问题\n\n> 建议：**积极发现并抽取出不相关的子逻辑**\n>\n> -   看看某个函数或代码块，问问自己，这段代码高层次目标是什么？\n> -   对每一行代码，问问自己，它是直接为了目标而工作吗？这段代码的高层次目标是什么？\n> -   如果有足够的行数在解决不相关的子问题，抽取代码到独立的函数中\n\n-   例子，计算地球上两个点的最近距离\n\n```js\n// Return which element of 'array' is closest to the given latitude/longitude.\n// Models the Earth as a perfect sphere.\nvar findClosestLocation = function (lat, lng, array) {\n    var closest\n    var closest_dist = Number.MAX_VALUE\n    for (var i = 0; i < array.length; i += 1) {\n        // Convert both points to radians.\n        var lat_rad = radians(lat)\n        var lng_rad = radians(lng)\n        var lat2_rad = radians(array[i].latitude)\n        var lng2_rad = radians(array[i].longitude)\n        // Use the \"Spherical Law of Cosines\" formula.\n        var dist = Math.acos(\n            Math.sin(lat_rad) * Math.sin(lat2_rad) +\n                Math.cos(lat_rad) *\n                    Math.cos(lat2_rad) *\n                    Math.cos(lng2_rad - lng_rad)\n        )\n        if (dist < closest_dist) {\n            closest = array[i]\n            closest_dist = dist\n        }\n    }\n    return closest\n}\n```\n\n循环中大部分代码都在解决一个和高层问题无关的子问题：“计算两个坐标之间的球面距离”，所以我们将它抽离出来：\n\n```js\nvar spherical_distance = function (lat1, lng1, lat2, lng2) {\n    var lat1_rad = radians(lat1)\n    var lng1_rad = radians(lng1)\n    var lat2_rad = radians(lat2)\n    var lng2_rad = radians(lng2)\n    // Use the \"Spherical Law of Cosines\" formula.\n    return Math.acos(\n        Math.sin(lat1_rad) * Math.sin(lat2_rad) +\n            Math.cos(lat1_rad) *\n                Math.cos(lat2_rad) *\n                Math.cos(lng2_rad - lng1_rad)\n    )\n}\n```\n\n然后函数就变成了，可读性更高，还能做单独测试：\n\n```js\nvar findClosestLocation = function (lat, lng, array) {\n    var closest\n    var closest_dist = Number.MAX_VALUE\n    for (var i = 0; i < array.length; i += 1) {\n        var dist = spherical_distance(\n            lat,\n            lng,\n            array[i].latitude,\n            array[i].longitude\n        )\n        if (dist < closest_dist) {\n            closest = array[i]\n            closest_dist = dist\n        }\n    }\n    return closest\n}\n```\n\n值得明白的一点是，例子中并不是在讲怎么架构，不是从**如何解耦**出发的，而是从如何抽取**不相关的问题**出发的。虽然殊途同归，但是思路是不一样的。\n\n-   意料之外的好处：当抽取不相关子问题成为独立的代码之后，改进这些独立的代码变得更加容易。\n\n-   **过犹不及**：过多的抽离子问题，会让整个代码引入过多的小函数，阅读者就需要在不同的函数之间反复跳跃，降低可读性。\n\n## 二、一次只做一件事\n\n> **建议**：\n>\n> 1. 列出代码所做的所有任务\n> 2. 尽量把任务拆分到不同的函数中，或者至少是代码中不同的段落中\n\n## 三、把想法变代码\n\n> **建议**：\n>\n> 1. 像对着一个同事一样用自然语言描述代码要做什么\n> 2. 注意描述中所用的关键词和短语\n> 3. 写出与描述所匹配的代码\n\n### 清楚描述逻辑\n\n在写代码之前，先清晰的描述（写）出你的逻辑，再进行 coding，这样有助于你写出更好的代码。\n这不就是传说中的“小黄鸭 debug 术”吗！\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-27/76690189-file_1485499018366_468c.png)\n下面这个例子就说明了如何用清晰的逻辑重构代码：\n\n```php\n$is_admin = is_admin_request();\nif ($document) {\n\tif (!$is_admin && ($document['username'] != $_SESSION['username'])) {\n\t\treturn not_authorized();\n\t}\n} else {\n\tif (!$is_admin) {\n\t\treturn not_authorized();\n\t}\n}\n// continue rendering the page ..\n```\n\n可以将上述逻辑表述为：\n\n```js\n// 以下两种情况之一，你就能获得授权：\n// 1. 你是管理员\n// 2. 你拥有当前文档（如果有当前文档的话）\n// 否则，无法授权与你\n```\n\n于是，代码可以重构为：\n\n```php\nif (is_admin_request()) {\n\t// authorized\n} else if ($document && ($document['username'] == $_SESSION['username'])) {\n\t// authorized\n} else {\n\treturn not_authorized();\n}\n// continue rendering the page ...\n```\n\n## 三、少写代码\n\n> 最好读的代码就是：没有代码\n\n### 质疑和拆分需求\n\n并不是所有程序都要运行得快，100%准确，并且能处理所有的输入。可以根据实际需要，拆分并且削减一部分需求。\n\n### 保持小的代码库\n\n**建议**：\n\n-   代码复用，创建更多可复用的“工具”代码\n-   减少无用的代码或没有用的功能\n-   让代码保持分开的子项目状态\n\n### 熟悉你周边的库\n\n建议：**每个一段时间，花 15 分钟来阅读标准库中的所有函数/模块/类型的名字**，用以了解有什么可以用，下次写新的代码时就会想到。\n","tags":["Coding","Reading"]},{"title":"杂谈：《编写可读代码的艺术》阅读笔记（二）","url":"/blog/2017/01/26/2017-01-26 《编写可读代码的艺术》阅读笔记（二）/","content":"\n# 简化循环和逻辑\n\n## 一、流程控制\n\n### 1. 判断\n\n#### 1）条件判断中的参数顺序\n\n| 比较的左侧                         | 比较的右侧                             |\n| ---------------------------------- | -------------------------------------- |\n| “被问询的”表达式，更倾向于不断变化 | 用来做比较的表达式，它的值更倾向于常量 |\n\n**PS**：但是反着写，能够避免掉那种`if(obj = NULL)`的错误，俗称“尤达表示法”。\n\n#### 2）if/else 语句块的顺序\n\n三个倾向性：\n\n1. 倾向于先处理正逻辑，再处理负逻辑\n2. 倾向于先处理掉简单情况\n3. 倾向于先处理掉有趣的或者可疑的状况\n\n#### 3）?:条件表达式\n\n- 并不是很推荐这种写法哈哈哈哈，一旦写了长表达式，就会很难理解\n\n### 2. 循环\n\n#### 1）避免使用 do/while 循环\n\n通常，逻辑条件应该出现在它们所“保护”的代码前。而且`do/while`循环中的`continue`会产生歧义。\n\n#### 2）最小化嵌套\n\n深嵌套会让读者的“思维栈”太深，可以通过提早返回来减少嵌套，可以将代码进行如下变化：\n\n```js\nif (a) {\n  if (b) {\n    // do something 1\n    return;\n  }\n  // do something 2\n}\n// do something 3\nreturn;\n```\n\n```js\nif (!a) {\n  // do something 3\n  return;\n}\nif (b) {\n  // do something 1\n  return;\n}\n// do something 2\nreturn;\n```\n\n## 二、长表达式拆分\n\n- 方法一：**增加变量**：总结为一句话，**用额外的变量，来代替一个长表达式**，例子：\n\n  ```js\n  // 解释变量\n  if (line.split(\":\")[0].strip() == \"root\") {\n    // ...\n  }\n  // **************************************\n  //                    ↓\n  // **************************************\n  var userName = line.split(\":\")[0].strip();\n  if (username == \"root\") {\n    // ...\n  }\n  ```\n\n  ```js\n  // 总结变量\n  if (request.user.id == document.owner_id) {\n    // ...\n  }\n  // ...\n  if (request.user.id != document.owner_id) {\n    // ...\n  }\n  // ***********************************************************\n  //                              ↓\n  // ************************************************************\n  var user_owns_document = request.user.id == document.owner_id;\n  if (user_owns_document) {\n    // ...\n  }\n  if (!user_owns_document) {\n    // ...\n  }\n  ```\n\n- 方法二：**使用德摩根定律**\n\n  > - !(a || b || c) <=> (!a) && (!b) && (!c)\n  > - !(a && b && c) <=> (!a) || (!b) || (!c)\n\n- 方法三：**不要滥用短路逻辑**：短路逻辑可能会增加代码的理解难度。\n\n- 方法四：**找到更优雅的方式**，一个理念是：\n\n  > 开始还很简单的问题变得非常令人费解，通常预示着一中更简单的方法。\n\n- 方法五：拆分巨大的语句，把一样的表达式抽离出来作为函数开头的总结变量\n  > - DRY：Don't Repeat Yourself.\n\n## 三、变量\n\n关于变量的三个问题：\n\n> - 变量越多，就越难全部追踪\n> - 变量作用域越大，就需要跟踪的越久\n> - 变量改变越频繁，就越难追踪它的当前值\n\n### 1）减少变量\n\n针对第一个问题，我们提出了以下几种方案，可以去掉以下几种不必要的变量：\n\n- **没有价值的临时变量**：举个例子：`now = datetime.datetime.now()`，一般这种变量有以下几种特点，\n\n  - 没有拆分任何临时变量\n  - 没有做过多澄清，`datetime.now()`已经足够清晰\n  - 只用一次（或少数几次），没有压缩任何冗余的代码\n\n- **中间结果**：下面例子中，`index_to_remove`可以被移除，那些为了保存临时结果，用完即丢的变量，可以考虑丢弃：\n\n```js\nvar remove_one = function (array, value_to_remove) {\n  var index_to_remove = null;\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] == value_to_remove) {\n      index_to_remove = i;\n      break;\n    }\n  }\n  if (index_to_remove !== null) {\n    array.splice(index_to_remove, 1);\n  }\n};\n// ***********************************************\n//                      ↓\n// ***********************************************\nvar remove_one = function (array, value_to_remove) {\n  var index_to_remove = null;\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] == value_to_remove) {\n      array.splice(i, 1);\n      return;\n    }\n  }\n};\n```\n\n- **流程控制变量**：用来控制流程的变量，往往不包含任何程序内的数据，能通过结构化编程来消除。\n\n### 2）缩小变量作用域\n\n> 让你的变量对尽量少的代码行可见。\n\n- 一个做法就是让变量“降级”，尽量降低作用域，比如\n\n  - 让**类成员变量**降级成某个**成员函数中的局部变量**\n  - 运用好`C++`的块级作用域，那些仅仅用来当做判断条件的变量，可以放在`if`语句中定义：\n\n  ```c\n  PaymentInfo* info = database.ReadPaymentInfo()\n  if(info){\n  \t// ...\n  }\n  // ************************************************\n  //                        ↓\n  // ************************************************\n  if(PaymentInfo* info = database.ReadPaymentInfo()){\n  \t// ...\n  }\n  ```\n\n  - 用`JavaScript`的立即执行函数制造封闭的作用域\n\n- 定义下移：将定义移动到使用它之前，增加可读性\n\n### 3）只写一次的变量更好\n\n尽量减少对变量的赋值的语句，有助于提高可读性。\n","tags":["Coding","Reading"]},{"title":"杂谈：《编写可读代码的艺术》阅读笔记（一）","url":"/blog/2017/01/24/2017-01-24 《编写可读代码的艺术》阅读笔记（一）/","content":"\n# 表面层次的改进\n\n## 一、命名\n\n### 1. 把信息装到名字里\n\n-   **选择更专业的词**：就是要寻找更有表现力，更精准的词汇来进行命名，文章给出了一个可替换单词的表格：\n<div class=\"table-responsive\"><table class=\"table\"><thead><tr><th style=\"text-align:center\">单词</th><th style=\"text-align:left\">替换选择</th></tr></thead><tbody><tr><td style=\"text-align:center\">send</td><td style=\"text-align:left\">deliver, dispatch, announce, distribute, route</td></tr><tr><td style=\"text-align:center\">find</td><td style=\"text-align:left\">search, extract, locate, recover</td></tr><tr><td style=\"text-align:center\">start</td><td style=\"text-align:left\">launch, create, begin, open</td></tr><tr><td style=\"text-align:center\">make</td><td style=\"text-align:left\">create, set up, build, generate, compose, add, new</td></tr></tbody></table></div>\n\n-   **避免空泛的词汇**：比如`tmp`, `retval`这样的单词，除非有特殊的理由，比如：`tmp`这个名字之应用于**短期存在**且**临时性为其主要存在性素**的变量。\n    循环迭代器中的`i`, `j`, `k`也有更好的选择，比如`user_i`能更好的表示这个循环索引是用来指示 user 的。\n\n-   **使用具体的名字来替代抽象的名字**：想要检测服务是否可以监听某个端口，就不要用`ServerCanStart()`这样的名词，最好用`CanListenOnPort()`这样更加具体描述这件事情的名称。\n\n-   **给变量名带上重要的细节**：\n\n    -   对单位，编码方式等等进行一个解释，比如给带单位的变量，在后面带上单位，比如值为毫秒的变量后面加上`_ms`；还可以为未处理的数据前面加上一个`raw_`\n\n-   **为作用域大的名字采用更长的名字**：不应该把那些只有一两个字母的名字用在很大的作用域下；相对的，在小的作用域里面，就不要用太长的名字……\n\n-   **有目的地使用大小写、下划线等**：比如 JavaScript 中，就建议，构造函数应该首字母大写，而普通的函数则是小写。献上：[JavaScript 编码规范](http://www.cnblogs.com/hustskyking/p/javascript-spec.html)\n\n### 2. 不会误解的名字\n\n> 关键思想：多问自己几遍：“这个名字会被别人解读成其他的含义吗？”，要相信，一个好名字是不会被误解的\n\n-   举例：用`filter()`时，阅读者并不知道，是要将特定目标从里面挑选出来还是过滤掉。\n\n#### 推荐策略\n\n-   **用 min 和 max 来表示（包含）极限**：如果想要表示极限，而且这个极限是在取值范围内的，比如两位正整数，用`[10,99]`来表示，那么我们就可以用`max_XXXX`表示最大的极限 99，用`min_XXXX`表示最小的极限 10.\n-   **用 first 和 last 表示包含的范围**：`[first, last]`\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-24/90287919-file_1485239528460_aedb.png)\n\n-   **用 begin 和 end 表示包含/排除范围**：`[begin, end)`\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-24/42295356-file_1485239629710_cb22.png)\n\n-   **明确的布尔值命名**：用 is, has, can, should 这样的词来使得布尔值更明确，避免使用反义名词\n\n-   **要和使用者的期望匹配**：用户会期望`get()`或者`size()`是轻量级的方法。可以用用`computer*()`来代替复杂度很高的`get*()`操作，用`countSize()`或者`countElements()`来替代复杂度很高的`size()`等等\n    -   例子：使用者很容易把`get*()`理解成一个很轻量的操作，他们可能认为`get*()`的时间复杂度只有`O(1)`？比如，`getMean()`这个函数是用来遍历，计算出平均值，但是使用者可能就觉得这个计算复杂度会很低，调用它的代价会很小。最好用`computerMean()`来代替它。\n\n## 二、审美\n\n> -   使用一致的布局，让读者很快就习惯这种风格\n> -   让相似的代码看上去相似\n> -   把相关的代码行分组，形成代码块\n\n## 三、注释\n\n> 注释的目的是让读者了解的和作者一样多\n\n### 1. 写什么样的注释\n\n#### 1）不用写注释的地方\n\n> -   不要为那些从代码本身就能快速推断的事实写注释\n> -   “好代码>好注释+坏代码”——不要用注释来粉饰那些烂代码和烂命名\n\n#### 2）需要写注释的地方\n\n-   **用注释记录思想**：\n\n    -   **“导演评论”**：可以加入一些注释，用来解释这段代码是如何运行的，或者评论这段代码\n    -   **“记录瑕疵”**：可以记录一些代码中的瑕疵，甚至可以利用某些标记，比如\n    <div class=\"table-responsive\"><table class=\"table\"><thead><tr><th>标记</th><th>意义</th></tr></thead><tbody><tr><td>TODO</td><td>我还有没处理的事情</td></tr><tr><td>FIXME</td><td>已知的无法运行的代码</td></tr><tr><td>HACK</td><td>对一个问题不得不采用比较粗糙的解决方案</td></tr><tr><td>XXX</td><td>危险！这里有重要问题</td></tr></tbody></table></div>\n\n    -   **“常量注释”**：利用注释来解释为什么这个常量是这个值\n\n-   **站在读者的角度**\n    -   为**意料之中的提问**写上注释：比如为什么这里要这么实现？\n    -   为**意料之外的行为**写上注释：比如公布可能存在的陷阱：这个函数在某种情况下可能会存在问题\n    -   **全局观注释**：用来解释所有的部分是如何一起工作的，比如，类之间如何交互，数据如何在系统中流动，入口在哪里...比如：\n    ```js\n    // 这个文件包含了一些辅助函数，为我们的文件系统提供了更便利的接口\n    // 它处理了文件权限及其他基本的细节\n    ```\n    -   **总结性注释**：用来总结前面的代码块，使读者不至于迷失在细节中\n\n### 2. 写言简意赅的注释\n\n> 注释应当有很高的信息/空间率\n\n-   让注释保持紧凑\n\n-   避免使用不明确的代词（如，it，this 等等）\n\n-   润色粗糙的句子\n\n-   精确地描述函数的行为\n\n    -   比如文件中只包含`hello\\n`这段文字，究竟认为是一行还是认为两行，所以利用“`//计算文件包含多少行（\\n）`”来代替“`//返回文件的行数`”会更精准\n\n-   用输入输出举例来说明特别情况，举例：\n\n```java\n//Examle: Strip(\"abba/a/ba\", \"ab\") returns \"/a/\"\nString Strip(String src, String chars) {...}\n```\n\n-   声明代码的意图：更高层次的意图，而不仅仅是这段代码干了什么。\n\n    -   比如注释：`//将价格从高到低排列`，而不仅仅注释说明：`// 反向遍历队列`\n\n-   嵌入注释来帮助理解参数含义：\n\n```C\nvoid Conect(int timeout, bool use_encryption) { ... }\n// Call the function with commented parameters\nConnect(/* timeout_ms = */ 10, /* use_encryption = */ false);\n```\n\n-   采用信息含量高的词汇\n","tags":["Coding","Reading"]},{"title":"CSS@10布局（下）：float","url":"/blog/2017/01/14/2017-01-14 CSS@10布局（下）：float/","content":"\n# CSS 布局（下）：`float`\n\n## `float`浮动布局\n\n顾名思义，`float`浮动布局的意思就是，元素会浮动起来，会出现类似脱离文档流的行为。具体见例子：\n\n<div style=\"width: 200px;height: 200px;background-color: pink;color: white;font-size: 12px;font-family: 'Microsoft yahei';margin:0 auto;\"><div style='width: 100px;height: 60px;background-color: lightseagreen;float: left;line-height: 60px;text-align: center;color: white;font-size: 12px;font-family:'Microsoft yahei';'>我是浮动的元素</div>我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本，我是正常的文本。</div>\n\n### 语法规则\n\n> <span>float：left|right<span style=\"color: #ccc;\">|none|inherit</span></span>\n\n-   `float`一般常用的两个属性值是`left`和`right`，分别表示向左浮动和向右浮动。\n\n### 一般特性\n\n> -   默认宽度（高度）是内容宽度（高度）\n> -   向指定方向一直移动\n> -   半脱离文档流：对元素，是脱离文档流的；对所有内容，在文档流中\n> -   float 的元素在同一文档流中\n\n**逐一解释**：\n\n-   **默认宽度（高度）是内容宽度（高度）**：在不对浮动元素设置宽高，那么，元素的宽高就是内容的宽高。\n\n-   **向指定方向移动**：这个很容易理解，就是按照`float`元素的值的方向进行移动。\n    有一点值得注意的是：多个兄弟元素都为浮动元素时，并且它们的浮动方向一致时，它们是按照队列的方式进行浮动的。\n    比如下面这个例子中，先向右浮动的“浮动元素 1”也就理所应当的浮动到最右边，紧接着是“浮动元素 2”和“浮动元素 3”\n\n```xml\n<div style=\"width: 100%;\">\n\t<div class=\"float-right\">浮动元素1</div>\n\t<div class=\"float-right\">浮动元素2</div>\n\t<div class=\"float-right\">浮动元素3</div>\n</div>\n```\n\n<div style=\"width: 100%;\"><div style=\"float:right;background-color: lightblue;border: 5px solid white;\">浮动元素1</div><div style=\"float:right;background-color: lightblue;border: 5px solid white;\">浮动元素2</div><div style=\"float:right;background-color: lightblue;border: 5px solid white;\">浮动元素3</div>\n</div>\n\n-   **脱离文档流**：指的是，对元素设置`float`属性后，元素就不再占据原有的位置。如下图动画演示，元素从普通元素变成一个浮动元素的过程：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/36797617-file_1485155013147_88f4.gif)\n    源代码（设置成浮动元素后的）：\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n    div{\n        line-height: 50px;\n        font-family: \"Microsoft yahei\";\n        color: white;\n        border-top: 5px solid white;\n        border-bottom: 5px solid white;\n    }\n    .parent {\n        width: 200px;\n    }\n    .element {\n        background-color: lightblue;\n    }\n    .float {\n\t\tfloat：right;\n        background-color: pink;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <div class=\"element\">普通元素</div>\n        <div class=\"float\">浮动元素</div>\n        <div class=\"element\">普通元素</div>\n    </div>\n</body>\n</html>\n```\n\n-   **半脱离文档流**：一个浮动的元素，对于其兄弟元素而言，的确已经不再占据空间，就如上面所示。\n    请看下面这段代码：\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n    div{\n        line-height: 50px;\n        font-family: \"Microsoft yahei\";\n        font-size: 10px;\n        color: white;\n    }\n    .parent {\n        width: 300px;\n    }\n    .element {\n        background-color: lightblue;\n        outline: 1px dashed red;\n    }\n    .float {\n        float: left;\n        background-color: pink;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <div class=\"float\">浮动元素</div>\n        <div class=\"element\">我是普通元素！我是普通元素！</div>\n    </div>\n</body>\n</html>\n```\n\n我们会以为，上面的代码大概会产生这样的效果：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/45895832-file_1485158182308_bd1.png)\n但是，事实上，效果是像下面这样的，上面的效果，是利用`position:absolute`实现的\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/80236331-file_1485158235226_ed22.png)\n我们发现，浮动元素，对于其兄弟元素的**内容（文字）**（或者父元素的内容）而言，还是会占据空间，会把这些**内容（文字）**挤到右边去，并不是完全脱离文档流的。但是对于这个兄弟元素本身，并没有占据空间，而是浮在这个元素上方。这个兄弟元素还是占据 100%的大小（红色虚线框表示的地方）。\n\n-   **float 的元素在同一文档流中**：在解释**按照队列顺序进行浮动**这一点时，我们已经看到，这些浮动元素之间，互相是会占据一定位置的，也就是说他们是处于同一文档流中的。\n\n## `clear`清除浮动\n\n### 前情提要\n\n`float`元素，因为其脱离文档流的关系，往往会超出父元素，进而影响到其他元素。比如下面这段代码：\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>clear</title>\n    <style>\n    body {\n        width: 400px;\n        line-height: 1.6;\n        font-family: 'Microsoft yahei';\n        color: white;\n    }\n    .parent {\n        padding: 5px 0;\n        margin-bottom: 10px;\n        background-color: pink;\n    }\n    .float-left {\n        margin: auto 5px;\n        float: left;\n        line-height: 80px;\n        background-color: lightblue;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"parent clear\">\n        <div class=\"float-left\">float: left;</div>\n        你们有一个好，全世界跑到什么地方，你们比其他的西方记者啊，跑得还快。\n    </div>\n</body>\n</html>\n```\n\n或许，我们脑中想象的大概是这个样子的：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/2578475-file_1485164143012_10777.png)\n但事实上，却是这个样子的：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/76766693-file_1485164210453_f7fe.png)\n很明显，我们可以得知，这其实是因为`float`元素脱离文档流所致，因为父元素是`block`元素，默认高度是内容高度，而`float`元素脱离了文档流，不在计算范围内（当然父元素是`inline-block`的时候就不会有这个问题）\n而更严重的问题，`float:left;`的元素，还有可能会影响到不属于同一个父元素的其他元素，比如这样：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/77037993-file_1485164386446_13e6e.png)\n而`clear`属性，就是为了解决这个问题，而生的，目的就是**清除浮动，能让父元素完全包含`float`子元素**，让图二变成图一这种效果。\n\n### 语法规则\n\n> <span>clear:both|left|right<span style=\"color: #ccc;\">|none|inherit</span></span>\n\n-   一般常用的就是`clear:both;`，指两边都不允许有浮动对象\n-   `left`指的是不允许左边有浮动对象\n-   `right`指的是不允许右边有浮动对象\n\n### 具体用法\n\n#### 方法一：增添元素\n\n通过在浮动元素后，增加一个空白元素`<br class=\"clear\">`来清除浮动，具体见案例：\n**未清除浮动前**：\n\n<div style=\"margin:20px auto; width: 400px;padding: 10px;outline: 1px dashed red;\"><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div></div>\n<br/>\n```xml\n<div class=\"parent\">\n\t  <div class=\"float\">float: left</div>\n\t  <div class=\"float\">float: left</div>\n\t  <div class=\"float\">float: left</div>\n</div>\n```\n```css\n.parent {\n\twidth: 400px;\n\tpadding: 10px;\n\toutline: 1px dashed red;\n}\n.float {\n\tfloat: left;\n\twidth: 100px;\n\tline-height: 100px;\n\tmargin: auto 5px;\n\ttext-align: center;\n\tfont-family: 'Microsoft yahei';\n\tcolor: white;\n\tbackground-color: pink;\n}\n```\n在未清除浮动前，我们可以见到如上景象，当我们修改一下HTML标签结构，增加一个元素之后：\n<div style=\"margin:20px auto; width: 400px;padding: 10px;outline: 1px dashed red;\"><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div><div style=\"font-family: 'Microsoft yahei';line-height: 100px;float: left;width: 100px;margin: auto 5px;text-align: center;color: white;background-color: pink;\">float: left</div><br style=\"clear: both;height: 0;overflow: hidden;visibility: hidden;\"></div>\n<br/>\n```xml\n<div class=\"parent\">\n\t<div class=\"float\">float: left</div>\n\t<div class=\"float\">float: left</div>\n\t<div class=\"float\">float: left</div>\n\t<br class=\"clear\">\n</div>\n```\n```css\n.clear{\n\tclear: both;\n\theight: 0;\n\toverflow: hidden;\n\tvisibility: hidden;\n}\n```\n**分析代码**：\n- 我们看到，在HTML结构中，我们增加了一个`<br class=\"clear\">`的元素，这个元素是用来清除浮动的\n- 这个元素是`<br>`标签，当然这和元素标签是什么并没有什么关系，只要是`block`元素即可；或者为之设置一个样式：`display:block`\n- css中，其实有用的代码只有`clear:both`这一行，后面的几行，只是为了让这个元素看不到罢了。\n\n#### 方法二：直接为父元素增加样式\n\n第一种方法的一个弊端是，我们必须要修改 HTML 结构，才能达到清除样式的作用。那么，这种方法，就只要修改 CSS，就能清除浮动。\n\n```css\n.parent:after {\n    content: \".\";\n    display: block;\n    clear: both;\n    height: 0;\n    overflow: hidden;\n    visbility: hidden;\n}\n```\n\n事实上，这段代码其实在父元素最后面增加了一个`'.'`，这个方法其实就是前面的方法的一个简略做法而已。我们发现，dom 树中多了一个`::after`：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-23/53396546-file_1485174286663_ef98.png)\n\n### 总结一下\n\n需要清除浮动的情况，只存在父元素是`block`元素的情况下；\n而在`inline-block`的情况下，是不存在需要清除浮动的情况的。\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@布局（中）：position","url":"/blog/2016/12/31/2016-12-31 CSS@9布局（中）：position/","content":"\n# CSS 布局（中）：position\n\n## `position` 定位方式\n\n### `position:static` 默认定位\n\n默认的定位方式，元素在文档流中，无法用`top`，`right`，`bottom`，`left`进行定位\n\n---\n\n### `position:relative` 相对定位\n\n-   仍在文档流中\n-   参照物为元素本身\n-   相对定位元素层级较高\n\n**解释：**\n\n-   **仍在文档流中**：指的是，这个元素仍然会按照原来的位置占据一定的区域，下面的元素不会因此上来，右边的元素不会因此左移，比如这样：\n<div style=\"margin:10px auto 0; height: 150px; width: 410px;font-family: consolas;\"><div style=\"margin:0 auto;height:150px;width:200px; display: inline-block;\"><div style=\"width: 200px; height: 50px; background-color: gold;\"></div><div style=\"width: 200px; height: 50px; background-color: lightseagreen;color:white; line-height: 50px; text-align: center;\">position: static;</div><div style=\"width: 200px; height: 50px; background-color: pink;\"></div></div> <div style=\"margin:0 auto;height:200px;width:200px; display: inline-block;\"><div style=\"width: 200px; height: 50px; background-color: gold;\"></div><div style=\"width: 200px; height: 50px; background-color: lightseagreen; position: relative; left: 10px; top: 10px;color:white; line-height: 50px; text-align: center;\">position: relative;</div><div style=\"width: 200px; height: 50px; background-color: pink;\"></div></div></div></div>\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n    .grandparent {\n        margin: 10px auto 0;\n        height: 150px;\n        width: 410px;\n        font-family: consolas;\n    }\n    .parent {\n        margin: 0 auto;\n        height: 150px;\n        width: 200px;\n        display: inline-block;\n    }\n    .element {\n        width: 200px;\n        height: 50px;\n    }\n    .first {\n        background-color: gold;\n    }\n    .second {\n        background-color: lightseagreen;\n        color: white;\n        line-height: 50px;\n        text-align: center;\n    }\n    .third {\n        background-color: pink;\n    }\n    .relative {\n        position: relative;\n        left: 10px;\n        top: 10px;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"grandparent\">\n        <div class=\"parent\">\n            <div class=\"element first\"></div>\n            <div class=\"element second\">position: static;</div>\n            <div class=\"element third\"></div>\n        </div>\n        <div class=\"parent\">\n            <div class=\"element first\"></div>\n            <div class=\"element second relative\">position: relative;</div>\n            <div class=\"element third\"></div>\n        </div>\n    </div>\n    </div>\n</body>\n</html>\n```\n\n-   **参照物为元素本身**：也就是，元素通过`top`,`left`等定位偏移属性，其位移的原点，是元素本来的位置。比如上面右边的，其 CSS 样式是这样的，向右和向下偏移了`10px`：\n\n```css\n.second-child {\n    width: 200px;\n    height: 50px;\n    background-color: lightseagreen;\n    position: relative;\n    left: 10px;\n    top: 10px;\n    color: white;\n    line-height: 50px;\n    text-align: center;\n}\n```\n\n-   **相对定位元素层级较高**： 设置了`position`的元素会比未设置的元素层级要高。可以这么理解，设置了`position`视作一类，没有设置的视作一类。他们分别计算层级，而前者一定高于后者。\n<div style=\"position: relative; z-index: 10;\"><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;position: absolute;background-color: pink;\">absolute</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;position: relative;left: 100px;top: 100px;background-color: lightblue;\">relative</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;\">default</div></div>\n<div style=\"position: relative; z-index: 1;\"><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;position: absolute;background-color: pink;\">absolute</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;position: relative;left: 100px;top:0;background-color: lightblue;\">relative</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;\">default</div></div>\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<style type=\"text/css\">\n\t\t.element{\n\t\t\tdisplay: inline-block;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tborder: 3px solid white;\n\t\t\tbackground-color: lightseagreen;\n\t\t\tcolor: white;\n\t\t\ttext-align: center;\n\t\t\tline-height: 200px;\n\t\t\tfont-family: consolas;\n\t\t\tfont-size: 24px;\n\t\t}\n\t\t.absolute{\n\t\t\tposition: absolute;\n\t\t\tbackground-color: pink;\n\t\t}\n\t\t.relative{\n\t\t\tposition: relative;\n\t\t\tleft: 100px;\n\t\t\ttop: 100px;\n\t\t\tbackground-color: lightblue;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div style=\"position: relative; z-index: 10;\">\n\t\t<div class=\"element absolute\">absolute</div>\n\t\t<div class=\"element relative\">relative</div>\n\t\t<div class=\"element default\">default</div>\n\t</div>\n\t<div style=\"position: relative; z-index: 1;\">\n\t\t<div class=\"element absolute\">absolute</div>\n\t\t<div class=\"element relative\" style=\"top: 0;\">relative</div>\n\t\t<div class=\"element default\">default</div>\n\t</div>\n</body>\n</html>\n```\n\n你会发现这段代码的效果里： - 第一行中`relative`的元素覆盖在了它后面的`default`元素上，因为`default`元素没有设置`position` - 第一行的`relative`元素还覆盖了第二行的`relative`元素，是因为它们父元素的`z-index`值的关系。\n\n### `position: absolute` 绝对定位\n\n-   脱离文档流（这个元素脱离了文档，浮出文档）\n-   参照物为第一个定位祖先/根元素（也就是 html 元素）\n-   默认宽度为内容宽度\n\n**解释：**\n\n-   **脱离文档流**：意思就是，这个元素不再占用正常文档流中的空间，且定位方法也和一般元素不一样。比如下图中：`abosolute`的元素并没有占据文档的位置，而是浮在了上面，因为它脱离了文档流。具体原因会在下面讲到：\n<div style=\"position: relative; margin:0 auto;width:420px;\"><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;\">default</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;position: absolute;background-color: pink;width:120px;height: 80px;line-height: 80px;\">absolute</div><div style=\"display: inline-block;width: 200px;height: 200px;border: 3px solid white;background-color: lightseagreen;color: white;text-align: center;line-height: 200px;font-family: consolas;font-size: 24px;\">default</div></div>\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<style type=\"text/css\">\n\t\t.parent{\n\t\t\tposition: relative;\n\t\t\tmargin: 0 auto; /*为了居中*/\n\t\t\twidth: 420px;\n\t\t}\n\t\t.element{\n\t\t\tdisplay: inline-block;\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tborder: 3px solid white;\n\t\t\tbackground-color: lightseagreen;\n\t\t\tcolor: white;\n\t\t\ttext-align: center;\n\t\t\tline-height: 200px;\n\t\t\tfont-family: consolas;\n\t\t\tfont-size: 24px;\n\t\t}\n\t\t.absolute{\n\t\t\tposition: absolute;\n\t\t\tbackground-color: pink;\n\t\t\twidth:120px;\n\t\t\theight: 80px;\n\t\t\tline-height: 80px;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"parent\">\n\t\t<div class=\"element default\">default</div>\n\t\t<div class=\"element absolute\">absolute</div>\n\t\t<div class=\"element default\">default</div>\n\t</div>\n</body>\n</html>\n```\n\n-   **参照物为第一个定位祖先/根元素**：在相对定位元素中，我们提到，`relative`元素的参照物是元素本身，而`absolute`元素的参照物应该是第一个已定位的祖先，如果没有这样的祖先，那么它的参照物就是根元素，也就是`<html>`。那么什么叫做**已定位的祖先**呢，就是它的已经设置了`position`值的祖先元素。\n\n    -   第一点值得注意的是，即便对某个元素设置了`absolute`，如果没有进行定位，它会保持在原来的位置上。\n    -   第二点值得注意的是，默认子元素会被包含在父元素的`content-box`里面，但是`absolute`元素定位的原点，是它的第一个已定位的祖先的`padding-box`左上角。\n        ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/17-1-13/69220800-file_1484320283452_92ff.png)\n\n-   **默认宽度为内容宽度**：即便为这个`position:absolute`的元素设置成`block`元素，这个元素默认的宽度仍是内容的宽度。\n\n### `position: fixed` 固定定位\n\n-   脱离文档流（这个元素脱离了文档，浮出文档）\n-   参照物为视窗\n-   默认宽度为内容宽度\n\n-   **参照物为视窗**：视窗的意思就是浏览器窗口。不再多做解释。可以自己尝试一下。\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@8布局（上）：display&amp;z-index","url":"/blog/2016/12/09/2016-12-09 CSS@8布局（上）：display&z-index/","content":"\n# CSS 布局（上）：`display`&amp;`z-index`\n\n### 文档流的概念\n\n文档流指的是元素按照其在 HTML 中的位置顺序决定排布的过程，或者说在排布过程中将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素。\n但是，在某些情况下，元素会脱离文档流，他们不会按照既定的顺序进行排布，而是按照指定的规则在文档流中浮动。\n\n---\n\n## `display`\n\n`display`属性，是用来设置元素的布局方式，就是元素如何在页面上展示。\n\n> display：**none** | **inline** | **block** | list-item | **inline-block** | **table** | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex\n\n`display`可以有很多可选的值，但是，**“似乎”**最重要的就只有我加粗的这几个。比较常用的也是这几个。下面就分别介绍这几个值的含义。\n\n### `display:inline` 行内元素\n\n> -   默认宽度为内容宽度\n> -   不可设置宽高\n> -   元素之间同行显示，内部会换行\n\n-   如果一个元素被指定为`display：inline`，那么这个元素就是一个行内元素。\n-   行内元素的意思，就是这个元素**能和其他元素在同一行显示**，比如以下两个元素都是`display:inline`，他们在同一行显示：\n\n-   **内部会换行**：虽然`inline`是一个行内元素，但是它自己内部是会换行的\n\n-   **不可设置宽高**：就是无法为一个行内元素设置宽（`width`）高（`height`），`inline`元素的行高完全是由元素本身内容决定的\n\n*   默认是`display:inline`的元素有：`span`, `a`, `label`, `cite`, `em`, …\n\n---\n\n### `display：block` 块级元素\n\n> -   默认宽度为父元素的宽度\n> -   可设置宽高\n> -   元素之间换行显示\n\n-   **默认宽度为父元素的宽度**，指的是，子元素的`margin`+`border`+`padding`+`content`的宽度和等于父元素`content-box`的宽度。默认高度是元素内容高度，值得注意。如果没有内容，那么高度即为 0。\n\n```css\n.parent {\n    width: 200px;\n    height: 200px;\n    margin: 10px;\n    padding: 50px;\n    background-color: lightseagreen;\n    box-sizing: border-box;\n}\n.child {\n    height: 20px;\n    padding: 20px;\n    margin: 10px;\n    background-color: white;\n}\n```\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-12-12/76855013-file_1481555964594_d399.png)\n\n-   默认是`display:block`的元素有：`div`, `p`, `h1`-`h6`, `ul`, `form`…\n\n        * * *\n\n        ### `display:inline-block` 行块元素\n\n        > *   默认宽度为内容宽度\n\n    > -   可设置宽高\n    > -   元素之间,同行显示\n    > -   后续元素宽度超过边界之后就会整块换行\n\n-   `display:inline-block`综合了行级元素和块级元素的特点。\n-   **默认宽度为内容宽度**，在未设置元素宽度的时候，元素的默认宽度就是内容的宽度，这和`inline`元素保持一致。但又同时是**可设置宽高**的。\n-   元素之间，同行显示，超过边界换行\n    ```css\n    .parent {\n        width: 100px;\n        height: 60px;\n        background-color: lightseagreen;\n    }\n    .children {\n        display: inline-block;\n        width: 30px;\n        height: 10px;\n        background-color: white;\n        outline: 1px solid lightblue;\n    }\n    ```\n-   默认是`display:inline-block`的元素有：`input`, `textarea`, `selelct`, `button`, …\n-   `display:inline-block`一直有一个历史遗留问题。就是**间隙问题**，就比如下面这段代码，你可以复制这段代码到本地，你会发现，将`content-box`之外的所有内容都设为 0，元素之间仍旧有一个间隙，令人百思不得其解。\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n    .parent {\n        width: 200px;\n        height: 100px;\n        background-color: lightseagreen;\n    }\n    .element {\n        display: inline-block;\n        width: 80px;\n        height: 40px;\n        margin: 0;\n        padding: 0;\n        border: 0;\n        background-color: white;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <span class=\"element\"></span>\n        <span class=\"element\"></span>\n        <span class=\"element\"></span>\n        <span class=\"element\"></span>\n    </div>\n</body>\n</html>\n```\n\n![mark](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/jackie/20170122/191902397.png)\n关于它的历史和解决方案，可以参照这篇文章[inline-block 前世今生](http://www.iyunlu.com/view/css-xhtml/64.html)，以及这篇文章提到了很多解决方案：[去除 inline-block 元素间间距的 N 种方法](http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)\n\n-   我个人而言，比较推崇在父元素上加上`font-size:0`的方法。但是这个方法也有局限性，因为要为每个子元素都再设置一遍`font-size`\n\n---\n\n### `display:none` 不显示\n\n-   指的是元素不出现在文档流中，和变透明是**不一样**的，`display:none`是完完全全的消失\n\n## 定位偏移属性\n\n---\n\n### `top` `bottom` `left` `right`\n\n-   当元素的`position`属性不是`static`的时候（下文中会讲），或者添加了`float`属性，那么就可以使用标题中的这四个属性来进行定位偏移\n-   默认是`auto`，也就是`top`和`left`都为 0，对齐到父元素`content-box`的左上角，以此类推。\n-   这四个值都可以设置\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"读《一道JS面试题引发的思考》","url":"/blog/2016/11/30/2016-11-30 读《一道JS面试题引发的思考》笔记和思考/","content":"\n# 读[《一道 JS 面试题引发的思考》](http://web.jobbole.com/89101/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)笔记和思考\n\n这真是一篇牛逼的文章……读了一个多小时才读懂，得好好品味一下才好\n\n### JS 面试题原题\n\n```js\n//比较下面两段代码，试述两段代码的不同之处\n// A--------------------------\nvar scope = \"global scope\"\nfunction checkscope() {\n    var scope = \"local scope\"\n    function f() {\n        return scope\n    }\n    return f()\n}\ncheckscope()\n\n// B---------------------------\nvar scope = \"global scope\"\nfunction checkscope() {\n    var scope = \"local scope\"\n    function f() {\n        return scope\n    }\n    return f\n}\ncheckscope()()\n```\n\n这两段代码其实都输出`\"local scope\"`，考的是跟函数作用域链和闭包相关的知识。\n\n其实这道题在《JavaScript 权威指南》第八章也出现过，当时只是略微理解了一下，大概讲的是，**函数在定义的时候即会绑定到作用域链上**，但是不是很深刻。这篇文章解释的异常详细，都让我觉得有些晦涩，所以要写点笔记。\n\n### 变量对象(variable object)\n\n> Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object.\n>\n> 简言之就是：**每一个执行上下文都会分配一个变量对象(variable object)，变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。**\n\n好吧，文章中的简而言之真的非常**简**而言之...\n\n我自己理解了一下，**变量对象**就是一个保存当前作用域的东西，里面存了当前作用域的所有函数和变量（以属性的方式），但是这个叫**变量对象**的东西，是没法被程序调度起来的（除了全局变量对象，其实就是`window`对象）。\n\n文中有两段神奇的代码值得研究一下：\n\n```js\n// 函数声明\nfunction a() {}\nconsole.log(typeof a) // \"function\"\n```\n\n```js\n// 函数表达式\nvar a = function _a() {}\nconsole.log(typeof a) // \"function\"\nconsole.log(typeof _a) // \"undefined\"\n```\n\n这个区别其实在于：第二段代码，执行完之后，其实根本就没有`_a`这个东西了，具体可以看我在浏览器中执行的结果截图。用函数表达式来定义函数，《JavaScript 权威指南》书中讲到：**定义函数表达式时并没有声明一个变量。**所以，其实根本就没有声明`_a`这个变量，又怎么可能把它存入**变量对象(variable object)**中呢\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-30/83040077.jpg)\n\n### 活动对象（activation object）\n\n> When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name arguments and attributes { DontDelete }. The initial value of this property is the arguments object described below.\n> The activation object is then used as the variable object for the purposes of variable instantiation.\n>\n> 简言之：**当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化。**\n\n我的理解，活动对象，其实就是`arguments`。在函数执行的时候创建。文中有一段代码用来解释这个概念：\n\n```js\nfunction a(name, age) {\n    var gender = \"male\"\n    function b() {}\n}\na(\"k\", 10)\n```\n\n不知道用下面这个图来解释它合不合适，但是这是我的理解。\n\n在函数`a`调用的时候，会创建`activation object`，而`activation object`事实上就是`arguments`。之后函数`a`在执行的时候，会生成`variable object`，实际上就是作用域内的函数和对象再加上`activation object`组成的。\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-30/6167039.jpg)\n\n### 执行环境和作用域链(execution context and scope chain)\n\n文中引入了一个叫**环境栈**的概念，其实很好理解，就是作用域链的另外一种表现形式而已。\n\n我比较想画个图来帮助理解下面这段话：\n\n```js\nfunction test(num) {\n    var a = \"2\"\n    return a + num\n}\ntest(1)\n```\n\n> 1.  执行流开始 初始化 function test，test 函数会维护一个私有属性 [[scope]],并使用当前环境的作用域链初始化，在这里就是 test.[[Scope]]=global scope.\n> 2.  test 函数执行，这时候会为 test 函数创建一个执行环境，然后通过复制函数的[[Scope]]属性构建起 test 函数的作用域链。此时 test.scopeChain = [test.[[Scope]]]\n> 3.  test 函数的活动对象被初始化，随后活动对象被当做变量对象用于初始化。即 test.variableObject = test.activationObject.contact[num,a] = [arguments].contact[num,a]\n> 4.  test 函数的变量对象被压入其作用域链，此时 test.scopeChain = [ test.variableObject, test.[[scope]]];\n\n1. `test`函数的声明（初始化）。事实上会生成一个`[[Scopes]]`属性，作为`test`函数作用域链上的一层。我特地去浏览器中声明了这个函数，并且查看了它的属性，的确有`[[Scopes]]`这个属性。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-30/91284528.jpg)\n\n2. `test`函数开始执行。创建`test`函数内部的作用域，并添加到作用域链上。此时`test`函数的作用域链（黄色部分）就包含了`[[Scopes]]`属性：\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-30/36836234.jpg)\n\n3. 在步骤 2 的同时，会用`arguments`初始化`test`的`activation object`（活动对象），并且用这个`activation object`（活动对象）来生成`variable object`（变量对象）。之后，将`variable object`（变量对象）添加到作用域链中。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-1/10486754.jpg)\n\n4. 动图解释一下：\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-30/29470224.jpg)\n\n    ### 关于题目本身\n\n    其实两段代码差别不大，区别在于，`f()`函数执行的环境不一样。花了一个多小时做了个动图，结果觉得还是算了。。。太麻烦了。。。\n\n    因为 B 这段代码，执行完`checkscope()`函数之后，就从**执行环境栈**中弹出`checkscope`的执行环境，但是对结果不产生影响。\n\n    ```js\n    var scope = \"global scope\"\n    function checkscope() {\n        var scope = \"local scope\"\n        function f() {\n            return scope\n        }\n        return f\n    }\n    checkscope()()\n    ```\n\n    而 A 这段代码，在执行`checkscope()`的过程中执行了`f()`，此时`checkscope`的执行环境还未从**执行环境栈**中弹出。下面这幅图展示了这点区别，当 A 代码还在执行`f()`的时候，B 代码已经从栈中弹出了`checkscope`的作用域链。\n\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-1/85400904.jpg)\n","tags":["FrontEnd","JavaScript"]},{"title":"CSS@7背景","url":"/blog/2016/11/29/2016-11-29 CSS@7背景/","content":"\n# CSS 背景 `background`\n\n---\n\n### `background-color` 背景颜色\n\n> background-color:&lt;color&gt;\n\n**解释：**\n\n-   背景颜色，默认是 transparent，全透明\n\n---\n\n### `background-image` 背景图片\n\n> background-image:&lt;bg-image&gt;[,&lt;bg-image&gt;]\\* > &lt;bg-image&gt; = &lt;image&gt;|none\n\n**解释：**\n\n-   image 的引入方法（引号改成单引号或者不加引号都可以）：\n    -   绝对地址：`url(\"绝对地址\")`\n    -   相对地址：`url(\"/image/x.png\")`\n    -   相对地址 2：`url(\"../image/x.png\")` （`..`表示向上一级）\n-   可以写多个图片，先写的覆盖后写的。`background-image:url(red.png), url(blue.png)`\n-   `background-image`的优先级高于`background-color`，也就是`background-color`铺在后面：\n\n```css\ndiv {\n    width: 250px;\n    height: 250px;\n    background-image: url(...);\n    background-color: lightblue;\n    background-repeat: no-repeat; /*之后会讲*/\n    background-position: 50% 50%; /*之后会讲*/\n}\n```\n\n<div style=\"width:250px;height:250px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-29/16656082.jpg);background-color:lightblue;background-repeat:no-repeat;margin:0 auto 20px;background-position:50% 50%;\"></div>\n\n---\n\n### `background-repeat` 背景图片延伸方式\n\n> background-repeat: &lt;repeat-style&gt;[,&lt;repeat-style&gt;]\\* > &lt;repeat-style&gt; = repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}\n\n**解释：**\n\n-   设置背景图片以何种方式填满这个元素。默认是`repeat`。\n-   这之前必须要设置`background-image`\n-   可以提供 1 对或多对参数，中间用逗号隔开，每对参数包含 2 个或 1 个参数。\n-   多对参数的意义在于，当设置多张`background-image`时，为它们一一设置（这一点同样适用于后面的各个`background-image`相关的属性）\n\n```css\ndiv {\n    width: 250px;\n    height: 250px;\n    background-image: url(\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-29/16656082.jpg\"),\n        url(\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png\");\n    background-repeat: no-repeat, repeat;\n    background-position: 50% 50%; /*之后会讲*/\n}\n```\n\n<div style=\"width:250px;height:250px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-29/16656082.jpg),url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-color:lightblue;background-repeat:no-repeat, repeat;margin:0 auto 20px;background-position:50% 50%;\"></div>\n\n-   提供 2 个参数时，第一个参数用于横向，第二个参数用于纵向。\n-   如果只提供一个参数，则横向纵向都使用。特殊值`repeat-x`,`repeat-y`只能设置它们所对应的轴。\n-   下面看一下`repeat`, `space`, `round`, `no-repeat`的效果:\n<div><div style=\"display:inline-block;height:150px;width:150px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/17139779.jpg);background-repeat:repeat;position:relative;background-color:#eee;\"><p style=\"position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);font-size:14px;color:white;\">repeat</p></div> <div style=\"display:inline-block;height:150px;width:150px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/17139779.jpg);background-repeat:space;position:relative;background-color:#eee;\"><p style=\"position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);font-size:14px;color:white;\">space</p></div> <div style=\"display:inline-block;height:150px;width:150px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/17139779.jpg);background-repeat:round;position:relative;background-color:#eee;\"><p style=\"position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);font-size:14px;color:white;\">round</p></div> <div style=\"display:inline-block;height:150px;width:150px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/17139779.jpg);background-repeat:no-repeat;position:relative;background-color:#eee;\"><p style=\"position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);font-size:14px;color:white;\">no-repeat</p></div> </div>\n\t- `repeat`:默认值，表示不进行缩放，图片不断重复\n\t- `space`:表示不缩放，完全填满整个元素，中间可以有间隙\n\t- `round`:表示用最小程度的缩放，完全填满整个元素，中间没有任何间隙\n\t- `no-repeat`:表示不重复\n\n---\n\n### `background-attachment` 背景固定\n\n> background-attachment:&lt;attachment&gt; [, &lt;attachment&gt;]\\* > &lt;attachment&gt; = scroll|fixed|local\n\n**解释：**\n\n-   用来设置背景图片是否相对固定的方式。默认是`scroll`。\n-   必须先指定`background-image`.\n-   来观察一下效果：\n<div style=\"width:100%;height:200px;overflow-y:scroll;\"><div style=\"height:250px;overflow-y:scroll;display:inline-block;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/74072331.jpg);background-color:#eee;background-attachment:scroll;\"><div style=\"display:inline-block;height:300px;width:150px;position:relative;\"><p style=\"position:absolute;left:50%;transform:translate(-50%);font-size:20px;color:white;\">scroll</p></div></div> <div style=\"height:250px;overflow-y:scroll;display:inline-block;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/74072331.jpg);background-color:#eee;background-attachment:fixed;\"><div style=\"display:inline-block;height:300px;width:150px;position:relative;\"><p style=\"position:absolute;left:50%;transform:translate(-50%);font-size:20px;color:white;\">fixed</p></div></div> <div style=\"height:250px;overflow-y:scroll;display:inline-block;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/74072331.jpg);background-color:#eee;background-attachment:local;\"><div style=\"display:inline-block;height:300px;width:150px;position:relative;\"><p style=\"position:absolute;left:50%;transform:translate(-50%);font-size:20px;color:white;\">local</p></div></div></div>\n\t- `scroll`：背景图像相对于元素固定\n\t- `fixed`：背景图像相对于窗体固定\n\t- `local`：背景图像相对于元素内容（子元素）固定，`CSS3`新增的属性\n\n---\n\n### `background-position` 背景图片位置\n\n> background-position：&lt;position&gt; [, &lt;position&gt;]\\* > &lt;position&gt; = [ left | center | right | top | bottom | &lt;percentage&gt; | &lt;length&gt; ] | [ left | center | right | &lt;percentage&gt; | &lt;length&gt; ] [ top | center | bottom | &lt;percentage&gt; | &lt;length&gt; ] | [ center | [ left | right ] [ &lt;percentage&gt; | &lt;length&gt; ]? ] && [ center | [ top | bottom ] [ &lt;percentage&gt; | &lt;length&gt; ]? ]\n\n**解释：**\n\n-   用来设置背景图片相对的位置\n-   一般只写两个值，比如：`background-position:20px 50px;`指的是：\n    -   以 top 上边界为基础向下偏移 20px，以 left 左边界为基础向右偏移 50px。\n-   再比如：`background-position:20% 50%;`指的是：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-12-5/397339.jpg) - ab 之间占了整体的 20% - ef 之间占了背景图片的 20% - ad 之间占了整体的 50% - cf 之间占了背景图片的 50% - 也就是说，**背景图片`20% 50%`的位置和元素`20% 50%`的位置重叠在一起**。\n-   **注意**：在`background-position`里面，`<length>`和`<persentage>`的偏移基准是不一样的，`<length>`是纯粹的偏移，而`<percentage>`有点“对齐”的意思。\n-   在`CSS3`，这个属性可以写三个或四个值了。可以写成：方向+偏移量+方向+偏移量，或者方向+偏移量+方向；就是说，**写偏移量之前，一定要声明方向**。举例吧：\n    -   三个参数：`background-position:right 20px bottom;`指的是：以右边界为基础向左偏移 20px，并和下边界对齐：\n    <div style=\"width:200px;height:200px;margin:10px auto;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-repeat:no-repeat;background-color:#ccc;background-size:auto;background-position:right 20px bottom;\"></div>\n    -   四个参数：`background-position:right 20% bottom 50%;`，具体效果见下面：\n    <div style=\"width:200px;height:200px;margin:10px auto;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-repeat:no-repeat;background-color:#ccc;background-size:auto;background-position:right 20% bottom 50%;\"></div>\n    -   再强调一遍，**写偏移量（`<length>`或者`<percentage>`）之前，一定要声明方向**。写成`right 20px 50px`或者`30% bottom 20%`是没用的。\n\n---\n\n### `background-origin` 背景图片相对定位方式\n\n> background-origin: &lt;box&gt;[, &lt;box&gt;]\\* > &lt;box&gt; = border-box | padding-box | content-box\n\n**解释：**\n\n-   设置偏移的基准是哪一个边框。默认是`padding-box`\n-   用例子来说明：\n\n```css\ndiv {\n    display: inline-block;\n    width: 150px;\n    height: 150px;\n    margin: 25px;\n    background-color: #bbb;\n    background-image: url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);\n    background-repeat: no-repeat;\n    padding: 25px;\n    border: 25px solid rgba(0, 0, 0, 0.3);\n}\n.border-box {\n    background-origin: border-box;\n}\n.padding-box {\n    background-origin: padding-box;\n}\n.content-box {\n    background-origin: content-box;\n}\n```\n\n<div style=\"margin:0 auto;width:600px;\"><div style=\"display:inline-block;width:150px;height:150px;margin:25px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-repeat:no-repeat;padding:25px;border:25px solid rgba(0, 0, 0, 0.3);background-origin: border-box;\"></div><div style=\"display:inline-block;width:150px;height:150px;margin:25px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-repeat:no-repeat;padding:25px;border:25px solid rgba(0, 0, 0, 0.3);background-origin: padding-box;\"></div><div style=\"display:inline-block;width:150px;height:150px;margin:25px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);background-repeat:no-repeat;padding:25px;border:25px solid rgba(0, 0, 0, 0.3);background-origin: content-box;\"></div></div>\n\n---\n\n### `background-clip` 背景图片/颜色覆盖范围\n\n> background-clip: &lt;box&gt;[, &lt;box&gt;]\\* > &lt;box&gt; = border-box | padding-box | content-box\n\n**解释：**\n\n-   用来设置，背景图片覆盖到的范围。默认是`border-box`。\n-   `background-clip`对`background-color`也同样有效。也就是说，背景颜色的覆盖范围也和它有关。\n-   `border-box`:背景图片除了没法覆盖`margin`以外，都能覆盖到\n-   `padding-box`:背景图片只能覆盖到`border`以内（不包含`border`）\n-   `content-box`:背景图片只能覆盖到`padding`以内（不包含`padding`）\n-   以下从左往右，分别是`border-box`，`padding-box`，`content-box`。\n\n```css\ndiv {\n    display: inline-block;\n    width: 150px;\n    height: 150px;\n    margin: 25px;\n    background-image: url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);\n    padding: 25px;\n    border: 25px solid rgba(0, 0, 0, 0.3);\n}\n.border-box {\n    background-clip: border-box;\n}\n.padding-box {\n    background-clip: padding-box;\n}\n.content-box {\n    background-clip: content-box;\n}\n```\n\n<div style=\"margin:0 auto;width:600px;\"><div style=\"display:inline-block;width:150px;height:150px;margin:25px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);padding:25px;border: 25px solid rgba(0,0,0,0.3);\"></div><div style=\"display:inline-block;width:150px;height:150px;margin:25px; background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);padding:25px;border: 25px solid rgba(0,0,0,0.3);background-clip:padding-box;\"></div><div style=\"display:inline-block;width:150px;height:150px;margin:25px;background-image:url(https://jackie-image.oss-cn-hangzhou.aliyuncs.com/avatar.png);padding:25px;border: 25px solid rgba(0,0,0,0.3);background-clip:content-box;\"></div></div>\n\n---\n\n### `background-size` 背景图片大小\n\n> background-size:&lt;bg-size&gt; [, &lt;bg-size&gt;]\\* > &lt;bg-size&gt; = [&lt;length&gt;|&lt;percentage&gt;|auto]{1, 2}|cover|contain\n\n**解释：**\n\n-   用来定义背景图片大小，默认是`auto`，表示无缩放地展示背景图片。\n-   `<length>`：不言而喻，就是直接定义长宽\n-   `<percentage>`：相对于背景图片的容器的百分比（注意不是相对于原图，而是以容器本身为基准）\n-   `cover`：背景图片的长宽都超过容器，但尽可能小。也就是等比例缩放到刚好能完全**覆盖**整个元素。\n-   `contain`：图片的长宽都不超过容器，但尽可能大。也就是等比例缩放到刚好能完全**撑满**整个元素。\n\n---\n\n### `linear-gradient()` 线性渐变\n\n> linear-gradient([[&lt;angle&gt;|to &lt;side-or-center&gt;],]? &lt;color-stop&gt;[, &lt;color-stop&gt;]+)\n> &lt;side-or-corner&gt; = [left | right] || [top | bottom] > &lt;color-stop&gt; = &lt;color&gt;[&lt;percentage&gt; | &lt;length&gt;]?\n\n**解释：**\n\n-   `linear-gradient`是用来定义线性渐变的背景图片的，一般用法像这样：`background-image:linear-gradient(red, bule);`表示红蓝渐变，效果如下(当然我改了颜色值，不然略微有点丑）：\n<div style=\"margin:0 auto; width:100px; height:100px; background-image:linear-gradient(coral, lightblue)\"></div>\n-   第一个参数`[<angle>|to <side-or-center>]`是可选的，可以写一个角度，表示渐变的方向（默认是`180deg`，表示从上往下）；也可以用关键词的方式，来定义从左往右（`to right`）或者从右往左(`to left`)或者从上往下（`to bottom`，默认）以及从下往上（`to top`）\n-   第二个参数是必须的，而且必须写两个及以上，用来表示颜色渐变。第二个参数，不光指定渐变的颜色，还能指定颜色停止的位置。比如：`background-image:linear-gradient(gold, pink 70%, purple);`指定粉色在渐变 70%的位置结束。在下面举了例子，在此不再深究。\n<div style=\"margin:0 auto; width:100px; height:100px; background-image:linear-gradient(gold, lightcoral 70%, mediumvioletred);\"></div>\n\n---\n\n### `radial-gradient()` 径向渐变\n\n这是一个大坑，详细讲的话要讲很久，只举几个例子，详细的请看这里：[CSS 参考手册](http://www.css88.com/book/css/values/image/index.htm)。\n\n-   `background-image:radial-gradient(gold, pink);`省略了默认值，补充完整是`radial-gradient(ellipse, farthest-corner, gold, pink)`\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(gold, pink);\"></div>\n-   `background-image:radial-gradient(closest-side, gold, pink);`\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(closest-side, gold, pink);\"></div>\n-   `background-image:radial-gradient(circle, gold, pink);` 默认是`farthest-corner`，也就是扩散到远端。\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(circle, gold, pink);\"></div>\n-   `background-image:radial-gradient(circle 50px, gold, pink);`\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(circle 50px, gold, pink);\"></div>\n-   `background-image:radial-gradient(100px 50px, gold, pink);`\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(100px 50px, gold, pink);\"></div>\n-   `background-image:radial-gradient(100px 50px at 0 0, gold, pink);`\n<div style=\"margin:10px auto; width:200px; height:100px; background-image:radial-gradient(100px 50px at 0 0, gold, pink);\"></div>\n-   `background-image:radial-gradient(gold, pink 20%, mediumvioletred);`\n<div style=\"margin:10px auto; width:200px; height:100px;background-image:radial-gradient(gold, pink 20%, mediumvioletred);\"></div>\n\n---\n\n### `repeating-*-gradient()` 循环渐变\n\n-   `*`可以替换成`linear`或`radial`，表示渐变不断地循环\n\n---\n\n### `backgound` 缩写\n\n> background: [&lt;bg-layer&gt; ,]\\* &lt;final-bg-layer&gt; > &lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [/ &lt;bg-size&gt;]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; > &lt;final-bg-layer&gt; = &lt;bg-layer&gt; || &lt;’backgorund-color’&gt;\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@6盒模型","url":"/blog/2016/11/26/2016-11-26 CSS@6盒模型/","content":"\n# CSS 盒模型\n\n---\n\n## 经典图解\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/42851826.jpg)\n如上图所述，每个 HTML 元素，都像一个盒子，而这个盒子，有`content`(内容)，`padding`(填充缝隙)，`border`(边界/外壳)，`margin`(边缘空白)。\n\n-   `content`:可以理解为盒子里装的内容物\n-   `padding`:可以理解为盒子的外壳和内容之间的缝隙（或者是填充物），就像快递盒子里面可能会填上那种充气的保护垫\n-   `border`:可以理解为盒子的外壳\n-   `margin`:可以理解为盒子与盒子间的空隙\n\n---\n\n## 相关属性\n\n### `width` 元素宽度\n\n> <span style=\"font-family: consolas\">width:&lt;length&gt;|&lt;percentage&gt;<span style=\"color: #ccc;\">|auto|inherit</span></span>\n\n**解释：**\n\n-   该属性，很明显，是用来设置元素宽度的，但是具体设置的是`content`部分的宽度，还是`border`包含的部分的宽度，要视情况而定，本篇后面会讲\n-   一般对于`inline`（行级）元素设置宽度是没有意义的，只给`inline-block`，`block`或者其他某些类型的元素设置宽度\n-   默认值是`auto`，没有继承性，除非设置了`inherit`\n-   引申出`min-width`，`max-width`属性，是给元素设置最小宽度和最大宽度的\n\n---\n\n### `height` 元素高度\n\n> <span style=\"font-family: consolas\">height:&lt;length&gt;|&lt;percentage&gt;<span style=\"color: #ccc;\">|auto|inherit</span></span>\n\n**解释：**\n\n-   和`width`一致\n\n---\n\n### `padding` 填充宽度\n\n> <span style=\"font-family:consolas\">padding：[&lt;length&gt;|&lt;percentage&gt;]{1, 4}<span style=\"color: #ccc;\">|inherit</span></span>\n\n**解释：**\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/46870088.jpg)\n\n-   `padding`是设置填充宽度的一个属性。可以设置 1 到 4 个值，分别设置上、右、下、左（顺时针）四个填充宽度，如上图。\n-   设置为`<percentage>`时，百分比数值是相对父元素\n-   也可以分开设置`padding`:`padding-top`,`padding-right`,`padding-bottom`,`padding-left`。\n-   举例说明：\n    -   写一个值的情况：`padding:20px;`，说明四个方向的`padding`都是同一个值，也就是 20px\n    -   写两个值的情况：`padding:20px 10px;`，其实等于`padding:20px 10px 20px 10px;`，也就是说，如果上和下的`padding`相等，那么只要设置一个就够了，左右也是一样。\n    -   写三个值的情况：`padding:20px 10px 5px;`，其实等于`padding:20px 10px 5px 10px`，事实上写三个就只指定了上，右和下的宽度，剩余的左宽度应该等于右边的宽度。\n-   总结一下规则：\n    -   **对面相等，后者省略**\n    -   **四面相等，只写一个**\n-   其实类似`padding`这样，要对四个方向设值的属性，一般都可以像`padding`的规则进行设置。\n-   `padding`的颜色和`content`的颜色一致，都是`background-color`\n\n---\n\n### `margin` 外边距宽度\n\n> <span style=\"font-family:consolas\">margin：[&lt;length&gt;|&lt;percentage&gt;<span style=\"color: #ccc;\">|auto</span>]{1, 4}<span style=\"color: #ccc;\">|inherit</span></span>\n\n**解释：**\n\n-   `margin`的书写方式基本上和`padding`是一样的，但是还是有一些区别的。\n-   `margin`默认为 0，但是可能浏览器的默认样式表会给某些标签设置初始`margin`值，比如 IE6、IE7 的 body 标签，默认的样式应该是：`display:block;margin:15px 10px;zoom:1;`（不是很确定），而没有预设 padding 值，chrome/firefox 也只是设置了`margin:8px;`没有预设 padding\n-   上下毗邻的两个元素的`margin-top`和`margin-bottom`会合并，取两者之间的较大值，看下面这个例子，两个元素间距仅为 30px,而不是 30px+10px：\n    ```xml\n    <div style=\"height:30px;width:100px;margin:30px 10px;background-color:lightseagreen;\"></div>\n    <div style=\"height:30px;width:100px;margin:10px 10px;background-color:lightseagreen;\"></div>\n    ```\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/99820013.jpg)\n-   父元素的上下`margin`分别会和第一个子元素的`margin-top`以及最后一个子元素的`margin-bottom`进行合并。\n    ```xml\n    <div style=\"width: 100px; margin: 40px auto; background-color: lightblue;\">\n          <div style=\"height:30px;width:100px;margin:30px 0;background-color:lightseagreen;\"></div>\n          <div style=\"height:30px;width:100px;margin:10px 0;background-color:lightseagreen;\"></div>\n      </div>\n    ```\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/70700658.jpg)\n    但值得注意的是，上面这种情况的触发条件是比较苛刻的。只有在父元素没有设置`border`的时候才会合并。因为子元素的所有内容（包括`margin`）是要完全包含在父元素的`border`里面的。假设，我在上面这种情况中，给父元素添加`border`,就会变成下面这种情况：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/63159378.jpg)\n\n---\n\n### `border` 边框\n\n> <span style=\"font-family:consolas\">border:[&lt;border-width&gt;||&lt;border-style&gt;||&lt;border-color&gt;]<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">border-width:[&lt;length&gt;<span style=\"color:#ccc\">|thin|medium|thick</span>]{1,4}<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">border-style:[solid|dashed|dotted<span style=\"color:#ccc\">|…</span>]{1,4}<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">border-color:[&lt;color&gt;|transparent]{1,4}<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">border-radius:[&lt;length&gt;|&lt;percentage&gt;]{1,4} [/[&lt;length&gt;|&lt;percentage&gt;]{1,4}]</span>\n\n**解释:**\n\n-   上面的属性，都可以写成`border-direction-xxx`的形式，如`border-bottom-color`。\n-   `border-style`最常用的三种就是：`solid`(实线), `dashed`(虚线), `dotted`(点线)\n-   重点讲一下`border-radius`：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/28606767.jpg) - 事实上，每个角都是一个椭圆，而椭圆都会有两个属性，就是 x 轴长度和 y 轴长度，如图所示。 - 所以设置全部四个角，需要 8 个值来表示，前四个，分别表示 1,2,3,4 个角的 X 轴方向半径，而后四个，则需要在前面加上`/`以示区别。比如上图中的圆角矩形，可以写成`border-radius: 10px 15px 5px 5px /10px 5px 5px 15px`。 - `border-radius`也满足**对面相同，后者省略；四面相等，只写一个**的规则，也就是，如果 1 号角和 3 号角如果一样，则只要写 1 号角的就行了。 - `border-radius`还满足**x,y 一致，后者省略**的规则，也就是说如果 x 方向半径和 y 方向半径一致的话，y 方向就可以不写 - 对`border-radius`设置百分比的值时，是相对本元素的`width`和`height`而言的。也就是说，如果对一个正方形元素，设置`border-radius:50%`就可以变成圆形，如下：\n<div style=\"width: 40px; height: 40px; margin:10px; background-color: lightblue;border-radius:50%;\"></div>\n\n---\n\n### `outline` 轮廓\n\n> <span style=\"font-family:consolas\">outline:[&lt;outline-width&gt;||&lt;outline-style&gt;||&lt;outline-color&gt;]<span style=\"color:#ccc\">|inherit</span></span>\n\n> <span style=\"font-family:consolas\">outline-width:[&lt;length&gt;<span style=\"color:#ccc\">|thin|medium|thick</span>]<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">outline-style:[solid|dashed|dotted<span style=\"color:#ccc\">|…</span>]<span style=\"color:#ccc\">|inherit</span></span> > <span style=\"font-family:consolas\">outline-color:&lt;color&gt;<span style=\"color:#ccc\">|inherit</span></span>\n\n**解释：**\n\n-   `outline`是在`border`外面的一圈，不占据空间的轮廓。基本上和`border`的属性一致。\n-   下面这个例子，你会发现两个`div`块之间，`outline`会互相覆盖，这说明`outline`并不占据空间。\n\n```css\ndiv {\n    width: 200px;\n    height: 50px;\n    outline: 10px solid rgba(230, 230, 230, 0.5);\n}\n.left {\n    background-color: lightseagreen;\n}\n.right {\n    background-color: darkorange;\n}\n```\n\n<div style=\"width:200px;height:50px;outline:10px solid rgba(230,230,230,0.5);background-color:lightseagreen;margin:0 auto;\"></div><div style=\"width:200px;height:50px;outline:10px solid rgba(230,230,230,0.5);background-color:darkorange;margin:0 auto 20px;\"></div>\n\n---\n\n### `overflow` 溢出\n\n> <span style=\"font-family:consolas\">overflow：visible|hidden|scroll|auto</span>\n\n**解释：**\n\n-   `overflow`是用来设置如果子元素超过父元素的溢出规则。\n-   `visible`表示可见；\n-   `hidden`表示隐藏；\n-   `scroll`表示固定显示滚动条；\n-   `auto`表示根据内容多少来选择显示或不显示滚动条；\n-   效果对比：\n\n<p style=\"display: inline-block;width: 180px;height: 120px;margin: 20px;background-color: lightblue;font-family: consolas;vertical-align: top;overflow: visible;\">overflow: visible; overflow: visible; overflow: visible; overflow: visible; overflow: visible; Jackie Anxis</p><p style=\"display: inline-block;width: 180px;height: 120px;margin: 20px;background-color: lightblue;font-family: consolas;vertical-align: top;overflow: hidden;\">overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; overflow: hidden; Jackie Anxis</p><br>\n  <p style=\"display: inline-block;width: 180px;height: 120px;margin: 20px;background-color: lightblue;font-family: consolas;vertical-align: top;overflow: scroll;\">overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; overflow: scroll; Jackie Anxis</p><p style=\"display: inline-block;width: 180px;height: 120px;margin: 20px;background-color: lightblue;font-family: consolas;vertical-align: top;overflow: auto;\">overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; overflow: auto; Jackie Anxis</p>\n\n-   也可以利用`overflow-x`，`overflow-y`分别设置 X 和 Y 方向的溢出处理\n\n### `box-sizing` 选择宽度设置\n\n> <span style=\"font-family:consolas\">box-sizing:content-box|border-box<span style=\"color:#ccc\">|inherit</span></span>\n\n**解释：**\n\n-   `box-sizing`是用来指定，`width`和`height`指定的究竟是`content`内容的宽度还是`border`包含的宽度。\n-   默认是`content-box`，表示 CSS 样式中，`width`和`height`指定的是`content`内容的宽度，也就是说，`width: 100px;padding:10px;`这段代码，实际上`border`（不包含`border`）里面的内容应该宽为 120px\n-   设置为`border-box`，表示 CSS 样式中，`width`和`height`指定的是`border`（包括`border`在内）包含内容的宽度。\n-\n\n```css\nwidth: 100px;\npadding: 10px;\nborder: 10px;\nbox-sizing: border-box;\n```\n\n这段代码，实际上，`content`部分的宽度只有 60px，而要加上`padding`和`border`的宽度才达到 100px。\n\n---\n\n### `box-shadow` 设置阴影\n\n> <span style=\"font-family:consolas\">box-shadow:none|&lt;shadow&gt;[,&lt;shadow&gt;]\\*</span> > <span style=\"font-family:consolas\">&lt;shadow&gt;:inset?&&&lt;length&gt;{2,4}&&&lt;color&gt;</span>\n\n**解释：**\n\n-   `box-shadow`用来设置一个元素的阴影，默认是`none`，可以是多个值，中间用`,`隔开，表示多层阴影。\n-   `inset`表示内阴影\n-   对于每一层阴影，`length`可以有 2-4 个，分别表示水平偏移（正值表示向右）、垂直偏移（正值表示向下），模糊半径，阴影大小；如下图所示的一段 CSS：\n\n```css\nbox-shadow: 10px 10px 5px 20px lightblue;\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-28/52001293.jpg)\n黑色边框部分，是向下偏移 10px，向右偏移 10px 应该产生的阴影（也就是`box-shadow: 10px 10px lightblue;`的情况下应该有的大小)，而红色边框比黑色边框总共宽 40px(2 个阴影大小的宽度)，而 5px 的模糊半径，是包含在 20px 的阴影大小里面的。\n\n## 关于盒模型中百分比的问题做一个统一说明\n\n### `width`&`height`\n\n> 对子元素的`width`和`height`设置百分比值，无论父元素的`box-sizing`如何，都是相对父元素`content`部分进行计算的。\n\n```css\n/*left div content-box*/\n.parent {\n    width: 200px;\n    height: 100px;\n    padding: 10px;\n    box-sizing: content-box;\n}\n.child {\n    width: 50%;\n    height: 50%;\n}\n/*right div border-box*/\n.parent {\n    width: 200px;\n    height: 100px;\n    padding: 10px;\n    box-sizing: border-box;\n}\n.child {\n    width: 50%;\n    height: 50%;\n}\n```\n\n<div style=\"display:inline-block;width:200px;height:100px;background-color:lightblue;padding:10px;box-sizing: content-box; margin:0 10px;\"><div style=\" width:50%;height:50%;padding:10px;background-color: lightseagreen;font-size:12px;color:white;text-align:center;\">100x50</div></div><div style=\"display:inline-block;width:200px;height:100px;background-color:lightblue;padding:10px;box-sizing: border-box; margin:0 10px;\"><div style=\"width:50%;height:50%;padding:10px;background-color:lightseagreen;font-size:12px;color:white;text-align:center;\">90x40</div></div>\n- 第一个父元素的`content-box`的宽为`200px`；所以子元素的`width`/`height`应该是基于200px进行计算的。\n- 第二个父元素的`content-box`的宽为`200px-10px*2=180px`；所以子元素的`width`/`height`应该是基于`180px`进行计算的。\n---\n### `padding`&`margin`&`border`\n> 对子元素的`padding`和`margin`设置百分比值，无论父元素的`box-sizing`如何，都是相对父元素`content`部分的`width`进行计算的。\n> 哦，忘了说了。`border`是不允许设置百分比值的。可怜的`border`。\n\n```css\n/*padding-test*/\n.parent {\n    width: 400px;\n    height: 150px;\n    padding: 50px;\n    box-sizing: border-box;\n}\n.child1 {\n    width: 200px;\n    height: 20px;\n    padding: 5% 16.67%;\n}\n.child2 {\n    width: 200px;\n    height: 20px;\n    margin: 5% 16.67%;\n}\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-28/10974580.jpg)\n\n-   父元素的`content-box`的宽为`400px-50px*2=300px`；所以子元素的`padding`/`margin`应该是基于`300px`进行计算的。\n-   **注意：**无论上下还是左右的`padding`或者`margin`，都是相对父元素的`width`而言的，和`height`无关。\n\n---\n\n### `border-radius`\n\n> 对元素的`border-radius`设置百分比值，x 轴方向的值是相对于元素`border-box`的`width`计算的，y 轴方向的值是相对于元素`border-box`的`height`计算的\n\n```css\ndiv {\n    width: 1000px;\n    height: 500px;\n    padding: 200px;\n    border: 1px dashed gray;\n    background-clip: content-box;\n    /*background-clip: border-box;*/\n    border-radius: 10%;\n}\n```\n\n以下是左上角部分截图：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-28/35260114.jpg)\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@5文本","url":"/blog/2016/10/23/2016-10-23 CSS@5文本/","content":"\n# 文本相关的 CSS 样式\n\n---\n\n## 文字和颜色（`font`&`color`）\n\n### `font-size` 文字大小\n\n> <span style=\"font-family: consolas\">font-size:&lt;length&gt;|&lt;percentage&gt;<span style=\"color: #ccc;\">|&lt;absolute-size&gt;|&lt;relative-size&gt;</span></span>\n\n**解释：**\n\n-   `font-size`可以填写一个**绝对**的长度值（length）或者一个**相对**的百分比值（percentage），我的前面一片文章中关于[css 单位](http://jackie-anxis.com/2016/09/26/CSS@4%E5%8D%95%E4%BD%8D/)中关于长度单位的部分可以参考。\n-   **默认**是从父元素继承`font-size`\n-   接下去，我一般会把不太重要的内容设置成灰色，这些内容一般平时都用不上。\n\n---\n\n### `font-family` 文字字体\n\n> <span style=\"font-family: consolas;\">font-family:[&lt;family-name&gt;|&lt;generic-family&gt;]#</span> > <span style=\" font-family: consolas\">&lt;generic-family&gt;=serif(衬线体)|sans-serif(非衬线体)<span style=\"color: #ccc;\">|cursive|fantasy|monospace</span></span>\n\n**解释：**\n\n-   `#`表示可以指定很多个`font-family`，中间用逗号`,`隔开，比如：`font-family:verdana, \"microsoft yahei\";`或者`font-family:\"宋体\", serif;`\n-   指定多个`font-family`：表示依次搜索这些值，取最先搜到的\n\n---\n\n### `font-weight` 字体粗细\n\n> <span style=\"font-family: consolas\">font-weight=normal|bold<span style=\"color: #ccc;\">|bolder|lighter</span>|100|200|…|900</span>\n\n**解释：**\n\n-   `font-weight`的取值，可以设置为数字，只能为 100-900 之间的整百数，如果不是这 9 个数之一，那就会失效。\n\n---\n\n### `font-style` 字体倾斜\n\n> <span style=\"font-family: consolas\">font-style=normal|italic<span style=\"color: #ccc;\">|oblique</span></span>\n\n**解释：**\n\n-   `italic`表示字体自带的斜体，`oblique`表示如果字体没有斜体，就会倾斜\n\n---\n\n### `line-height` 字体行高\n\n> <span style=\"font-family: consolas\">line-height:normal|&lt;number&gt;|&lt;length&gt;|&lt;percentage&gt;</span>\n\n**解释：**\n\n-   举几个例子：`line-height:40px;` `line-height:3em;` `line-height:300%;` `line-height:3;`\n\n-   上面四个例子中的后三者，看上去差不多，当不发生继承时，的确他们的表现差不多：\n<div><p style=\"background: wheat; line-height: 3em; display: block\">line-height: 3em</p><p style=\"background: lightblue; line-height: 300%; display: block\">line-height: 300%</p><p style=\"background: salmon; line-height: 3; display: block\">line-height: 3</p>\n  </div>\n\n-   一旦他们的子元素继承了父元素的`line-height`，这三者就不一样了：\n    可以明显看到，`line-height: 3em`和`line-height: 300%`的表现是差不多的，都是`3*20px`，但是`line-height:3`是`3*10px`。可以理解为，前两者是直接把父元素的计算结果继承下来（**先计算后继承**），而后者则是直接继承，之后再计算（**先继承后计算**）：\n\n```xml\n<div style=\"line-height: 3em; font-size: 20px;\">\n\t<p style=\"font-size: 10px; background: yellow;\">line-height: 3em</p>\n</div>\n<div style=\"line-height: 3; font-size: 20px;\">\n\t<p style=\"font-size: 10px; background: blue;\">line-height: 3</p>\n</div>\n<div style=\"line-height: 300%; font-size: 20px;\">\n\t<p style=\"font-size: 10px; background: red;\">line-height: 300%</p>\n</div>\n```\n\n    <div style=\"line-height: 3em; font-size: 20px;\"><p style=\"font-size: 10px; background: wheat;\">line-height: 3em</p></div><div style=\"line-height: 3; font-size: 20px;\"><p style=\"font-size: 10px; background: lightblue;\">line-height: 3</p></div><div style=\"line-height: 300%; font-size: 20px;\"><p style=\"font-size: 10px; background: salmon;\">line-height: 300%</p></div>\n\n---\n\n### `font` 缩写\n\n> <span style=\"font-family: consolas\">font:[[&lt;font-style&gt;<span style='color: #ddd;'>||&lt;font-variant&gt;</span>||&lt;font-weight&gt;<span style='color: #ddd;'>||&lt;font-stretch&gt;</span>]? &lt;font-size&gt; [/&lt;line-height&gt;]?&lt;font-family&gt;]<span style='color: #ddd;'>|caption|icon|menu|message-box|small-caption|status-bar</span></span>\n\n**解释：**\n\n-   `[<font-style>||<font-variant>||<font-weight>||<font-stretch>]?`说的是：这四个元素都可以写一次或者不写。\n-   `font-size`和`font-family`是必写的属性\n-   举例：\n\n```css\nfont: italic 200 16px /3 \"Microsoft yahei\", Consolas;\n```\n\n---\n\n### `color` 文字颜色\n\n> <span style=\"font-family: consolas\">color:color_name|hex_number|rgb_number</span>\n\n**解释：**\n\n-   `color_name`：规定颜色值为颜色名称的颜色（比如 `red`, `blue`）。当然也可以设成`transparent`（全透明），具体关键词可以参照这里：[color 关键词对照表](#颜色关键值表)\n-   `hex_number`：规定颜色值为十六进制值的颜色（比如 `#ff0000`或`#fff`）\n-   `rgb_number`：规定颜色值为 rgb 代码的颜色（比如`rgb(255,0,0)`）\n-   除此之外，还有一个不是很常用的方法：`hsla()`，就是利用色相-饱和度-明度-阿尔法来定义颜色。比如`hsla(240,100%,50%,0.05)`\n\n## 文本修饰\n\n### `text-shadow` 文字阴影\n\n> <span style=\"font-family: consolas\">text-shadow:none|[&lt;length&gt;{2,3}&&&lt;color&gt;?]#</span>\n\n**解释：**\n\n-   下面这条标签，`text-shadow:10px 20px 10px rgba(0,0,0,0.2);`这个样式，就是用来设置文字阴影的，它可以写**两个或三个长度值**并且指定**颜色**：\n\n```xml\n<p style=\"font-family: Consolas; font-size: 100px; text-shadow:10px 20px 10px rgba(0,0,0,0.2);\">Jackie</p>\n```\n\n    - 第一个长度值：阴影在x轴方向的偏移量\n    - 第二个长度值：阴影在y轴方向的偏移量\n    - 第三个长度值：阴影的模糊半径\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-10-23/24138474.jpg)\n\n### `text-decoration` 设置划线\n\n> <span style=\"font-family: consolas\">text-decoration:none|[underline||overline||line-through]</span>\n\n**解释：**\n\n-   `underline`,`overline`,`line-through`只能设置其中一个，分别表示：下划线，上划线和删除线。\n\n## 文本对齐\n\n### `text-align` 水平对齐\n\n> <span style=\"font-family: consolas\">text-align:left|right|center|justify(左中右两端)</span>\n\n**解释：**\n\n-   一张图理解这个属性：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-10-23/95828562.jpg)\n\n### `vertical-align` 垂直对齐\n\n> <span style=\"font-family: consolas\">vertical-align:baseline|sub|super|top|text-top|middle|bottom|text-bottom|&lt;percentage&gt;|&lt;length&gt;</span>\n\n**解释：**\n\n-   以上这段的解释是：基线 | 下标 | 上标 | (行)顶部 | 文本顶部 | 居中|(行)底部 | 文本底部 | 以`baseline`为起点往上偏移基于行高的百分比 | 以`baseline`为起点往上偏移 `n px/em`\n-   默认是`baseline`,其他各种情况，不想赘述……请大家转而访问这篇更牛逼的博客：[CSS vertical-align 属性详解](http://www.cnblogs.com/hykun/p/3937852.html)以及另外一篇国外博客的译文[(翻译)关于 Vertical-Align 你需要知道的事情](https://segmentfault.com/a/1190000002668492)\n-   重点讲一下`vertical-align`的适用性：\n    1. 一般`vertical-align`属性用于对齐`display`为`inline`和`inline-block`的元素：\n        - `inline`的元素基本上就是文本元素\n        - `inline-block`则是行块元素，高度可以自己设定，也可以是内容决定\n    2. 而`vertical-align`最重要的还是用来垂直居中对齐某些元素\n\n---\n\n### `text-indent` 首行缩进\n\n> <span style=\"font-family: consolas\">text-indent:&lt;length&gt;|&lt;percentage&gt;</span>\n\n**解释：**\n\n-   `text-indent`属性是用来规定首行缩进的，也就是一个元素的首行文本内容之前应该有多少水平空格。\n-   `<length>`就是普通的长度值，不再赘述\n-   `<percentage>`就是相对父元素而言的百分比长度，也不再赘述\n\n---\n\n## 格式处理\n\n### `white-space` 换行/空格的合并\n\n> <span style=\"font-family:consolas\">white-space：normal|nowrap|pre|pre-wrap|pre-line</span>\n\n**解释：**\n\n-   我们知道，在除了`<pre>`标签以外的其他标签中，多个空格、多个制表符（tab）是会合并的，换行也是没有效果的，而且超过元素宽度是会自动换行的。那是因为这些标签的默认`white-space`的值是`normal`。\n-   `white-space`的值的含义：\n    -   `new lines`表示换行是否合并；\n    -   `spaces&tabs`表示制表符和空格是否合并；\n    -   `text wrapping`则表示是否自动换行；\n    -   `collapse`表示换行会合并成一个空格，空格 tab 会和并；\n    -   `wrap`表示自动换行\n    -   `preserve`表示不自动合并\n\n|    value     | new lines | spaces&tabs | text wrapping |\n| :----------: | :-------: | :---------: | :-----------: |\n|  **normal**  | collapse  |  collapse   |     wrap      |\n|  **nowrap**  | collapse  |  collapse   |    no wrap    |\n|   **pre**    | preserve  |  preserve   |    no wrap    |\n| **pre-wrap** | preserve  |  preserve   |     wrap      |\n| **pre-line** | preserve  |  collapse   |     wrap      |\n\n---\n\n### `word-wrap` 设置单词截断\n\n> <span style=\"font-family:consolas\">word-wrap:normal|break-word</span>\n\n**解释：**\n\n-   `word-wrap`是用来在设置是否截断一个宽度过大的单词（仅对 non-CJK 有效，Chinese/Japanese/Korean）。\n-   当啥都不写的时候，会发生这样的情况，浏览器自动截断这句长句子，将后面的东西换一行，而长单词，是不截断的。\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/80140572.jpg)\n-   但是如果赋予`word-wrap:break-word`，就会将`Jackieeeeeeeeeeee`截断：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/61609140.jpg)\n\n---\n\n### `word-break` 设置如何进行单词截断\n\n> <span style=\"font-family:consolas\">word-break:normal|keep-all|break-all</span>\n\n**WTF?**\n好吧，我不应该说脏话的，但是这个的确和上面提到的`break-word`太像了。。。老外是写不出新的单词了吗……\n\n-   不知道大家有没有思考过……为什么`My name is`后面为啥全空白却不利用？那是因为！`word-break`的值默认为`normal`，也就是把太长的单词先换到下一行再说……（当然也仅仅是对 non-CJK 有效）\n-   `keep-all`的表现基本和`normal`一致，只是针对 CJK 语言进行了一个新规定:\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/1931567.jpg)\n-   当`word-break:break-all;`时（无论`word-break`如何），则变成下面这种情形啦！`break-all`本身的意思就是随时都能 break:\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/34985531.jpg)\n-   OK，写了这么多，我做个对比：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/public/16-11-27/4714032.jpg)\n\n---\n\n### `text-overflow` 文本溢出\n\n> <span style=\"font-family:consolas\">text-overflow:clip|ellipsis</span>\n\n**解释：**\n\n-   `text-overflow`用来处理文本溢出的地方\n-   `clip`是默认值，表示文本溢出的地方直接截断。\n-   `ellipsis`表示文本溢出的地方替换成`...`，通常要配合另外两个属性一起写：`overflow:hidden; white-space:nowrap;`，就像这样：\n\n```xml\n<p style=\"width:100px;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;\">hello hello hello</p>\n```\n\n效果：<p style=\"width:100px;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;\">hello hello hello</p>\n\n---\n\n## 颜色关键值表\n\n| 关键字               |   翻译   | RGB 十六进制 |                                                颜色                                                |\n| :------------------- | :------: | :----------: | :------------------------------------------------------------------------------------------------: |\n| black                |    黑    |   #000000    | <span style=\"display:block;background-color:#000000;width:20px;height:20px;margin:0 auto;\"></span> |\n| silver               |    银    |   #c0c0c0    | <span style=\"display:block;background-color:#c0c0c0;width:20px;height:20px;margin:0 auto;\"></span> |\n| gray                 |    灰    |   #808080    | <span style=\"display:block;background-color:#808080;width:20px;height:20px;margin:0 auto;\"></span> |\n| white                |    白    |   #ffffff    | <span style=\"display:block;background-color:#ffffff;width:20px;height:20px;margin:0 auto;\"></span> |\n| maroon               |    褐    |   #800000    | <span style=\"display:block;background-color:#800000;width:20px;height:20px;margin:0 auto;\"></span> |\n| red                  |    红    |   #ff0000    | <span style=\"display:block;background-color:#ff0000;width:20px;height:20px;margin:0 auto;\"></span> |\n| purple               |    紫    |   #800080    | <span style=\"display:block;background-color:#800080;width:20px;height:20px;margin:0 auto;\"></span> |\n| fuchsia              |   紫红   |   #ff00ff    | <span style=\"display:block;background-color:#ff00ff;width:20px;height:20px;margin:0 auto;\"></span> |\n| green                |    绿    |   #008000    | <span style=\"display:block;background-color:#008000;width:20px;height:20px;margin:0 auto;\"></span> |\n| lime                 |   绿黄   |   #00ff00    | <span style=\"display:block;background-color:#00ff00;width:20px;height:20px;margin:0 auto;\"></span> |\n| olive                |  橄榄绿  |   #808000    | <span style=\"display:block;background-color:#808000;width:20px;height:20px;margin:0 auto;\"></span> |\n| yellow               |    黄    |   #ffff00    | <span style=\"display:block;background-color:#ffff00;width:20px;height:20px;margin:0 auto;\"></span> |\n| navy                 |   藏青   |   #000080    | <span style=\"display:block;background-color:#000080;width:20px;height:20px;margin:0 auto;\"></span> |\n| blue                 |    蓝    |   #0000ff    | <span style=\"display:block;background-color:#0000ff;width:20px;height:20px;margin:0 auto;\"></span> |\n| teal                 |    青    |   #008080    | <span style=\"display:block;background-color:#008080;width:20px;height:20px;margin:0 auto;\"></span> |\n| aqua                 |   水绿   |   #00ffff    | <span style=\"display:block;background-color:#00ffff;width:20px;height:20px;margin:0 auto;\"></span> |\n| orange               |    橙    |   #ffa500    | <span style=\"display:block;background-color:#ffa500;width:20px;height:20px;margin:0 auto;\"></span> |\n| aliceblue            |  浅灰蓝  |   #f0f8ff    | <span style=\"display:block;background-color:#f0f8ff;width:20px;height:20px;margin:0 auto;\"></span> |\n| antiquewhite         |  古董白  |   #faebd7    | <span style=\"display:block;background-color:#faebd7;width:20px;height:20px;margin:0 auto;\"></span> |\n| aquamarine           |   海蓝   |   #7fffd4    | <span style=\"display:block;background-color:#7fffd4;width:20px;height:20px;margin:0 auto;\"></span> |\n| azure                |   蔚蓝   |   #f0ffff    | <span style=\"display:block;background-color:#f0ffff;width:20px;height:20px;margin:0 auto;\"></span> |\n| beige                |   浅褐   |   #f5f5dc    | <span style=\"display:block;background-color:#f5f5dc;width:20px;height:20px;margin:0 auto;\"></span> |\n| bisque               |   橘黄   |   #ffe4c4    | <span style=\"display:block;background-color:#ffe4c4;width:20px;height:20px;margin:0 auto;\"></span> |\n| blanchedalmond       |  杏仁白  |   #ffe4c4    | <span style=\"display:block;background-color:#ffe4c4;width:20px;height:20px;margin:0 auto;\"></span> |\n| blueviolet           |   蓝紫   |   #8a2be2    | <span style=\"display:block;background-color:#8a2be2;width:20px;height:20px;margin:0 auto;\"></span> |\n| brown                |    褐    |   #a52a2a    | <span style=\"display:block;background-color:#a52a2a;width:20px;height:20px;margin:0 auto;\"></span> |\n| burlywood            |  原木色  |   #deb887    | <span style=\"display:block;background-color:#deb887;width:20px;height:20px;margin:0 auto;\"></span> |\n| cadetblue            |   灰蓝   |   #5f9ea0    | <span style=\"display:block;background-color:#5f9ea0;width:20px;height:20px;margin:0 auto;\"></span> |\n| chartreuse           |   黄绿   |   #7fff00    | <span style=\"display:block;background-color:#7fff00;width:20px;height:20px;margin:0 auto;\"></span> |\n| chocolate            | 巧克力色 |   #d2691e    | <span style=\"display:block;background-color:#d2691e;width:20px;height:20px;margin:0 auto;\"></span> |\n| coral                |  珊瑚红  |   #ff7f50    | <span style=\"display:block;background-color:#ff7f50;width:20px;height:20px;margin:0 auto;\"></span> |\n| cornflowerblue       | 矢车菊蓝 |   #6495ed    | <span style=\"display:block;background-color:#6495ed;width:20px;height:20px;margin:0 auto;\"></span> |\n| cornsilk             | 玉米穗黄 |   #fff8dc    | <span style=\"display:block;background-color:#fff8dc;width:20px;height:20px;margin:0 auto;\"></span> |\n| crimson              |   深红   |   #dc143c    | <span style=\"display:block;background-color:#dc143c;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkblue             |   深蓝   |   #00008b    | <span style=\"display:block;background-color:#00008b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkcyan             |   深青   |   #008b8b    | <span style=\"display:block;background-color:#008b8b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkgoldenrod        |   暗金   |   #b8860b    | <span style=\"display:block;background-color:#b8860b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkgray             |   深灰   |   #a9a9a9    | <span style=\"display:block;background-color:#a9a9a9;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkgreen            |   深绿   |   #006400    | <span style=\"display:block;background-color:#006400;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkgrey             |   深灰   |   #a9a9a9    | <span style=\"display:block;background-color:#a9a9a9;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkkhaki            |  暗黄褐  |   #bdb76b    | <span style=\"display:block;background-color:#bdb76b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkmagenta          |   深紫   |   #8b008b    | <span style=\"display:block;background-color:#8b008b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkolivegreen       | 深橄榄绿 |   #556b2f    | <span style=\"display:block;background-color:#556b2f;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkorange           |   深橙   |   #ff8c00    | <span style=\"display:block;background-color:#ff8c00;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkorchid           | 深兰花紫 |   #9932cc    | <span style=\"display:block;background-color:#9932cc;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkred              |   深红   |   #8b0000    | <span style=\"display:block;background-color:#8b0000;width:20px;height:20px;margin:0 auto;\"></span> |\n| darksalmon           |  深橙红  |   #e9967a    | <span style=\"display:block;background-color:#e9967a;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkseagreen         |  深海绿  |   #8fbc8f    | <span style=\"display:block;background-color:#8fbc8f;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkslateblue        |  暗灰蓝  |   #483d8b    | <span style=\"display:block;background-color:#483d8b;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkslategray        |   墨绿   |   #2f4f4f    | <span style=\"display:block;background-color:#2f4f4f;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkslategrey        |   墨绿   |   #2f4f4f    | <span style=\"display:block;background-color:#2f4f4f;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkturquoise        | 暗宝石绿 |   #00ced1    | <span style=\"display:block;background-color:#00ced1;width:20px;height:20px;margin:0 auto;\"></span> |\n| darkviolet           | 深紫罗兰 |   #9400d3    | <span style=\"display:block;background-color:#9400d3;width:20px;height:20px;margin:0 auto;\"></span> |\n| deeppink             |  深粉红  |   #ff1493    | <span style=\"display:block;background-color:#ff1493;width:20px;height:20px;margin:0 auto;\"></span> |\n| deepskyblue          |  深天蓝  |   #00bfff    | <span style=\"display:block;background-color:#00bfff;width:20px;height:20px;margin:0 auto;\"></span> |\n| dimgray              |   暗灰   |   #696969    | <span style=\"display:block;background-color:#696969;width:20px;height:20px;margin:0 auto;\"></span> |\n| dimgrey              |   暗灰   |   #696969    | <span style=\"display:block;background-color:#696969;width:20px;height:20px;margin:0 auto;\"></span> |\n| dodgerblue           |  遮板蓝  |   #1e90ff    | <span style=\"display:block;background-color:#1e90ff;width:20px;height:20px;margin:0 auto;\"></span> |\n| firebrick            |   砖红   |   #b22222    | <span style=\"display:block;background-color:#b22222;width:20px;height:20px;margin:0 auto;\"></span> |\n| floralwhite          |   花白   |   #fffaf0    | <span style=\"display:block;background-color:#fffaf0;width:20px;height:20px;margin:0 auto;\"></span> |\n| forestgreen          |  丛林绿  |   #228b22    | <span style=\"display:block;background-color:#228b22;width:20px;height:20px;margin:0 auto;\"></span> |\n| gainsboro            |   浅灰   |   #dcdcdc    | <span style=\"display:block;background-color:#dcdcdc;width:20px;height:20px;margin:0 auto;\"></span> |\n| ghostwhite           |  幽灵白  |   #f8f8ff    | <span style=\"display:block;background-color:#f8f8ff;width:20px;height:20px;margin:0 auto;\"></span> |\n| gold                 |    金    |   #ffd700    | <span style=\"display:block;background-color:#ffd700;width:20px;height:20px;margin:0 auto;\"></span> |\n| goldenrod            |   橘黄   |   #daa520    | <span style=\"display:block;background-color:#daa520;width:20px;height:20px;margin:0 auto;\"></span> |\n| greenyellow          |   黄绿   |   #adff2f    | <span style=\"display:block;background-color:#adff2f;width:20px;height:20px;margin:0 auto;\"></span> |\n| grey                 |    灰    |   #808080    | <span style=\"display:block;background-color:#808080;width:20px;height:20px;margin:0 auto;\"></span> |\n| honeydew             |  蜜瓜色  |   #f0fff0    | <span style=\"display:block;background-color:#f0fff0;width:20px;height:20px;margin:0 auto;\"></span> |\n| hotpink              |   亮粉   |   #ff69b4    | <span style=\"display:block;background-color:#ff69b4;width:20px;height:20px;margin:0 auto;\"></span> |\n| indianred            | 印第安红 |   #cd5c5c    | <span style=\"display:block;background-color:#cd5c5c;width:20px;height:20px;margin:0 auto;\"></span> |\n| indigo               |   靛蓝   |   #4b0082    | <span style=\"display:block;background-color:#4b0082;width:20px;height:20px;margin:0 auto;\"></span> |\n| ivory                |  象牙白  |   #fffff0    | <span style=\"display:block;background-color:#fffff0;width:20px;height:20px;margin:0 auto;\"></span> |\n| khaki                |  卡其色  |   #f0e68c    | <span style=\"display:block;background-color:#f0e68c;width:20px;height:20px;margin:0 auto;\"></span> |\n| lavender             |   淡紫   |   #e6e6fa    | <span style=\"display:block;background-color:#e6e6fa;width:20px;height:20px;margin:0 auto;\"></span> |\n| lavenderblush        |  淡紫红  |   #fff0f5    | <span style=\"display:block;background-color:#fff0f5;width:20px;height:20px;margin:0 auto;\"></span> |\n| lawngreen            |   草绿   |   #7cfc00    | <span style=\"display:block;background-color:#7cfc00;width:20px;height:20px;margin:0 auto;\"></span> |\n| lemonchiffon         |   粉黄   |   #fffacd    | <span style=\"display:block;background-color:#fffacd;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightblue            |   淡蓝   |   #add8e6    | <span style=\"display:block;background-color:#add8e6;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightcoral           | 浅珊瑚色 |   #f08080    | <span style=\"display:block;background-color:#f08080;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightcyan            |   淡青   |   #e0ffff    | <span style=\"display:block;background-color:#e0ffff;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightgoldenrodyellow |  浅金黄  |   #fafad2    | <span style=\"display:block;background-color:#fafad2;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightgray            |   浅灰   |   #d3d3d3    | <span style=\"display:block;background-color:#d3d3d3;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightgreen           |   浅绿   |   #90ee90    | <span style=\"display:block;background-color:#90ee90;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightgrey            |   浅灰   |   #d3d3d3    | <span style=\"display:block;background-color:#d3d3d3;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightpink            |   淡粉   |   #ffb6c1    | <span style=\"display:block;background-color:#ffb6c1;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightsalmon          |  浅肉色  |   #ffa07a    | <span style=\"display:block;background-color:#ffa07a;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightseagreen        |  浅海绿  |   #20b2aa    | <span style=\"display:block;background-color:#20b2aa;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightskyblue         |  浅天蓝  |   #87cefa    | <span style=\"display:block;background-color:#87cefa;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightslategray       |  浅青灰  |   #778899    | <span style=\"display:block;background-color:#778899;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightslategrey       |  浅青灰  |   #778899    | <span style=\"display:block;background-color:#778899;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightsteelblue       |  浅钢蓝  |   #b0c4de    | <span style=\"display:block;background-color:#b0c4de;width:20px;height:20px;margin:0 auto;\"></span> |\n| lightyellow          |   浅黄   |   #ffffe0    | <span style=\"display:block;background-color:#ffffe0;width:20px;height:20px;margin:0 auto;\"></span> |\n| limegreen            |  酸橙绿  |   #32cd32    | <span style=\"display:block;background-color:#32cd32;width:20px;height:20px;margin:0 auto;\"></span> |\n| linen                |  亚麻色  |   #faf0e6    | <span style=\"display:block;background-color:#faf0e6;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumaquamarine     |   中绿   |   #66cdaa    | <span style=\"display:block;background-color:#66cdaa;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumblue           |   中蓝   |   #0000cd    | <span style=\"display:block;background-color:#0000cd;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumorchid         | 间兰花紫 |   #ba55d3    | <span style=\"display:block;background-color:#ba55d3;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumpurple         |   中紫   |   #9370db    | <span style=\"display:block;background-color:#9370db;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumseagreen       |  间海绿  |   #3cb371    | <span style=\"display:block;background-color:#3cb371;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumslateblue      |  中暗蓝  |   #7b68ee    | <span style=\"display:block;background-color:#7b68ee;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumspringgreen    |  中春绿  |   #00fa9a    | <span style=\"display:block;background-color:#00fa9a;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumturquoise      | 中海湖蓝 |   #48d1cc    | <span style=\"display:block;background-color:#48d1cc;width:20px;height:20px;margin:0 auto;\"></span> |\n| mediumvioletred      | 中紫罗兰 |   #c71585    | <span style=\"display:block;background-color:#c71585;width:20px;height:20px;margin:0 auto;\"></span> |\n| midnightblue         |  午夜蓝  |   #191970    | <span style=\"display:block;background-color:#191970;width:20px;height:20px;margin:0 auto;\"></span> |\n| mintcream            | 薄荷乳白 |   #f5fffa    | <span style=\"display:block;background-color:#f5fffa;width:20px;height:20px;margin:0 auto;\"></span> |\n| mistyrose            | 粉玫瑰红 |   #ffe4e1    | <span style=\"display:block;background-color:#ffe4e1;width:20px;height:20px;margin:0 auto;\"></span> |\n| moccasin             |  鹿皮色  |   #ffe4b5    | <span style=\"display:block;background-color:#ffe4b5;width:20px;height:20px;margin:0 auto;\"></span> |\n| navajowhite          |  纳瓦白  |   #ffdead    | <span style=\"display:block;background-color:#ffdead;width:20px;height:20px;margin:0 auto;\"></span> |\n| oldlace              |  浅米色  |   #fdf5e6    | <span style=\"display:block;background-color:#fdf5e6;width:20px;height:20px;margin:0 auto;\"></span> |\n| olivedrab            |  橄榄褐  |   #6b8e23    | <span style=\"display:block;background-color:#6b8e23;width:20px;height:20px;margin:0 auto;\"></span> |\n| orangered            |   橙红   |   #ff4500    | <span style=\"display:block;background-color:#ff4500;width:20px;height:20px;margin:0 auto;\"></span> |\n| orchid               |  兰花紫  |   #da70d6    | <span style=\"display:block;background-color:#da70d6;width:20px;height:20px;margin:0 auto;\"></span> |\n| palegoldenrod        |  灰菊黄  |   #eee8aa    | <span style=\"display:block;background-color:#eee8aa;width:20px;height:20px;margin:0 auto;\"></span> |\n| palegreen            |   苍绿   |   #98fb98    | <span style=\"display:block;background-color:#98fb98;width:20px;height:20px;margin:0 auto;\"></span> |\n| paleturquoise        | 苍宝石绿 |   #afeeee    | <span style=\"display:block;background-color:#afeeee;width:20px;height:20px;margin:0 auto;\"></span> |\n| palevioletred        | 苍紫罗兰 |   #db7093    | <span style=\"display:block;background-color:#db7093;width:20px;height:20px;margin:0 auto;\"></span> |\n| papayawhip           |  木瓜色  |   #ffefd5    | <span style=\"display:block;background-color:#ffefd5;width:20px;height:20px;margin:0 auto;\"></span> |\n| peachpuff            |   桃色   |   #ffdab9    | <span style=\"display:block;background-color:#ffdab9;width:20px;height:20px;margin:0 auto;\"></span> |\n| peru                 |  秘鲁色  |   #cd853f    | <span style=\"display:block;background-color:#cd853f;width:20px;height:20px;margin:0 auto;\"></span> |\n| pink                 |    粉    |   #ffc0cb    | <span style=\"display:block;background-color:#ffc0cb;width:20px;height:20px;margin:0 auto;\"></span> |\n| plum                 |  李子色  |   #dda0dd    | <span style=\"display:block;background-color:#dda0dd;width:20px;height:20px;margin:0 auto;\"></span> |\n| powderblue           |   粉蓝   |   #b0e0e6    | <span style=\"display:block;background-color:#b0e0e6;width:20px;height:20px;margin:0 auto;\"></span> |\n| rosybrown            |  玫瑰粽  |   #bc8f8f    | <span style=\"display:block;background-color:#bc8f8f;width:20px;height:20px;margin:0 auto;\"></span> |\n| royalblue            |   宝蓝   |   #4169e1    | <span style=\"display:block;background-color:#4169e1;width:20px;height:20px;margin:0 auto;\"></span> |\n| saddlebrown          |  马鞍棕  |   #8b4513    | <span style=\"display:block;background-color:#8b4513;width:20px;height:20px;margin:0 auto;\"></span> |\n| salmon               |  鲑肉色  |   #fa8072    | <span style=\"display:block;background-color:#fa8072;width:20px;height:20px;margin:0 auto;\"></span> |\n| sandybrown           |  沙褐色  |   #f4a460    | <span style=\"display:block;background-color:#f4a460;width:20px;height:20px;margin:0 auto;\"></span> |\n| seagreen             |   海绿   |   #2e8b57    | <span style=\"display:block;background-color:#2e8b57;width:20px;height:20px;margin:0 auto;\"></span> |\n| seashell             |  贝壳白  |   #fff5ee    | <span style=\"display:block;background-color:#fff5ee;width:20px;height:20px;margin:0 auto;\"></span> |\n| sienna               |    赭    |   #a0522d    | <span style=\"display:block;background-color:#a0522d;width:20px;height:20px;margin:0 auto;\"></span> |\n| skyblue              |   天蓝   |   #87ceeb    | <span style=\"display:block;background-color:#87ceeb;width:20px;height:20px;margin:0 auto;\"></span> |\n| slateblue            |   青蓝   |   #6a5acd    | <span style=\"display:block;background-color:#6a5acd;width:20px;height:20px;margin:0 auto;\"></span> |\n| slategray            |   青灰   |   #708090    | <span style=\"display:block;background-color:#708090;width:20px;height:20px;margin:0 auto;\"></span> |\n| slategrey            |   青灰   |   #708090    | <span style=\"display:block;background-color:#708090;width:20px;height:20px;margin:0 auto;\"></span> |\n| snow                 |   雪白   |   #fffafa    | <span style=\"display:block;background-color:#fffafa;width:20px;height:20px;margin:0 auto;\"></span> |\n| springgreen          |   春绿   |   #00ff7f    | <span style=\"display:block;background-color:#00ff7f;width:20px;height:20px;margin:0 auto;\"></span> |\n| steelblue            |   铁青   |   #4682b4    | <span style=\"display:block;background-color:#4682b4;width:20px;height:20px;margin:0 auto;\"></span> |\n| tan                  |   棕褐   |   #d2b48c    | <span style=\"display:block;background-color:#d2b48c;width:20px;height:20px;margin:0 auto;\"></span> |\n| thistle              |   苍紫   |   #d8bfd8    | <span style=\"display:block;background-color:#d8bfd8;width:20px;height:20px;margin:0 auto;\"></span> |\n| tomato               |  番茄红  |   #ff6347    | <span style=\"display:block;background-color:#ff6347;width:20px;height:20px;margin:0 auto;\"></span> |\n| turquoise            |   蓝绿   |   #40e0d0    | <span style=\"display:block;background-color:#40e0d0;width:20px;height:20px;margin:0 auto;\"></span> |\n| violet               | 紫罗兰色 |   #ee82ee    | <span style=\"display:block;background-color:#ee82ee;width:20px;height:20px;margin:0 auto;\"></span> |\n| wheat                |   麦色   |   #f5deb3    | <span style=\"display:block;background-color:#f5deb3;width:20px;height:20px;margin:0 auto;\"></span> |\n| whitesmoke           |   烟白   |   #f5f5f5    | <span style=\"display:block;background-color:#f5f5f5;width:20px;height:20px;margin:0 auto;\"></span> |\n| yellowgreen          |   黄绿   |   #9acd32    | <span style=\"display:block;background-color:#9acd32;width:20px;height:20px;margin:0 auto;\"></span> |\n| rebeccapurple        | 利百加紫 |   #663399    | <span style=\"display:block;background-color:#663399;width:20px;height:20px;margin:0 auto;\"></span> |\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"浅析JS模块化规范：CommonJS，AMD，CMD","url":"/blog/2016/10/17/2016-10-17 浅析JS模块化规范：CommonJS，AMD，CMD/","content":"\n## 模块化编程的进化过程\n\n### 原始写法\n\n这种做法的缺点很明显：\"污染\"了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。\n\n```js\nfunction m1() {\n  //...\n}\nfunction m2() {\n  //...\n}\n```\n\n### 对象写法\n\n这样的写法会暴露所有模块成员，内部状态可以被外部改写。\n\n```js\nvar module1 = new Object({\n  _count: 0,\n  m1: function () {\n    //...\n  },\n  m2: function () {\n    //...\n  },\n});\n```\n\n### 立即执行函数写法\n\n使用\"立即执行函数\"（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。\n\n```js\nvar module1 = (function () {\n  var _count = 0;\n  var m1 = function () {\n    //...\n  };\n  var m2 = function () {\n    //...\n  };\n  return {\n    m1: m1,\n    m2: m2,\n  };\n})();\n```\n\nJavaScript 模块的基本写法，之后对这种写法继续加工。\n\n### 放大模式\n\n继承其他模块，放大模式（augmentation）\n\n```js\nvar module1 = (function (mod) {\n  mod.m3 = function () {\n    //...\n  };\n  return mod;\n})(module1);\n```\n\n以上代码说明的是：module1 模块添加了一个新方法 m3()，然后返回新的 module1 模块\n\n### 宽放大模式\n\n有可能被继承的模块不存在，就会加载一个不存在的空对象，这时就要采用“款放大模式”\n\n```js\nvar module1 = (function (mod) {\n  //...\n  return mod;\n})(window.module1 || {});\n```\n\n### 输入全局变量\n\n独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\n为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\n\n```js\nvar module1 = (function ($, YAHOO) {\n  //...\n})(jQuery, YAHOO);\n```\n\n## 模块规范\n\n### CommonJS\n\n#### 编写模块\n\n根据 CommonJS 规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。\n通过`exports`或者`module.exports`来导出需要暴露的接口\n\n#### 加载模块\n\n`require()`函数用于加载模块：\n\n```js\nvar math = require(\"math\");\nmath.add(2, 3); // 5\n```\n\n**浏览器环境**：加载模块会导致浏览器阻塞，所以要采用“异步加载”方式，也就是 AMD 规范诞生的背景。所以 CommonJS 更适合服务器环境。\n\n#### 评价\n\n##### 优点\n\n- 服务器端模块便于重用\n- NPM 中已经有将近 20 万个可以使用模块包\n- 简单并容易使用\n\n##### 缺点\n\n- 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的\n- 不能非阻塞的并行加载多个模块\n\n### AMD\n\n异步模块定义，AMD 是\"Asynchronous Module Definition\"的缩写.\n\n#### 定义模块\n\n```js\ndefine(id?, dependencies?, factory);\n```\n\n- ID: 是一个字符串，表示模块标识。可以省略，则会定义一个匿名模块。\n- dependencies: 是一个数组，成员是依赖模块的 id。可以省略，默认的依赖是：[\"require\", \"exports\", \"module\"]\n- factory：是一个回调函数，在依赖的模块加载成功后，会执行这个回调函数\n\n一般写法：\n\n```js\ndefine(\"adder\", [\"math\"], function (math) {\n  return {\n    addTen: function (x) {\n      return math.add(x, 10);\n    },\n  };\n});\n```\n\n默认依赖：\n\n```js\ndefine(\"adder\", function (require, exports) {\n  exports.addTen = function (x) {\n    return x + 10;\n  };\n});\n```\n\n匿名模块：\n\n```js\ndefine([\"math\"], function (math) {\n  return {\n    addTen: function (x) {\n      return math.add(x, 10);\n    },\n  };\n});\n```\n\n兼容 CommonJS(匿名+默认依赖)：\n\n```js\n// module app/mime-client\ndefine(function (require, exports, module) {\n  var rest, mime, client;\n\n  rest = require(\"rest\");\n  mime = require(\"rest/interceptor/mime\");\n\n  client = rest.chain(mime);\n\n  module.exports = client;\n});\n```\n\n#### exports 写法\n\n1. 通过`exports`暴露接口\n\n```js\ndefine(function (require, exports) {\n  exports.foo = \"bar\"; // 对外提供 foo 属性\n  exports.doSomething = function () {}; // 对外提供 doSomething 方法\n});\n```\n\n2. 通过`return`暴露接口\n\n```js\ndefine(function (require) {\n  // 通过 return 直接提供接口\n  return {\n    foo: \"bar\",\n    doSomething: function () {},\n  };\n});\n```\n\n3. 如果`return`是模块中唯一的代码，还可以写成这样：\n\n```js\ndefine({\n  foo: \"bar\",\n  doSomething: function () {},\n});\n```\n\n4. 错误的写法：\n\n```js\ndefine(function (require, exports) {\n  // 错误用法！！!\n  exports = {\n    foo: \"bar\",\n    doSomething: function () {},\n  };\n});\n```\n\n5. 正确的写法是用`return`或者给`module.exports`赋值：\n\n```js\ndefine(function (require, exports, module) {\n  // 正确写法\n  module.exports = {\n    foo: \"bar\",\n    doSomething: function () {},\n  };\n});\n```\n\n**提示**：提示：`exports`仅仅是`module.exports`的一个引用。在`factory`内部给`exports`重新赋值时，并不会改变`module.exports`的值。因此给`exports`赋值是无效的，不能用来更改模块接口。\n\n#### 加载模块\n\n有两个参数，当模块加载完之后，才调用回调函数，第一个参数是一个数组，成员就是要加载的模块\n\n```js\nrequire([module], callback);\n//example:\nrequire([\"math\"], function (math) {\n  math.add(2, 3);\n});\n```\n\n目前，主要有两个 Javascript 库实现了 AMD 规范：require.js 和 curl.js。\n\n#### requireJS\n\nRequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块）。\n贴上[阮一峰的 requireJS 教程](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n\n##### 引入 requireJS\n\n- 普通方式：\n\n```js\n<script src=\"js/require.js\"></script>\n```\n\n- 异步加载方式(`async`属性表明这个文件需要异步加载，避免网页失去响应。IE 不支持这个属性，只支持`defer`，所以把 defer 也写上)：\n\n```js\n<script src=\"js/require.js\" defer async=\"true\"></script>\n```\n\n- 最普遍的写法：\n\n```js\n<script data-main=\"scripts/main\" src=\"scripts/require.js\"></script>\n```\n\n`data-main`属性的作用是，指定网页程序的主模块。在上例中，就是 js 目录下面的`main.js`，这个文件会第一个被`require.js`加载。由于`require.js`默认的文件后缀名是 js，所以可以把`main.js`简写成 main。\n\n##### main.js 的写法\n\nrequire()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。\n\n```js\n// main.js\nrequire([\"moduleA\", \"moduleB\", \"moduleC\"], function (\n  moduleA,\n  moduleB,\n  moduleC\n) {\n  // some code here\n});\n```\n\n代码含义：主模块的依赖模块是`['moduleA', 'moduleB', 'moduleC']`。默认情况下，`require.js`假定这三个模块与`main.js`在同一个目录，文件名分别为`moduleA.js`，`moduleB.js`和`moduleC.js`，然后自动加载。回调函数的参数只要位置对应即可，不一定要同名。\n\n##### require.config() 自定义加载\n\nrequire.config()就写在主模块（main.js）的头部，参数为一个对象。\n\n```js\nrequire.config({\n  paths: {\n    jquery: \"lib/jquery.min\",\n    underscore: \"lib/underscore.min\",\n    backbone: \"lib/backbone.min\",\n  },\n});\n//或者\nrequire.config({\n  baseUrl: \"js/lib\",\n  paths: {\n    jquery: \"jquery.min\",\n    underscore: \"underscore.min\",\n    backbone: \"backbone.min\",\n  },\n});\n```\n\n##### 加载非 AMD 规范的模块\n\n举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。\n\n```js\nrequire.config({\n  shim: {\n    underscore: {\n      exports: \"_\",\n    },\n    backbone: {\n      deps: [\"underscore\", \"jquery\"],\n      exports: \"Backbone\",\n    },\n  },\n});\n```\n\n1. exports 值（输出的变量名），表明这个模块外部调用时的名称；\n2. deps 数组，表明该模块的依赖性。\n\n#### 评价\n\n##### 优点\n\n- 适合在浏览器环境中异步加载模块\n- 可以并行加载多个模块\n\n##### 缺点\n\n- 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅\n- 不符合通用的模块化思维方式，是一种妥协的实现\n\n### CMD\n\n`Common Module Definition`规范和`AMD`很相似，尽量保持简单，并与`CommonJS`和`Node.js`的`Modules`规范保持了很大的兼容性。在`Sea.js`中实现。\n[**官方文档**：CMD 模块定义规范](https://github.com/seajs/seajs/issues/242)\n\n#### 定义模块\n\n和 AMD 标准定义模块的方式一致，但有一些不同，主要表现在增加了一些对象：\n\n- `define.cmd`：一个空对象，可用来判定当前页面是否有 CMD 模块加载器\n\n```js\nif (typeof define === \"function\" && define.cmd) {\n  // 有 Sea.js 等 CMD 模块加载器存在\n}\n```\n\n- `require.async(id, callback?)`\n  用来在模块内部异步加载模块，并在加载完成后执行指定回调。\n\n```js\ndefine(function (require, exports, module) {\n  //异步加载一个模块，在加载完成时，执行回调\n  require.async(\"./b\", function (b) {\n    b.doSomething();\n  });\n  // 异步加载多个模块，在加载完成时，执行回调\n  require.async([\"./c\", \"./d\"], function (c, d) {\n    c.doSomething();\n    d.doSomething();\n  });\n});\n```\n\n- `require.resolve(id)`\n  使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。\n\n```js\ndefine(function (require, exports) {\n  console.log(require.resolve(\"./b\"));\n  // ==> http://example.com/path/to/b.js\n});\n```\n\n#### 评价\n\n与 RequireJS 的 AMD 规范相比，CMD 规范尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。\n","tags":["FrontEnd","JavaScript"]},{"title":"CSS@4单位","url":"/blog/2016/09/26/2016-09-26 CSS@4单位/","content":"\n## CSS 长度单位\n\n### 绝对单位\n\n| 单位 |    全称    | 描述                              |\n| :--: | :--------: | :-------------------------------- |\n|  in  |    inch    | 英寸                              |\n|  cm  | centimeter | 厘米                              |\n|  mm  | millimeter | 毫米                              |\n|  pt  |   point    | 磅（印刷单位，大小为 1/72 英寸）  |\n|  pc  |    Pica    | 派卡（印刷单位，大小为 1/6 英寸） |\n|  px  |   pixel    | 像素                              |\n\n绝对单位没啥好解释的，顶多会在`px`和`pt`之间的区别有点疑问：\n\n-   `pt`是一个印刷单位，不管在任何的地方，任何的显示器上，都是一样长的，都是 1/72 英寸。\n-   `px`就不一样了，在不同 PPI(Pixels Per Inch)的设备上，一个像素的长度是不一样的。PPI 高的地方，说明像素点密集，一个`px`的长度也就短。\n-   这两者之间的具体区别可以见这篇文章：[《CSS 长度单位：px 和 pt 的区别》](http://www.cnblogs.com/chinhr/archive/2008/01/23/1049576.html)\n\n### 相对单位\n\n| 单位 |                     全称                     | 描述                      |\n| :--: | :------------------------------------------: | :------------------------ |\n|  %   |                  percentage                  | 百分比                    |\n|  ch  |                      ？                      | 当前字体的字符\"0\"的宽度   |\n|  em  |                equal-M-width                 | 当前字体的大写\"M\"的宽度   |\n|  ex  |                equal-x-height                | 当前字体的小写\"x\"的高度   |\n| rem  |              root equal-M-width              | 根节点字体的大写\"M\"的宽度 |\n|  vh  |    1/100th of the height of the viewport     | 视窗高度的百分之一        |\n|  vw  |     1/100th of the width of the viewport     | 视窗宽度的百分之一        |\n| vmin | 1/100th of the minimum value of the viewport | 视窗较短边的百分之一      |\n| vmax | 1/100th of the maximum value of the viewport | 视窗较长边的百分之一      |\n\n当然其他还有很多距离单位，我可能没法完全收集齐，但是我会后续补充。\n然后就简单谈一下这些单位的一些具体的注意事项吧：\n\n-   关于`%`，就很简单，相对于父元素而言，`width:300%`就是父元素高度的三倍；\n-   关于`ch`：[Eric Meyer's 的博客](http://meyerweb.com/eric/thoughts/2012/05/15/defining-ch/)有谈到：对于一种等宽字体，如果你给出一个`width: 40ch;`的盒子，那么就可以刚好容纳 40 个这种字体的字符。一般和盲文相关。\n-   关于`rem`：一般用于网格布局，使得界面能随着内容按照比例缩放。\n-   关于还算比较具体的一个 CSS 单位的支持度的图片，具体可以用[Can I Use](caniuse.com)来测试：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-9-27/83271961.jpg)\n\n## 角度单位\n\n| 单位 | 全称   | 描述   |\n| :--: | :----- | :----- |\n| deg  | degree | 角度   |\n| grad | grad   | 百分度 |\n| rad  | radian | 弧度   |\n| turn | turn   | 圈数   |\n\n-   这些单位一般而言，正的就是顺时针转，负数代表逆时针转。\n-   `deg`: 就是角度，就是一个整圆 360°，`1deg`就是`1°`\n-   `grad`: 百分度，一个整圆切成 400 份，`1grad = 360°/400`\n-   `rad`: 弧度，初中知识，`1rad = 180°/π`\n-   `turn`: 这个就更简单了，`1turn = 360°`\n\n## 时间单位\n\n| 单位 | 全称        | 描述 |\n| :--: | :---------- | :--- |\n|  s   | second      | 秒   |\n|  ms  | millisecond | 毫秒 |\n\n## 频率单位\n\n一般用于听（或说）级联样式表中，用来表示声音频率。\n\n| 单位 | 全称      | 描述 |\n| :--: | :-------- | :--- |\n|  hz  | hertz     | 赫兹 |\n|  ms  | kilohertz | 千赫 |\n\n```css\np.low {\n    pitch: 105hz;\n}\nq.squeal {\n    pitch: 135hz;\n}\n```\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@3继承优先级","url":"/blog/2016/09/14/2016-09-14 CSS@3继承优先级/","content":"\n## CSS 的继承、优先级、层叠\n\n### CSS 的继承\n\n有些元素的样式是可以被子元素继承的，大概包括这些，其中橙色的是文本相关的，蓝色的是列表相关的：\n\n-   <span style=\"font-family: consolas;\">azimuth</span>\n-   <span style=\"font-family: consolas;\">border-collapse</span>\n-   <span style=\"font-family: consolas;\">border-spacing</span>\n-   <span style=\"font-family: consolas;\">caption-side</span>\n-   <span style=\"font-family: consolas; color:orange;\">color</span>\n-   <span style=\"font-family: consolas;\">cursor</span>\n-   <span style=\"font-family: consolas;\">direction</span>\n-   <span style=\"font-family: consolas;\">elevation</span>\n-   <span style=\"font-family: consolas;\">empty-cells</span>\n-   <span style=\"font-family: consolas; color:orange;\">font-family</span>\n-   <span style=\"font-family: consolas; color:orange;\">font-size</span>\n-   <span style=\"font-family: consolas; color:orange;\">font-style</span>\n-   <span style=\"font-family: consolas; color:orange;\">font-variant</span>\n-   <span style=\"font-family: consolas; color:orange;\">font-weight</span>\n-   <span style=\"font-family: consolas; color:orange;\">font</span>\n-   <span style=\"font-family: consolas; color:orange;\">letter-spacing</span>\n-   <span style=\"font-family: consolas; color:orange;\">line-height</span>\n-   <span style=\"font-family: consolas; color:blue;\">list-style-image</span>\n-   <span style=\"font-family: consolas; color:blue;\">list-style-position</span>\n-   <span style=\"font-family: consolas; color:blue;\">list-style-type</span>\n-   <span style=\"font-family: consolas; color:green;\">list-style</span>\n-   <span style=\"font-family: consolas;\">orphans</span>\n-   <span style=\"font-family: consolas;\">pitch-range</span>\n-   <span style=\"font-family: consolas;\">pitch</span>\n-   <span style=\"font-family: consolas;\">quotes</span>\n-   <span style=\"font-family: consolas;\">richness</span>\n-   <span style=\"font-family: consolas;\">speak-header</span>\n-   <span style=\"font-family: consolas;\">speaknumeral</span>\n-   <span style=\"font-family: consolas;\">speak-punctuation</span>\n-   <span style=\"font-family: consolas;\">speak</span>\n-   <span style=\"font-family: consolas;\">speech-rate</span>\n-   <span style=\"font-family: consolas;\">stress</span>\n-   <span style=\"font-family: consolas; color:orange;\">text-align</span>\n-   <span style=\"font-family: consolas; color:orange;\">text-indent</span>\n-   <span style=\"font-family: consolas;\">text-transform</span>\n-   <span style=\"font-family: consolas;\">visibility</span>\n-   <span style=\"font-family: consolas;\">voice-family</span>\n-   <span style=\"font-family: consolas;\">volume</span>\n-   <span style=\"font-family: consolas;\">white-space</span>\n-   <span style=\"font-family: consolas;\">widows</span>\n-   <span style=\"font-family: consolas; color:orange;\">word-spacing</span>\n\n### 优先级\n\n经常会遇到的一个问题，如果多次对一个元素声明样式，到底哪次声明才有效呢？这就要考虑到优先级的问题了。一般来说会对每一次样式的声明都计算一次优先级权值，这个权值比较大的，拥有比较高的优先级，也就是说话最有权力，当然这只是比较简单的说法，具体的规则如下：\n\n1. 每个选择器都有一个权值，权值越大的优先级越高。\n2. 权值相等时，后出现的覆盖先出现的。\n3. 用 JS 代码指定的样式，相当于增加了一段行内样式。\n4. `!important`规则的优先级最大（这条规则只适用于支持`!important`的浏览器，像 IE6 这样的就不支持）\n\n#### 规则一：关于选择器权值的计算\n\n-   A. 行内样式数 \\* 1000（行内样式就是写在标签的`style`属性中的样式）\n-   B. id 选择器数量 \\* 100\n-   C. 类、伪类选择器和属性选择器数量 \\* 10\n-   D. 标签选择器和伪元素选择器数量 \\* 1\n\n**最终的权值 = A + B + C + D**\n举个例子：\n\n```xml\n<html>\n  <head>\n    <style type=\"text/css\">\n        /* #grandparent为ID选择器，权值为100；.parent和.child都是类选择器，权值为10；*/\n        /* 权值 = 100 + 10 + 10 = 120*/\n        #grandparent .parent .child{\n          color: red;\n        }\n        /* #grandparent为ID选择器，权值为100；.parent是类选择器，权值为20； p是标签选择器，权值为1*/\n        /* 权值 = 100 + 10 + 1 = 111*/\n        #grandparent .parent p{\n          color: blue;\n        }\n        /* #grandparent为ID选择器，权值为100， .child都是类选择器，权值为10；*/\n        /* 权值 = 100 + 10 = 110*/\n        #grandparent .child{\n          color: green;\n        }\n    </style>\n  </head>\n  <body>\n    <div id=\"grandparent\">\n     <div class=\"parent\">\n         <p class=\"child\">Which color?</p>\n     </div>\n     </div>\n  </body>\n</html>\n```\n\n所以最终的效果应该是，`which color？`呈现出红色。\n\n#### 规则二：关于先后覆盖的一个例子\n\n这个例子很简单，就是当权值一样的时候，后面的样式覆盖前面的样式。举例：\n\n```xml\n<html>\n  <head>\n    <style type=\"text/css\">\n        #grandparent .child_b{\n          color: red;\n        }\n        #grandparent .child_a{\n          color: blue;\n        }\n    </style>\n  </head>\n  <body>\n    <div id=\"grandparent\">\n     <div class=\"parent\">\n         <p class=\"child_a child_b\">Which color?</p>\n     </div>\n     </div>\n  </body>\n</html>\n```\n\n当然，最后是呈现出蓝色的。\n\n#### 规则三：使用 JavaScript 添加脚本的一个例子\n\n```xml\n<html>\n<head>\n    <style type=\"text/css\">\n    #parent{\n        color: red;\n    }\n    </style>\n</head>\n\n<body>\n    <div id=\"parent\">\n        <p id=\"child\">Which color?</p>\n    </div>\n    <script type=\"text/javascript\">\n        var child = document.getElementById(\"child\");\n        child.style.color = \"blue\";\n    </script>\n</body>\n</html>\n```\n\n最终的结果中，发现 child 元素多出了一行行内样式：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-9-26/20024983.jpg)\n\n#### 规则四：使用`!important`覆盖\n\n```xml\n<html>\n<head>\n    <style type=\"text/css\">\n    #parent #child{\n        color: red;\n    }\n    p{\n      color: yellow !important;\n    }\n    </style>\n</head>\n\n<body>\n    <div id=\"parent\">\n        <p id=\"child\" sytle=\"color: blue\">Which color?</p>\n    </div>\n</body>\n</html>\n```\n\n这段代码，即便 ID 选择器和行内样式权值都很大，然而`!important`还是最有话语权；这样看来`!important`是不是有种钦定的感觉……\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@2选择器","url":"/blog/2016/09/13/2016-09-13 CSS@2选择器/","content":"\n## **CSS 选择器**\n\nOK，先来普及一下选择器是什么：\n假如你是造物主，你需要捏造一个个的人，而 HTML 文档中的一个个标签则是一个个人，你要从茫茫人海中挑选出一个或者一部分人来为他们声明他们的样式，这个时候你可能会需要一个工具，那就是选择器的功能，将你要选的一个或一部分标签选出来，并为他们声明样式。\n\n### **简单选择器**\n\n#### **标签选择器**\n\n根据标签名选出对应的标签，如：\n假如想选出这个文档中所有的`<p>`标签，并声明它们包含的文字颜色应该是蓝色的：\n\n```css\np {\n  color: blue;\n}\n```\n\n#### **类选择器**\n\n**符号`.` + 类名**：根据类名(class)选出对应的标签，如：\n假如想选出这个文档中所有的属性`class`等于`special`的标签，并声明它们的宽度为 20px：\n\n```css\n.special {\n  width: 20px;\n}\n```\n\n#### **ID 选择器**\n\n**符号`#` + ID 名**：根据 ID 选出对应的标签，如：\n假如想选出这个文档中的属性`id`等于`special`的标签，并声明它们的背景颜色为红色：\n\n```css\n#special {\n  background-color: red;\n}\n```\n\n#### **通配符选择器**\n\n符号`*`：用于选择所有元素\n\n```css\n* {\n  color: blue;\n}\n```\n\n#### **属性选择器[att]**\n\n`[att]{ css code }`: 用来选出某些带有特殊属性的标签。\n\n- 最普通的：\n  假如需要选出带有`disabled`属性的标签，设置它们的背景颜色为蓝色：\n\n```css\n[disabled] {\n  background-color: blue;\n}\n```\n\n- `=`（等于）\n  假如需要选出`value`属性等于`abc`的标签，设置它们的背景颜色为蓝色：\n\n```css\n[value=\"abc\"] {\n  background-color: blue;\n}\n```\n\n- `~=`（包含）\n  假如需要选出`class`属性包含`special`字段的标签，设置它们的背景颜色为蓝色：\n\n```css\n[class~=\"special\"] {\n  background-color: blue;\n}\n```\n\n    ​```xml\n    <p class=\"special\">能被选中</p>\n    <p class=\"special abc\">能被选中</p>\n    <p class=\"abspecialc\">不能被选中</p>\n    ​```\n\n- `|=`（选择 xx 和 xx-）\n  OK，此处不多说，都在代码里了：\n\n```css\n[lang|=\"en\"] {\n  color: blue;\n} //(这个属性选择器可以选择en以及en-这些标签)\n```\n\n    ​```xml\n    <p lang=\"en\">能被选中</p>\n    <p lang=\"en-us\">能被选中</p>\n    <p lang=\"en-au\">能被选中</p>\n    <p lang=\"en fr\">无法被选中</p>\n    <p lang=\"cy-en\">无法被选中</p>\n    ​```\n\n- `^=`（匹配属性值开头）\n  比如，你需要选出带有以`https`开头的`href`属性的标签：\n\n```css\n[href^=\"https\"] {\n  ...;\n}\n```\n\n- `$=`(匹配属性值结尾)\n  基本同上。\n- `*=`（匹配字符串）\n  假如你需要找出`href`属性值的字符串中包含`\"jackie\"`的标签：\n\n```css\n[href*=\"jackie\"] {\n  ...;\n}\n```\n\n    这和`~=`最大的区别就在于，同样是`[href~=jackie]`和`[href*=jackie]`，前者无法匹配到`href='jackie-anxis.com'`而后者可以，因为前者只能匹配到关键词前后都是空格的那些标签，比如`href='jackie anxis'`。\n\n#### **伪类选择器**\n\n1. 可以用来选出具有特定样式的标签：\n\n```xml\n<a href=\"http://jackie-anxis.com/\">叫Jackie的咸鱼</a>\n```\n\n    如下面所示：`link`和`visited`属性的伪类选择器只用于链接标签，`hover`和`active`可用于其他标签。\n    ​```css\n    a:link{color:gray;}\t/*用于选中带有连接的a类*/\n    a:visited{color:red;}\t/*用来表示访问过的链接*/\n    a:hover{color:green;}\t/*鼠标悬停样式*/\n    a:active{color:green;}\t/*鼠标点击样式*/\n    ​```\n    如果对一个链接标签写以上四种不同的伪类选择器，那么需要按照以下顺序来写，不然会失效。除了以上介绍之外，其他常用的还有：\n    ​```css\n    input:enabled{color:red;} /*处于可用状态的input标签*/\n    input:disabled{color:red;} /*处于不可用状态的input标签*/\n    input:checked{color:red;} /*处于选中或焦聚状态的input标签*/\n    ​```\n\n2. 可以选出特定的子元素：\n   比如，有如下结构：\n\n```xml\n<div>\n\t<p>1</p><p>2</p><p>3</p><p>4</p>\n</div>\n```\n\n    如果要选出这个结构中的第一个子元素`<p>1</P>`，并设置文字颜色为蓝色，可以这么写：\n    ​```css\n    p:first-child{color:blue;}\n    ​```\n    除此之外，还可以选最后一个子元素`:last-child{}`，或者自定义：`:nth-child(...){}`（括号中的...可以替换成odd，even或者一个表达式如3n+1等等）\n    当然，需要注意的是：<span style=\"color:orange\">这个伪类选择器的头部（冒号前的部分）需要是子元素</span>，比如这个例子中，是`p:first-child`，意思是作为第一个子元素的p标签。\n\n3. 其他一些：\n\n- `:only-child{}`选中只有一个子元素的列表\n- `dd:first-of-type{}`选中 dd 这种标签的第一个元素(`last-of-type`, `nth-of-type(...){}`,`nth-last-of-type(...){}`)\n- 不常用的有这些：\n  - `:empty` 选中没有子元素的标签\n  - `:root` 选中`<html>`这个根标签\n  - `:not()` 选中不包含某个选择器的元素,括号里放简单选择器\n  - `:target` 选中一些被锚点选中为目标的目标元素\n  - `:lang()` 选中 language 值是特殊值的某些元素\n\n#### **伪元素选择器**\n\n伪元素选择器就比较少，基本上就以下几个：\n\n- `:first-line{}`：向文本的首行设置特殊样式。比如：\n\n```CSS\np:first-line{\n  color:#ff0000;\n  font-variant:small-caps;\n}\n```\n\n    `first-line`只作用于块级元素，简单而言就是说，这个元素是会有很多行的。\n\n- `:first-letter{}`用于向文本的首字母设置特殊样式。同样也只适用于块级元素。\n- `:before{}`用于在元素的内容前面插入新内容。比如，需要在`<p>`元素之前插入一张图片：\n\n```CSS\np:before{\n\tcontent: url(logo.gif);\n}\n```\n\n- `:after{}`用于在元素后面插入新内容，原理同`:before`\n- `:selection{}`用于调整用户选中的内容：\n\n```css\n:selection {\n  color: red;\n  background-color: #ccc;\n}\n```\n\n- **注释**：伪元素选择器是可以和一般的选择器配合使用的，关于伪元素选择器更加详细的资料也可参考：[CSS 伪元素 (Pseudo-elements)](http://www.w3school.com.cn/css/css_pseudo_elements.asp)\n\n### **组合选择器**\n\n#### **后代选择器：空格` `**\n\n比如有如下结构：\n\n```xml\n<div class=\"main\">\n\t<h2>标题1</h2>\n\t<div>\n\t\t<h2>标题2</h2>\n\t</div>\n</div>\n```\n\n想要选出 main 类下面的所有 h2 标签，可以这么做：`.main h2{}`。\n所以你懂了，后代选择器就是用来选出某个元素的这些后代元素的（不光是子元素，可能是孙元素）。空格` `代表的是后代的意思。\n\n#### **子选择器：`>`**\n\n还是上面 1 里面那个例子，如果你只想选出“标题 1”而不想选出“标题 2”，那你就需要一个子选择器，子选择器`>`（大于号）只会选出直接的子元素：`.main>h2{}`\n\n#### **兄弟选择器：`+`和`~`**\n\n又比如有以下的结构：\n\n```xml\n<div>\n\t<h2>标题</h2>\n\t<p>段落1</p>\n\t<p>段落2</p>\n</div>\n```\n\n我们姑且把`div`下的三个子元素分别称为*老大*（标题），_老二_（段落 1）和*老三*（段落 2）吧。\n\n- 第一种情况： 如果想要选出老大的第一个弟弟，也就是老二，可以通过兄弟选择器`+`来实现：`h2+p{}`。（你当然可以通过前面说过的伪元素选择器来实现）\n  所以你懂了，`a+b`的意思就是选出 a 的第一个弟弟，而且这个弟弟还必须叫 b，否则就找不到。\n- 第二种情况：你想要找到老大的所有的标签为`<p>`弟弟，你就需要第二个兄弟选择器：`~`。可以这么做：`h2~p{}`。而且不一定要相邻，只要是标签`h2`的`<p>`弟弟都能找到。\n\n#### **选择器分组**\n\n很多有一样样式的选择器你可以写到一起，比如：\n\n```css\nh1 {\n  color: gray;\n  font-family: sans-serif;\n}\nh2 {\n  color: gray;\n  font-family: sans-serif;\n}\nh3 {\n  color: gray;\n  font-family: sans-serif;\n}\n```\n\n你可以写成：\n\n```css\nh1,\nh2,\nh3 {\n  color: gray;\n  font-family: sans-serif;\n}\n```\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"CSS@1介绍和准备","url":"/blog/2016/08/18/2016-08-18 CSS@1介绍和准备/","content":"\n### 推荐\n\n[CSS3 参考手册](http://www.css88.com/book/css/)，啥都有的参考网站\n\n### **引入 CSS**\n\n三种方法用于在 HTML 文档中引入 CSS：\n\n1. 外部样式表\n\n```xml\n<head>\n\t<link rel=\"stylesheet\" href=\"base.css\">\n</head>\n```\n\n2. 内部样式表\n\n```xml\n<head>\n\t<style type=\"text/css\">\n\t\tbody{background-color:read;}\n\t\tp{margin-left:20px;}\n\t</style>\n</head>\n```\n\n3. 内嵌样式表\n   不利于后期的维护，静态页面不建议\n\n```xml\n<p style=\"color:read;margin-left:20px;\">\n\tthis is a paragragh.\n</p>\n```\n\n### **CSS 语法**\n\n#### **基本语法**\n\n```CSS\nselector{\n\tproperty: value;\n}\n```\n\n**selector**：选择器，也就是指明样式应用的对象。因为你写 CSS 样式时，必须要指名道姓的说，我这些样式是写给谁谁谁的，所以必须要用选择器把样式应用的对象挑选出来。\n**property**：性质或者称为属性。\n**value**：属性的值。\n\n可以这么认为，如果 CSS 是一套房子的装修方案，那么 selector 就可以认为是物品的名字，property 就是物品的属性，value 则是这个属性的值。比如你想要把东墙，西墙的背景颜色刷成蓝色，墙上写的字体都要是微软雅黑，你可以这么写：\n\n```CSS\neast_wall, west_wall{ //东墙和西墙\n\tbackground-color: blue; //背景颜色为蓝色\n\tfont-family: Microsoft yahei; //字体为微软雅黑\n}\n```\n\n---\n\n#### **浏览器私有属性**\n\n有时候，有些属性只有某些浏览器实现了，或者说在不同的浏览器中，不同属性的名称叫法不一样，这时，就需要在属性前加上必要的前缀，常见浏览器和它们的私有属性的对应关系如下：\n\n| browser        | prefix   |\n| -------------- | -------- |\n| chrome, safari | -webkit- |\n| firefox        | -moz-    |\n| IE             | -ms-     |\n| opera          | -o-      |\n\n举个例子，以前圆角属性`border-radius`还未在所有浏览器普及的时候，需要这么写 CSS：\n\n```CSS\n-webkit-border-radius: 50%;\n-o-border-radius: 50%;\n-moz-border-radius: 50%;\n-ms-border-radius: 50%;\nborder-radius: 50%;\n```\n\n---\n\n#### **属性值语法**\n\n因为我们后面会介绍不同的属性，属性的值必须要符合一定语法，其实这和正则表达式比较像的，比如，background-color 是颜色，它的值可能就是一个关键词（如 blue, red）或者 16 进制 RGB 值（#ffffff 或#fff 表示白色)，而 border-width 是边框宽度，那可能就是一个数字。我们这里要讲的，就是说明如何表示属性值的规则。OK，来举个栗子：\n`margin: [<length>|<percentage>|auto]{1,4}`\n\n这句话的意思就是，margin 这个属性的值，可以是 length（长度），或者 percentage（百分数），或者关键词 auto，而这个值可以写 1-4 个。因为一个元素的外边距（margin）有上下左右四个，所以可以写 1-4 个值，而值的类型当然可以是绝对长度，或者相对长度或者自动设置（auto）。\nOK，那么我们来学一下这句话是怎么写的，也就是规则是什么。\n\n<p style=\"display: inline; font-family: Consolas; background-color: #eee; padding:3px 10px; border-radius: 3px; color: gray;\">margin: <span style=\"color: rgb(126, 213, 61)\">[<span style=\"color: red\">&lt;length&gt;</span>|<span style=\"color: red\">&lt;percentage&gt;</span>|<span style=\"color: red\">auto</span>]</span><span  style=\"color: blue\">{1,4}</span></p>\n\n1. 红色部分：<span style=\"color: red\">基本元素</span>\n   基本元素有三种：\n   - 关键词：`auto`, `solid`, `bold`...\n   - 类型\n     - 基本类型（`<length>`, `<percentage>`, `<color>`...）\n     - 特殊类型（`<padding-width>`, `<background-color>`...）\n   - 其他：inherit(继承)，initial（默认）\n2. 绿色部分：<span style=\"color: rgb(126, 213, 61)\">组合符号</span>\n   组合符号就是用来表示这些基本元素之间的关系是怎么样的：\n\n   - `|`：分隔两个基本元素，表示**<span style=\"color: orange;\">两者只能出现一个</span>**，比如后面我们会讲到：\n\n   ```\n   display:block|inline|inline-block|none\n   ```\n\n   这一句表示，`display`这个属性的值只能是`block`, `inline`, `inline-block`, `none`中的其中一个。\n\n   - ` `(空格)：表示这两个基本类型**<span style=\"color: orange;\">必须出现</span>**，而且**<span style=\"color: orange;\">必须以相同的排列顺序</span>**出现，随便举个例子，比如：\n\n   ```\n   font:<font-family> <font-size>\n   ```\n\n   表示：font 这个属性的值，一定要由一个**类型为 font-family 的值**和一个**类型为 font-size 的值**以**如上的排列顺序**构成。\n\n   - `||`：表示**<span style=\"color: orange;\">前后两个元素至少出现一个</span>**，对顺序不作要求。\n\n   - `&&`：表示**<span style=\"color: orange;\">前后两个元素必须出现</span>**，对顺序不做要求。\n\n   - `[]`：表示一个优先级，也就是方括号中的整个看做一个整体，随便举个例子：\n\n   ```\n   font-weight:[bold|thin] [<percentage>|<lenth>]\n   ```\n\n   表示 font-weight 这个属性一定要有两个值组成，一个是 bold 或 thin，一个是一个百分比值或长度值，且前后顺序要保证。\n\n3. 蓝色部分：<span style=\"color:blue\">数量符号</span>\n   - `{}`:花括号中间写两个值，中间用逗号隔开。表示**<span style=\"color: orange;\">最少出现次数</span>**和**<span style=\"color: orange;\">最多出现次数</span>**。当然，两个值当中其中一个不设置，就表示不作要求。举个例子：\n     `margin: [<length>|<percentage>]{1,4}`\n     其中的`{1,4}`就表示，中括号中的值要出现最少一次，最多四次。\n   - `?`:表示出现 0 次或 1 次。相当于`{0, 1}`\n   - `*`:表示出现 0 次或多次。相当于`{0, }`\n   - `+`:表示出现 1 次或多次。相当于`{1, }`\n   - `#`:表示出现 1 次或多次。**<span style=\"color: red\">注意：</span>**`#`和`+`很像，但是唯一不同的是，当用`#`表示时，这个元素多次出现需要用逗号隔开。\n     对比一下，符合`bold smaller#`这一条规则的取值有：\n     - <span style=\"font-family: consolas;\">bold smaller</span>\n     - <span style=\"font-family: consolas;\">bold smaller, smaller</span>\n     - <span style=\"font-family: consolas;\">bold smaller, smaller, smaller</span>\n       而符合`bold smaller+`这一条规则的取值有：\n     - <span style=\"font-family: consolas;\">bold smaller</span>\n     - <span style=\"font-family: consolas;\">bold smaller smaller</span>\n     - <span style=\"font-family: consolas;\">bold smaller smaller smaller</span>\n   - 无：说明该元素**<span style=\"color: orange;\">只出现一次</span>**。\n\nOK，在学习之后做个简单的练习，有个属性叫 text-shadow。它可以写 none，也可以写一个或多个用逗号隔开的，由 2 个或 3 个长度类型的值以及 0 或 1 个颜色类型的值构成的组合。答案在下方，我写成白色了，当然不是唯一的答案：\n答案：<span style=\"font-family: consolas; color: white;\">text-shadow:none|[&lt;length&gt;{2,3}&&&lt;color&gt;?]#</span>\n\n---\n\n#### **@规则语法**\n\n我在这儿不再赘述，这些内容在后面会再出现。\n@media：用来做响应式的布局，只有设备符合@media 媒体查询条件样式才能生效\n@keyframes：描述 css 动画的中间步骤\n@font-face：引入外部字体\n","tags":["FrontEnd","Course Notes","CSS"]},{"title":"HTML@7补充篇","url":"/blog/2016/08/13/2016-08-13 HTML@7结尾篇/","content":"\n### 回顾\n\n之前的知识点包括了：\n\n-   文档头部包含的四种最重要的标签（`<title>`, `<meta>`, `<link>`, `<style>`）\n-   标签的最常用的四种属性（id, class, style, title）\n-   章节标签（`<body>`, `<header>`, `<footer>`, `<nav>`, `<aside>`, `<article>`, `<h1>-<h6>`）\n-   文本标签（`<a>`, `<em>`, `<stong>`, `<span>`, `<br>`, `<cite>`, `<q>`, `<code>`, `<b>`, `<i>`)\n-   组合内容标签（`<div>`, `<p>`, `<ui> <ol> <dl>`, `<pre>`, `<blockquote>`）\n-   嵌入资源标签（`<img>`, `<iframe>`, `<object>`, `<embed>`, `<video>`, `<audio>`, `<canvas>`, `<svg>`, `<map>`, `<area>`）\n-   表格标签\n-   表单标签（`<form>`, `<fieldset>`, `<legend>`, `<input>`, `<select>`, `<textarea>`, `<button>`, `<label>`）\n\n以上就是我们讲的关于 HMTL 的基础知识，今天这一篇笔记，主要讲四个内容：\n\n-   什么叫“语义化”\n-   HTML 实体字符\n-   HTML5 的新特性\n-   作为练习的题目\n\n### 语义化\n\n事实上，语义化很简单，就是用对应标签干对应的事。\n比如，要展示一段文字，你就用`<p>`标签，`<p>`标签专门是用来容纳文字内容的，没有特殊情况，不要用`<div>`或者其他标签来展示。\n为什么要语义化呢？原因大概有两点：\n\n-   SEO(search engine optimization)搜索引擎优化（html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析），搜索引擎会对语义化的页面给予一个更高的权重因为搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重。\n-   代码的可读性，这一点不言而喻。利于维护等等。\n\n### HTML 实体字符\n\n有时候，我们要展示如下信息：<span style=\"color: red\">这是个&lt;span&gt;标签</span>。然而当我们这么写代码的时候：\n`<p>这是个<span>标签</p>`\n出来的效果会是：这是个标签\n因为 HTML 没法把尖括号解析成文字内容，尖括号是它用来表示标签的标志，同样的，这样的符号还有一大堆，解决方案就是用另外一种方式来表示这类字符，比如用实体字符`&quot;`或者实体编号`&#34;`来表示双引号（单个）。\n当然，你可以参考这个[HTML ISO-8859-1 参考手册](http://www.w3school.com.cn/tags/html_ref_entities.html)。\n我列出一部分常用的：\n\n| 字符   | 实体字符   | 实体编号   |\n| ------ | ---------- | ---------- |\n| &quot; | &amp;quot; | &amp;#34;  |\n| &amp;  | &amp;amp;  | &amp;#38;  |\n| &lt;   | &amp;lt;   | &amp;#60;  |\n| &gt;   | &amp;gt;   | &amp;#62;  |\n| 空格   | &amp;nbsp; | &amp;#160; |\n| ©      | &amp;copy; | &amp;#169; |\n\n### HTML5 的新特性\n\n这个是面试中常常被问到的问题，我也从网上扒了一点资料，在这边列举一遍。\n\n-   新的文档类型`<!DOCTYPE html>`\n    关于这一点我在前面的笔记中已经提到过，在 HTML5 中，放弃了以前复杂的文档类型声明，而改用现在简单的`<!DOCTYPE html>`的形式。在 HTML5 之前需要写这么一大段：\n\n```xml\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n```\n\n-   脚本和链接无需 type\n    曾经，我们在引入 CSS 或 JS 文件时，需要用 type 属性来区分我们引入的文件类型，比如：\n\n```xml\n<link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" type=\"text/css\" />\n<script type=\"text/javascript\" src=\"path/to/script.js\"> </script>\n```\n\n    在HTML5中取消了这一点，不需要再加type属性，当然也没禁止你加。\n\n-   语义 Header 和 Footer\n    在 HTML5 之前，我们需要这样来声明 header 和 footer：\n\n```xml\n<div id=\"header\"></div>\n<div id=\"footer\"></div>\n```\n\n    在HTML5中，新增了两种标签用来代替它们，HTML中篇中我也提到过，就是`<header>`标签和`<footer>`标签。\n\n-   Hgroup\n    我们知道，我们可以用 h1-h6 六种不同的标签来表示不同的标题，`<hgroup>`标签则是用来对这些标题进行分组的。\n\n```xml\n<hgroup>\n\t<h1>Welcome to my WWF</h1>\n\t<h2>For a living planet</h2>\n</hgroup>\n<p>The rest of the content...</p>\n```\n\n-   标记元素\n    `<mark>`标签，实际上就是一个高亮文本标签，你可以这么用：\n\n```xml\n<h3>Search Results </h3>\n<p>They were interrupted, just after Quato said, <mark>\"Open your Mind\"</mark>. </p>\n```\n\n    mark标签内的内容会变成高亮文本：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-18/82166206.jpg)\n\n-   图形元素 figure/figcaption\n    `<firgure>`标签事实上在功能上没有实质性作用，它的作用在于使代码更语义化，比如，插入一幅图像以及它的标题，假如不采用`<firgure>`标签，可能会这么写：\n\n```xml\n<p>黄浦江上的的卢浦大桥</p>\n<img src=\"shanghai_lupu_bridge.jpg\" width=\"350\" height=\"234\" />\n```\n\n    此刻，标题和图像在语义上是没有任何联系的，在HTML5中，你可以这么写：\n    ​```xml\n    <figure>\n    \t<figcaption>黄浦江上的的卢浦大桥</figcaption>\n    \t<img src=\"shanghai_lupu_bridge.jpg\" width=\"350\" height=\"234\" />\n    </figure>\n    ​```\n\n-   重新定义`<small>`元素\n    `<small>` 标签呈现小号字体效果。但是如果`<small>` 标签所包含的文字已到达字体模型能支持的最小号模型，那么`<small>` 标签将不起任何作用。`<small>` 标签常常用来用做页面底部版权声明。\n\n-   `placeholder`占位符\n    这个在`<input>`标签中提到过，用来实现占位符。在 HTML5 之前，要实现`placeholder`的功能，需要用 JavaScript 代码。但是 HTML5 中，新增的`placeholder`属性可以方便的实现占位符功能。\n\n-   `required`属性\n    `required`属性也是`<input>`标签在 HTML5 中新增的元素，表示这个元素一定要填写或选择。\n\n-   `autofocus`属性\n    自动焦聚属性，也就是你打开这个网页时，焦点会自动跳转到这个`<input>`标签。\n\n-   audio 支持\n    HTML 新增了`<audio>`标签来渲染音频。\n\n-   video 支持\n    HTML 新增了`<video>`标签来渲染视频。\n\n-   视频预载 preload 属性\n    如果在`<video>`标签中设置了 preload 属性，在视频播放前就会预加载。\n\n-   显示控制条 controls 属性\n    如果光是`<video>`标签的话，就光是会在页面上加载一张图片，如果要显示控制条，则应该设置 controls 属性。\n\n-   正则表达式\n    有时候，你会需要 input 输入框中填写某种特殊格式的字符串，这个时候就需要用到正则表达式。而 HTML5 新增了 pattern 属性，可以在 pattern 属性中写入一个正则表达式，如果输入不符合这个正则表达式，则会出现提示。比如，你要求输入完全由大小写字母构成的字符串，可以这么写：\n\n```xml\n<form action=\"\" method=\"post\">\n\t<label for=\"username\">Create a Username: </label>\n\t<input type=\"text\" placeholder=\"a-z or A-Z Only\" pattern=\"[A-Za-z]*\" autofocus required>\n\t<button type=\"submit\">Go</button>\n</form>\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-18/33602309.jpg)\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@6表单标签","url":"/blog/2016/08/09/2016-08-09 HTML@6表单标签/","content":"\n## 常用标签\n\n### 表单标签\n\n表单标签是 HTML 中非常重要的标签，可以用来上传信息而且在 HTML5 中有扩展了很多 input 类型的表单标签，是和用户进行信息交互的重要媒介。但是表单标签家族人员众多，如果要讲完，还是挺费劲的，所以我也只是简述而已。\n\n#### `form`**标签**\n\n一般来说，会把`<form>`标签放在表单的最外面，因为一般而言，表单数据都会发送给后台，让后台进行处理，那么就需要定义，后台的地址是什么，用什么方式传给后台（POST or GET?）等等。总而言之，如果把表单看成一封信，那么 form 标签就是它的信封，标注着收件地址，怎么寄送等等。挂出 W3School 的详细信息：[HTML form 标签](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n```xml\n<form action=\"/login\" method=\"post\">\n<!--action: 后台地址， method: 提交方式-->\n<!-- 这里面就放入表单 -->\n</form>\n```\n\naction 属性表示的是后台地址，method 就是传输方式（POST or GET）。具体想知道 POST 和 GET 传给后台之间有什么区别，以后我也会详细推出一篇笔记来阐述两者区别，现在暂时先看别人的日志：\n[W3School：HTTP 方法：GET 对比 POST](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)\n[hyddd：浅谈 HTTP 中 Get 与 Post 的区别](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)\n[gideal_wang：HTTP POST GET 本质区别详解](http://blog.csdn.net/gideal_wang/article/details/4316691)\n\n#### `fieldset`**标签**\n\n这个标签是用来划分表单的，将不同表单进行分组，比如填写个人基本信息的相关表单放在一个`<fieldset>`标签，填写个人教育经历的放在另一个。这个没什么好讲的……\n\n#### `legend`**标签**\n\n通常被用来配合`<fieldset>`标签使用，是用来表示一个 filedset 的标题信息的。\n\n#### `input`**标签**\n\ninput 标签千变万化，可以用来作为输入框，按钮，单选框等等等等，这都和它的**type**属性息息相关，不同的 type 就能变幻出不同的形态，当然我还是贴出这个标签的权威解答：[HTML input 标签](http://www.w3school.com.cn/tags/tag_input.asp)。\n\n-   **type 属性：** 变换不同形态\n    type 属性有以下这些值，当然，你如果想有更多的体验，可以访问 →[HTML input 标签的 type 属性](http://www.w3school.com.cn/tags/att_input_type.asp)，自己写代码试试看：\n\n    -   text：普通的单行输入框\n\n    ```xml\n    <input type=\"text\" placeholder=\"在此处输入试试\">\n    ```\n\n    -   效果：<input type=\"text\" placeholder=\"在此处输入试试\">\n\n    *   password：密码输入框\n\n    ```xml\n    <input type=\"password\" placeholder=\"在此处输入密码\">\n    ```\n\n    -   效果：<input type=\"password\" placeholder=\"在此处输入密码\">\n\n    *   radio：单选框\n\n    ```xml\n    <input type=\"radio\" name=\"sex\" value=\"male\"/>男\n    <input type=\"radio\" name=\"sex\" value=\"female\"/>女\n    ```\n\n    -   效果：<input type=\"radio\" name=\"sex\" value=\"male\"/>男 <input type=\"radio\" name=\"sex\" value=\"female\"/>女\n\n    *   checkbox：多选框\n\n    ```xml\n    <input type=\"checkbox\">选项一\n    <input type=\"checkbox\">选项二\n    <input type=\"checkbox\">选项三\n    ```\n\n    -   效果：<input type=\"checkbox\">选项一 <input type=\"checkbox\">选项二 <input type=\"checkbox\">选项三\n\n    *   file：文件上传\n\n    ```xml\n    <input type=\"file\">\n    ```\n\n    -   效果：<input type=\"file\">\n\n    *   hidden： 隐藏某个 input 标签\n        隐藏字段对于用户是不可见的。隐藏字段通常会存储一个默认值，它们的值也可以由 JavaScript 进行修改。\n    *   button：没有任何反应的按钮\n\n    ```xml\n    <input type=\"button\">\n    ```\n\n    -   效果：<input type=\"button\">\n\n    *   submit：提交按钮，是用来提交整个表单的数据\n\n    ```xml\n    <input type=\"submit\">\n    ```\n\n    -   效果：<input type=\"submit\">\n\n    *   image：定义图像形式的提交按钮。\n\n    ```xml\n    <input type=\"image\" src=\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-13/76798647.jpg\">\n    ```\n\n    -   效果：<input type=\"image\" src=\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-13/76798647.jpg\">\n\n    *   reset：重置按钮，重置表单所有数据\n\n    ```xml\n    <form>\n    \t<input type=\"text\" placeholder=\"在此处输入试试\">\n    \t<input type=\"password\" placeholder=\"在此处输入密码\">\n    \t<input type=\"checkbox\">选项一\n    \t<input type=\"checkbox\">选项二\n    \t<input type=\"checkbox\">选项三\n    \t<input type=\"reset\">\n    </form>\n    ```\n\n    -   效果：（可以先输入信息，点击 reset 之后清除）\n    <form>\n    \t<input type=\"text\" placeholder=\"在此处输入试试\">\n    \t<input type=\"password\" placeholder=\"在此处输入密码\">\n    \t<input type=\"checkbox\">选项一<input type=\"checkbox\">选项二<input type=\"checkbox\">选项三\n    \t<input type=\"reset\">\n    </form>\n\n-   **name 属性：** input 元素的名称\n    提交表单时对表单数据进行标识，因为你把数据提交到后台后，肯定要对每个表单数据都有一个标记，也就是他们的名字，这也就是 name 属性的意义。\n\n-   **value 属性：** input 元素的值\n    当然，你经常有需要会让某些 input 元素有一些预设值，或者让某些 input 元素有值能提交，比如：\n\n```xml\n<input type=\"radio\" name=\"sex\" value=\"male\"/>男\n<input type=\"radio\" name=\"sex\" value=\"female\"/>女\n```\n\n-   **placeholder 属性：** 输入框的提示信息\n    规定帮助用户填写输入字段的提示。当然非输入字段是没用的……\n\n```xml\n<input type=\"text\" placeholder=\"在此处输入试试\">\n```\n\n    - 效果：<input type=\"text\" placeholder=\"在此处输入试试\">\n\n-   **checked 属性：** 使带有这个属性的 input 标签默认处于选中状态\n\n```xml\n<input type=\"radio\" name=\"sex\" value=\"male\"/>男\n<input type=\"radio\" name=\"sex\" value=\"female\" checked/>女\n```\n\n    - 效果：\n\n<form>\n\t<input type=\"radio\" name=\"sex\" value=\"male\"/>男\n\t<input type=\"radio\" name=\"sex\" value=\"female\" checked/>女\n</form>\n\n-   **disabled 属性：** 禁用该标签\n    **<span style=\"color:red\">提示：</span>**disabled 属性不能和 type=\"hidden\"一起使用。\n\n```xml\n<input type=\"radio\" name=\"sex\" value=\"male\"/>男\n<input type=\"radio\" name=\"sex\" value=\"female\" checked disabled/>女\n```\n\n    - 效果：\n\n<form>\n\t<input type=\"radio\" name=\"sex\" value=\"male\"/>男\n\t<input type=\"radio\" name=\"sex\" value=\"female\" checked disabled/>女\n</form>\n\n-   其他还有很多有用的属性：**autofocus**，**readonly**，**multiple**，**required**等等……可以访问[HTML input 标签](http://www.w3school.com.cn/tags/tag_input.asp)。\n\n#### `select`**标签**\n\n同样先贴上 W3School 的链接：[HTML select 标签](http://www.w3school.com.cn/tags/tag_select.asp)\n下拉菜单，有几个需要配合 select 一起使用的标签：\n\n-   option：也就是菜单选项\n-   optgroup：可以对 option 选项进行分组\n\n```xml\n<select id=\"delivery\">\n\t<optgroup>\n\t\t<option value=\"0\">快递</option>\n\t\t<option value=\"1\">EMS</option>\n\t</optgroup>\n\t<option value=\"2\" selected>平邮</option>\n</select>\n```\n\n效果：<select id=\"delivery\">\n\n<optgroup>\n<option value=\"0\">快递</option>\n<option value=\"1\">EMS</option>\n</optgroup>\n<option value=\"2\" selected>平邮</option>\n</select>\n\n#### `textarea`**标签**\n\ntextarea 就是多行的文本输入控件。贴上链接：[HTML textarea 标签](http://www.w3school.com.cn/tags/tag_textarea.asp)\n\n```xml\n<textarea rows=\"3\" cols=\"20\">\n\t在w3school，你可以找到你所需要的所有的网站建设教程。\n</textarea>\n```\n\n<textarea rows=\"3\" cols=\"20\">在 w3school，你可以找到你所需要的所有的网站建设教程。</textarea>\ntextarea 有几个较为重要的属性，简单讲解：\n\n-   rows：文本输入框可见的行数\n-   cols：文本输入框可见的列数\n-   其他还有：autofocus，readonly，disabled，placeholder，required 等等\n\n#### `button`**标签**\n\nbutton 标签就是按钮标签，[HTML button 标签](http://www.w3school.com.cn/tags/tag_button.asp)。\n\n```xml\n<button onclick=\"alert('hello!')\">click here!</button>\n```\n\n效果：<button onclick=\"alert('hello!')\">click here!</button>\n这个 button 标签比`<input type=\"button\">`提供了更为强大的功能和更丰富的内容。\n\n#### `label`**标签**\n\n`<label>`标签为 input 元素定义标注（标记）。可以用 label 的 for 属性绑定另外一个元素，只要 label 的 for 属性的值和另外一个元素的 id 相同，此时如果你点击 label 标签的文本，就会自动触发那个绑定的控件，就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。可以将以下代码复制到`<body>`标签下进行测试。\n\n```xml\n<form>\n  <label for=\"male\">Male</label>\n  <input type=\"radio\" name=\"sex\" id=\"male\" />\n  <br />\n  <label for=\"female\">Female</label>\n  <input type=\"radio\" name=\"sex\" id=\"female\" />\n</form>\n```\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@5表格标签","url":"/blog/2016/08/08/2016-08-08 HTML@5表格标签/","content":"\n## 常用标签\n\n### 表格标签\n\n表格标签最重要的这几个标签都基本包含在这个代码中，\n\n```xml\n<table border=\"1px\">\n<caption>表格标题</caption>\n\t<thead>\n\t  <tr><th>列标题1</th><th>列标题2</th></tr>\n\t</thead>\n\t<tbody>\n\t\t<tr><th>行1列1</th><td>行1列2</td></tr>\n\t\t<tr><th>行2列1</th><td>行2列2</td></tr>\n\t</tbody>\n\t<tfoot>\n\t\t<tr><td colspan=\"2\">……</td></tr>\n\t\t<!--colspan可以用来合并列，rowspan可以用来合并行-->\n\t</tfoot>\n</table>\n```\n\n效果大概是：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-12/59167503.jpg)\n可以看到：\n\n-   `<table>`标签包裹在最外层，表示这是一个表格。它有一些必要的属性，比如控制边框粗细，边框和内容之间的空白宽度等，具体见：[HTML table 标签](http://www.w3school.com.cn/tags/tag_table.asp)。\n-   `<caption>`，这是一个表格的标题\n-   `<thead>`表示的是表格的标题栏，具体见：[HTML thead 标签](http://www.w3school.com.cn/tags/tag_thead.asp)。\n-   `<tbody>`表示的是表格的主题部分，具体见：[HTML tbody 标签](http://www.w3school.com.cn/tags/tag_tbody.asp)。\n-   `<tr>`表示一行，table row 的意思，具体见：[HTML tr 标签](http://www.w3school.com.cn/tags/tag_tr.asp)。\n-   `<th>`表示一个单元格，而且这个单元格是一个表头，带有加粗的效果，具体见：[HTML th 标签](http://www.w3school.com.cn/tags/tag_th.asp)。\n-   `<td>`表示一个普通单元格，它也具有一些属性，比较重要的有`colspan`/`rowspan`属性（其实`<th>`也有这个属性），这个属性的值，表示这个单元格占几格，比如上面这个 Example 中，最底下的单元格就占了两列。其他属性可见：[HTML td 标签](http://www.w3school.com.cn/tags/tag_td.asp)。\n-   `<tfoot>`表示表格的页脚（脚注或者标记）。特别需要注意的是，<span style=\"color:orange\">thead, tbody, tfoot 需要一起配合使用，一旦用了其中一个，其他两个也要一起使用</span>，其属性也和其他两者类似，可以参考：[HTML tfoot 标签](http://www.w3school.com.cn/tags/tag_tfoot.asp)\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@4嵌入资源标签","url":"/blog/2016/08/07/2016-08-07 HTML@4嵌入资源标签/","content":"\n## 常用标签\n\n### 嵌入资源标签\n\n#### 图片 `img`\n\n<span style=\"color:orange\">提示：</span>img 是没有闭合标签的，也就是没有`</img>`。\nimg 标签有很多属性，简单介绍几个，具体可以去 W3School[【HTML img 标签】](http://www.w3school.com.cn/tags/tag_img.asp)\n\n-   **src 属性**：\n    **绝对地址**指的就是这张图片的地址，可以直接将这个地址复制到浏览器中打开这张图。\n    **相对地址**指的是，这张图相对于这个 HTML 文档的地址。\n    比如文档结构是这样的：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/1101943.jpg)\n    在\"blog - 副本\"文件夹下，有 img 文件夹和一个 index.html 文件，index.html 文件需要访问到 img 文件夹中的 icon.png 文件时，应该写`<img src=\"img/icon.png\">`\n    又假如，你需要访问到上级文件夹，此时文件结构是这样的：\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/56139804.jpg)\n    你需要在 index.html 中访问 icon.png 文件，则要写成这样`<img src=\"../icon.png\">`，要访问上级的上级的文档则需要写`src=\"../../\"`，以此类推。\n\n-   **alt 属性**：如果 src 中的图片无法显示，alt 就会替代该图片显示。\n\n```xml\n<img src=\"http://jackie-anxis.com/img/avatar.png\" alt=\"封面\">\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/81792570.jpg)\n\n-   **width&height 属性**：用来规定图片大小。可以有两种单位，%和 px（像素）。\n    %也就是相对父元素的大小。px 就是像素，也就是绝对大小。\n\n```xml\n<div style=\"background-color:orange; width: 300px; height: 300px;\">\n\t<img src=\"../icon.png\" width=\"50%\">\n</div>\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/14035412.jpg)\n显然这个 50%指的是父元素的 50%。\n\n#### 页面 `iframe`\n\n也就是在页面中嵌入另一个页面，假如说我在 google 的搜索页`<body>`中添加一段\n\n```xml\n<iframe src=\"www.google.com\"></iframe>\n```\n\n就能嵌入一个页面。\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/30399709.jpg)\n当然这是 iframe 标签最基础的功能，iframe 标签还可以用来做很多强大的事。而且它还有很多属性，可以访问[【HTML iframe 标签】](http://www.w3school.com.cn/tags/tag_iframe.asp)和[【深入理解 iframe】](http://www.cnblogs.com/fangjins/archive/2012/08/19/2645631.html)（后面一篇可能需要有点 JS 基础）。\n\n#### 插件 `object` `embed` `video` `audio` `canvas` `svg` `map` area\n\n这些都是用来嵌入一些插件的，但有些比较有难度，我只讲一些比较简单的，其他的，我会给出链接，你们可以参考别人的博客来帮助学习，我的观点是：这些标签你只要懂的它们的作用即可，而具体如何使用可以查看资料。\n**`<object>`标签**\nobject 标签可以用来嵌入一些插件（除了图片以外的多媒体），比如 Flash,Java Applets,MP3,QuickTime Movies 等。基本上主流浏览器都支持 object 标签的实现，故而 object 可以完全代替标准不赞成使用的 applet,embed,bgsound 标签。大概写法如下：\n\n```xml\n<object type=\"application/x-shockwave-flash\">\n<param name=\"movie\" value=\"http://pdfReader.swf\">\n<!--播放器地址可以写进value中-->\n    <param name=\"flashvars\" value=\"http://book.pdf\">\n</object>\n```\n\n其中，当 object 元素没有显示的时候，`<object></object>`之间的代码就会被执行。具体我也不再赘述，可以参考[HTML object 标签(梦之园)](http://www.dreamdu.com/xhtml/tag_object/)，[HTML object 标签(大肥子猪)](http://www.dreamdu.com/xhtml/tag_object/)\n\n**`<embed>`标签**\n这个标签和 object 功能类似，但是`<embed>`标签是 HMTL5 推出的新特性。同样不支持嵌入图片媒体，不赞成使用这个标签，因为它有很多毛病，也不符合网页设计理念，对旧的浏览器也不支持。\n\n**`<video>`标签**\n用来加载视频资源，也是 HTML5 新支持的标签，和`<img>`标签类似，可以非常便捷的引入资源。\n写法大概是：\n\n```xml\n<video src=\"media/butterfly.mp4\" controls>\n\t您的浏览器不支持 video 标签。\n</video>\n```\n\nsrc 是视频的路径，controls 表示显示视频播放控件，默认是不显示的。标签之间的文字会出现在不支持 video 标签的浏览器中，作为后备内容出现，用来兼容不支持 video 标签的浏览器。具体属性可以查看[HTML video 标签](http://www.w3school.com.cn/tags/tag_video.asp)\n\n**`<audio>`标签**\n基本和 video 属性一致，不再赘述。要了解详细信息可以看：[HTML audio 标签](http://www.w3school.com.cn/tags/tag_audio.asp)\n\n**`<canvas>`标签**\n可以用嵌入的脚本来绘制图形，后面讲 JS 的时候会提到，然后这里就简单贴一段代码，可以看看它是怎么工作的。\n\n```xml\n<canvas id=\"myCanvas\">\n\tyour browser does not support the canvas tag\n</canvas>\n<script type=\"text/javascript\">\n\tvar canvas=document.getElementById('myCanvas');//找到canvas标签\n\tvar ctx=canvas.getContext('2d');//制定绘图模式是2d\n\tctx.fillStyle='#FF0000';//填充颜色\n\tctx.fillRect(0,0,80,100);//绘制长方形，参数是左上角和右下角的坐标\n</script>\n```\n\n结果如下：\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/93723471.jpg)\n详情：[HTML canvas 标签](http://www.w3school.com.cn/tags/tag_canvas.asp)\n\n**`<map>`和`<area>`标签**\n这两个标签要配合使用，area 标签永远嵌套在 map 标签中，可以用来映射图像区域。\n\n```xml\n<img src=\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/88534460.jpg\" border=\"0\" usemap=\"#planetmap\" alt=\"Planets\" />\n<map name=\"planetmap\" id=\"planetmap\">\n\t<area shape=\"rect\" coords=\"0,0,123,62\" href=\"https://www.baidu.com\" target =\"_blank\" alt=\"Mercury\" />\n\t<area shape=\"circle\" coords=\"166,38,30\" href =\"https://www.google.com\" target =\"_blank\" alt=\"Sun\" />\n</map>\n```\n\n效果可以直接点击试试看：\n<img src=\"https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-10/88534460.jpg\" border=\"0\" usemap=\"#planetmap\" alt=\"Planets\" />\n<map name=\"planetmap\" id=\"planetmap\">\n<area shape=\"rect\" coords=\"0,0,123,62\" href=\"https://www.baidu.com\" target =\"_blank\" alt=\"Mercury\" />\n<area shape=\"circle\" coords=\"166,38,30\" href =\"https://www.google.com\" target =\"_blank\" alt=\"Sun\" />\n</map>\n\n具体参考：[HTML map 标签](http://www.w3school.com.cn/tags/tag_map.asp)\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@3组合内容标签","url":"/blog/2016/08/06/2016-08-06 HTML@3组合内容标签/","content":"\n## 常用标签\n\n### 组合内容标签\n\n#### 区块 `div`\n\n这也将是 HTML 文档中最常见的标签，是一个区块，可以用来盛放其他标签。\n\n#### 段落 `p`\n\n用来容纳段落和文字。\n\n#### 列表 `ul` `ol` `dl`\n\n-   `<ul>`标签：无序列表(默认样式是不带序号的)\n\n```xml\n<ul>\n    <li>列表项1</li>\n\t<li>列表项2</li>\n</ul>\n```\n\n效果：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/3495335.jpg)\n\n-   `<ol>`标签：有序列表(默认是带有数字序号的,控制`type=\"a\" start=\"2\"`就会从 b 开始排序)\n\n```xml\n<ol type=\"a\" start=\"2\">\n\t<li>列表项1</li>\n\t<li>列表项2</li>\n</ol>\n```\n\n效果：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/8684718.jpg)\n\n-   `<dl>`标签：自定义列表(如：问答列表，术语定义列表)\n\n```xml\n<dl>\n\t<dt>列表标题1</dt>\n\t<dd>列表标题1下的内容1</dd>\n\t<dd>列表标题1下的内容2</dd>\n\t<dt>列表标题2</dt>\n\t<dd>列表标题2下的内容</dd>\n</dl>\n```\n\n效果：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/12583532.jpg)\n\n#### 格式 `pre`\n\n首先需要提到一个问题，就是在 HTML 一般的标签中，都是默认会自动删除换行符，将多个空格合并成一个，将行缩进（tab）替换成空格。所以有时候就会有保留原格式的需求，在 pre 标签中，就不会有以上的问题。\n\n```xml\n<p>\n\thello!\n\tevery        one!\n</p>\n<pre>\n\thello!\n\tevery        one!\n</pre>\n```\n\n效果：![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/713675.jpg)\n\n#### 块级引用 blockquote\n\n其实和 p,段落标签也没什么区别，只是引用段落的时候比较常用罢了。\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@2章节标签&文本标签","url":"/blog/2016/08/05/2016-08-05 HTML@2章节标签&文本标签/","content":"\n## 常用标签\n\n### 章节标签\n\n-   `<body>`标签：是整个文档的容器，文档章节内容相关的标签都会包含在 body 中\n-   `<header>`标签：页面头部标签，可以参见下图\n-   `<footer>`标签：页面底部标签，可以参见下图\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/6142987.jpg)\n-   `<nav>`标签：导航，可以参考下图\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/1596405.jpg)\n-   `<aside>`标签：和主要内容不相关的区域插入的广告，一些工具性的内容\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/32408003.jpg)\n-   `<article>`标签：独立的可重复的结构，论坛的帖子文章等等\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/59101603.jpg)\n-   `<section>`标签：表示文档中的一节，一般来说 section 会带一个标题\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/1803994.jpg)\n-   h1-h6 标签：标题标签，从 1-6 依次变小\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/34667391.jpg)\n\n### 文本标签\n\n#### 超链接标签 `a`\n\n超链接标签有很多用途，最常用的有三种，详情可以点击[【HTML a 标签】](http://www.w3school.com.cn/tags/tag_a.asp)：\n\n**用途一**：创建指向另一个文档的连接\n\n```xml\n<a href=\"http://jackie-anxis.com/\" target=\"_self\">叫Jackie的咸鱼</a>\n```\n\nhref 是目标地址，target 是跳转方式，默认是\\_self(在本页面显示), \\_blank(在新的窗口显示), 或者是一个名称(会在对应名称的 iframe 标签下显示)，比如这样：\n\n```xml\n<a href=\"http://jackie-anxis.com/\" target=\"123\">Jackie</a>\n<iframe src=\"\" name=\"123\" style=\"display:block; width:500px\"></iframe>\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/27379656.jpg)\n\n**用途二**：创建一个文档内部的锚点(跳转到页面中的其他地方)\n\n```xml\n<a href=\"#bottom\" style=\"display: block;\">Jackie</a>\n<iframe id=\"bottom\" src=\"www.jackie-anxis.com\" style=\"margin: 400px 0\"></iframe>\n```\n\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/33613196.jpg)\n(这样点击之后，会跳转到 id=\"bottom\"这个地方) 地址栏会多一个#bottom\n\n**用途三**：链接到 Email 地址/电话号码，会直接打开邮箱的客户端\n\n```xml\n发送邮件：<a href=\"mailto:yixinplus@188.com\">联系我们</a>\n拨打电话：<a href=\"tel:1321321321\">31243234</a>\n还可以直接写上主题和抄送：\n<a href=\"mailto:xx@xx.com?cc=yy@yy.com&subject=建议&body=body...\">联系我们(抄送)</a>\n```\n\n#### 强调标签 `em` `strong`\n\n`<em>`标签和`<strong>`标签都可以表示强调，但不同的是：\n`<em>`标签表示**斜体**\n`<strong>`标签表示**粗体**\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/77322384.jpg)\n\n#### 行内容器 `span`\n\n事实上，它就是一个非常普普通通的标签，默认是不换行的，可以用来组合行内元素，比如：\n`提示：请使用 <span> 来组合行内元素，以便通过样式来格式化它们。`\n假如你需要把提示两个字变成红色，那么可以写成这样：\n\n```xml\n<p><span style=\"color:red\">提示：</span>请使用 span 来组合行内元素，以便通过样式来格式化它们</p>\n```\n\n最终效果就会是：\n\n<p><span style=\"color:red\">提示：</span>请使用 span 来组合行内元素，以便通过样式来格式化它们</p>\n\n#### 换行 `br`\n\n就是换行\n\n#### 引用 `cite` `q`\n\n**用途一**：cite 用来表示一个引用的出处，比如作品名称或人物\n\n```xml\n<p>决心不过是记忆的奴隶它会根据你的记忆随意更改——<cite>《哈姆雷特》</cite></p>\n```\n\n效果：\n\n<p>决心不过是记忆的奴隶它会根据你的记忆随意更改——<cite>《哈姆雷特》</cite></p>\n\n**用途二**：q 作品中的一段文字，某人说的话\n\n```xml\n<p>莎士比亚说：<q>我抽烟,喝酒,有纹身,但我知道我是好女孩。</q></p>\n```\n\n效果：\n\n<p>莎士比亚说：<q>我抽烟,喝酒, 有纹身,但我知道我是好女孩。</q></p>\n显然，你可以和明确的看到，cite其实也就是斜体罢了，而q则只是为这句话加上了引号。\n\n#### 代码 `code`\n\n只是说明，如果有代码的话，套在这个标签里面会更优雅。而且，这个标签会自动把你的代码字体改成等宽字体，以暗示：对，你不用怀疑，这是一段代码。后面我们会讲到，这样写符合语义化标准。\n\n#### 强调 `b` `i`\n\n这个和`<em> <strong>`非常像，`<b>`标签表示加粗，`<i>`标签表示斜体，只不过在 HTML5 的标准中，推荐使用`<em> <strong>`。\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"HTML@1文档结构&标签属性","url":"/blog/2016/07/19/2016-07-19 HTML@1文档结构&标签属性/","content":"\n## 推荐相关教程\n\n[w3school 在线教程](http://www.w3school.com.cn/)：全球最大的中文 Web 技术教程。其中包括 W3C 的标准技术:HTML、CSS、XML 。以及其他的技术,诸如 JavaScript、PHP、SQL 等等。\n\n## 举例：如何写一个 HTML 的表单？\n\n以下是我以前写过的一个表单的 DEMO，这就是一个简单的网站的基本构架，可以先看一下，接下去我会详细讲解……\n\n```XML\n<!DOCTYPE html>\n<html>\n  <head>\n  \t<meta charset=\"UTF-8\">\n  </head>\n  <body>\n  \t<form action=\"#\" method=\"post\">\n  \t<table>\n  \t  <tr>\n\t  \t<td>头像&nbsp;&nbsp;</td>\n\t  \t<td><input type=\"file\" name=\"headfile\"></td>\n\t  </tr>\n\t  <tr>\n\t  \t<td>昵称&nbsp;&nbsp;</td>\n\t  \t<td><input type=\"text\" name=\"name\"></td>\n\t  </tr>\n\t  <tr>\n\t    <td>学历&nbsp;&nbsp;</td>\n\t    <td>\n\t\t  <select name=\"diploma\" id=\"diploma\">\n\t\t    <option value=\"0\">大专</option>\n\t\t    <option value=\"1\">本科</option>\n\t\t  </select>\n\t    </td>\n\t  </tr>\n\t  <tr>\n\t  \t<td>性别&nbsp;&nbsp;</td>\n\t  \t<td>\n\t  \t  <input type=\"radio\" name=\"sex\" value=\"0\" checked>\n\t  \t  <label>男&nbsp;&nbsp;</label>\n\t  \t  <input type=\"radio\" name=\"sex\" value=\"1\">\n\t  \t  <label>女</label>\n\t  \t</td>\n\t  </tr>\n\t  <tr>\n\t  \t<td>爱好&nbsp;&nbsp;</td>\n\t  \t<td>\n\t  \t  <input type=\"checkbox\" name=\"hobby\" value=\"0\" checked><label>电影</label>\n\t  \t  <input type=\"checkbox\" name=\"hobby\" value=\"1\"><label>摄影</label>\n\t  \t  <input type=\"checkbox\" name=\"hobby\" value=\"2\"><label>音乐</label>\n\t  \t  <input type=\"checkbox\" name=\"hobby\" value=\"3\" checked><label>阅读</label>\n\t  \t</td>\n\t  </tr>\n\t  <tr>\n\t  \t<td valign=\"top\">签名&nbsp;&nbsp;</td>\n\t  \t<td><textarea name=\"sign\" rows=\"4\" cols=\"30\"></textarea></td>\n\t  </tr>\n\t  <tr>\n\t  \t<td></td>\n\t  \t<td><button type=\"submit\">保存</button></td>\n\t  </tr>\n  \t</table>\n  \t</form>\n  </body>\n </html>\n```\n\n效果：\n![](http://i1.piimg.com/4851/01c75d2bdf4c6788.jpg)\n\n## HTML 文档结构\n\n### `<!DOCTYPE html>`结构声明\n\n这一行是用来声明文档结构的，也就是说，这一行是用来表明，浏览器应该用哪个版本的 HTML 来解析文档，现在 HTML5 推出之后，基本上都声明称`<!DOCTYPE html>`用来支持 HTML5 即可。\n\n### `head`文档头部\n\n#### 页面标题 `title`\n\n声明一个`<title>`标签，可以为一个 HTML 文档提供**标题**，这个标题显示在页面标签上，也是搜索引擎搜索结果中看到的标题。以上面的 DEMO 为例，DEMO 中我未声明`<title>`标签，所以默认的标签栏标题就是文件名：\n![](http://i2.piimg.com/4851/6c1ee08c32420ddb.png)\n在文档头部加入`<title>DEMO 3</title>`标签后\n\n```XML\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>DEMO 3</title>\n</head>\n```\n\n![](http://i2.piimg.com/4851/6b930434c97e829f.png)\n\n#### 元标签 `meta`\n\n`<meta>`标签是用来提供有关页面的元信息（meta-information）的标签，没有结束标签（`</meta>`），详细的`<meta>`标签的用法可见[HTML meta 标签](http://www.w3school.com.cn/tags/tag_meta.asp)，我在此只叙述三种最常用的用途：\n\n-   **字符编码**：`<meta charset=\"utf-8\">` 用来定义文档的字符编码，必须要写在第一行，如果不写这一栏，可能无法支持中文等语言……\n\n-   **搜索引擎**：`<meta name=\"keywords\" content=\"\">`和`<meta name=\"discription\" content=\"\">`，这两者都是提供给搜索引擎的，很明显，`content=\"\"`的双引号中填写内容，keywords 这个标签是用来说明该页面的关键词的，而 discription 则是用来描述该页面的主要内容的\n\n-   **移动端**：`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">`这个就比较复杂了，讲的详细点可以写一篇博文了，这里就简单介绍：\n\n    -   这个主要用来控制移动端窗口的大小，对移动端浏览器才有效果，通过这个标签可以设置移动端浏览器的视窗的宽高\n\n    -   width：这个控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度。\n\n    -   height：和 width 相对应\n\n    -   initial-scale：字面意思，就是初始缩放大小\n\n    -   maximum-scale：允许用户缩放到的最大比例。\n\n    -   minimum-scale：允许用户缩放到的最小比例。\n\n    -   user-scalable：用户是否可以手动缩放\n\n    -   详细内容：[快捷提示：别忘记 Viewport Meta 标签](http://webdesign.tutsplus.com/zh-hans/articles/quick-tip-dont-forget-the-viewport-meta-tag--webdesign-5972)\n\n    -   详细内容：[在移动浏览器中使用 viewport 元标签控制布局](https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag)\n\n#### 链接标签 `link`\n\n`<link>`标签主要用来引入外部资源，最常用的用途就是引入外部 css 样式表和定义页面标签的 ICON 图标。\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-1/22509611.jpg)\n详细内容见[【HTML link 标签 W3School】](http://www.w3school.com.cn/tags/tag_link.asp)\n\n-   **定义 ICON 图标**：`<link rel=\"shortcut icon\" href=\"favicon.ico\">` 属性`rel=\"shortcut icon\"`用来指示这段代码是用来引入 ICON 图标，而 href 则用来写 icon 图标的位置。\n-   **引入外部 CSS 样式**：`<link rel=\"stylesheet\" href=\"../css/style.css\"> ` 属性`rel=\"stylesheet\"`用来指示这段代码是用来引入 CSS 样式资源的，而同样的，href 则是写这个 CSS 文件的地址是\"../css/style.css\"\n\n#### 样式标签 `style`\n\n`<style>`标签之间，可以用来写 CSS 样式代码，比如这样\n\n```html\n<style type=\"text/css\">\n    h1 {\n        color: red;\n    }\n    p {\n        color: blue;\n    }\n</style>\n```\n\n## 标签属性\n\n什么是标签属性呢，可以这么理解，一个标签是一个人，那么 id 属性就是这个人的身份证号，class 属性就可以理解成一个人的民族，style 属性就是一个人长什么样等等等等类似，接下来就来详细了解几个常用的标签属性。具体可以看[【HTML 属性】](http://www.w3school.com.cn/html/html_attributes.asp)。\n\n### `id`属性\n\n`<div id=\"...\"></div>`\n上面提到，id 属性事实上就是一个标签的身份证号，在一个页面下，这个 id 属性的内容一定要保证在这个页面中是唯一的（虽然发生重复也不会报错），但是如果你用 JS 脚本来找到这个元素的时候就会出错，只能找到第一个。\nid 属性是一个标签的标志，所以可以通过 ID 属性来找到唯一的一个标签。\n\n### `class`属性\n\n`<div class=\"...\"></div>`\nclass 属性，则是一个标签的类名。拥有同一个类名的标签不用唯一，可以有很多个，也可以通过 class 属性来获得这些带有同一属性的标签。\n**※id 和 class 的区别**：拥有同一个 id 属性的标签在同一个页面下只能有一个（虽然有多个也不会报错），但是拥有同一个 class 属性的标签可以出现多个。\n\n### `style`属性\n\n`<div style=\"...\"></div>`\nstyle 属性，是一个标签的外表。可以直接在 style 属性中写样式，但是后面我们会提到，在这里面写的样式具有较高的优先级。不推荐 在这里写样式，因为会增加标签长度。\n\n### title 属性\n\n`<div title=\"...\"></div>`\ntitle 属性规定了元素的额外的一些信息，当鼠标移动到元素上方就会显示这些信息。\n![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-8-9/52350225.jpg)\n","tags":["FrontEnd","Course Notes","HTML"]},{"title":"杂谈：react-native的枪林弹雨","url":"/blog/2016/06/04/2016-06-04 react-native的枪林弹雨/","content":"\n## react-native 的枪林弹雨\n\n### 常见问题系列\n\n1. Couldn't get the native call queue:bridge configuration isn't available.This shouldn't be possible.Congratulations.\n   ![](http://i.stack.imgur.com/bj86C.png)\n   我的解决方法：删除工作目录下的 node_modules 文件夹，之后备份你的 js 文件，然后在行命令中重新进行：\n\n   ```bash\n   cd ..\n   react-native init\n   ```\n\n2. Unable to upload some APKs\n   运行\n   ```bash\n   react-native run-android\n   ```\n   可能出现如下错误：\n   ```bash\n   Execution failed for task ':app:installDebug'.\n   com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs\n   ```\n   此时需要确认：\n   1. 如果你是在真机上运行，你的设备要确保连接正确（打开 USB 调试），可以用 adb services 来查看是否有该设备\n   2. 如果你是用模拟器，保证它已经启动了（也可以用 adb services 来查看）\n   3. 可能需要更改你的工作目录/android/build.gradle 中的\n   ```bash\n   com.android.tools.build:gradle:1.3.1\n   ```\n   改成\n   ```bash\n   com.android.tools.build:gradle:1.2.3\n   ```\n   然后再跑\n   ```bash\n   react-native run-android\n   ```\n   参考：[Unable to upload some APKs](http://www.hacksparrow.com/react-native-android-unable-to-upload-some-apks.html)\n3.\n","tags":["Coding"]},{"title":"杂谈：React-Native在win10平台上的部署","url":"/blog/2016/05/09/2016-05-09 React-Native在win10平台上的部署/","content":"\n**特别注意：牢记你的所有文件的路径不要出现中文，不然会出现未知的问题**\n**默认查看本教程的看官们都有过一定开发经验~配置环境变量这些简单的工作就不用教了吧**\n\n### 安装 JDK\n\n这一点就不废话了，一般程序员都应该有 JDK……\n之后将 JDK 的 bin 文件夹的路径加入 PATH 环境变量\n\n### 安装 Android SDK 并下载重要组件：\n\n1. 下载 Android SDK\n   如果你已经安装过 eclipse 集成版本或者 Android Stutio 就默认已经安装了 SDK\n   如果你没装过，需要去下载[android SDK](http://tools.android-studio.org/index.php/sdk)，下载完安装就行了。\n\n2. 配置环境变量\n   将 SDK 的 platform-tools 子目录加入 PATH 环境变量\n   将 ANDROID_HOME 环境变量设置成的 SDK 的目录，比如我的：\n   ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-5-9/98466475.jpg)\n\n3. 打开 Android SDK 下载重要组件：\n   用行命令打开 SDK\n\n    ```bash\n    android sdk\n    ```\n\n    你需要勾选以下组件：\n\n    - Tools/Android SDK Tools(>=24.3.3)\n    - Tools/Android SDK Platform-tools(>=22)\n    - Tools/Android SDK Build-tools(==23.0.1)\n    - Android 6.0 (API 23)/SDK Platform(>=1)\n    - Extras/Android Support Repository(>=29)\n\n    下载之前:如果你没有科学上网工具，可以选择腾讯的[Bugly](http://android-mirror.bugly.qq.com:8080/include/usage.html)来代理下载\n    之后就慢慢等待完成即可~\n\n### 下载安装 node.js\n\n去官网下一个安装（4.1 及以上版本），本教程是不会讲的（哼，自己去看[这篇博客](http://www.cnblogs.com/pigtail/archive/2013/01/08/2850486.html)吧\n\n### 安装 react-native 命令行工具\n\n在这之前，推荐你用淘宝的 npm 镜像来加速后面的过程：\n\n```bash\nnpm config set registry https://registry.npm.taobao.org --global\nnpm config set disturl https://npm.taobao.org/dist --global\n```\n\n安装 react-native 命令行：\n\n```bash\nnpm install -g react-native-cli\n```\n\n等待几分钟后即可完成\n\n### 下载一个模拟器或者使用 Android Studio 自带的安卓模拟器\n\n推荐用 bluestacks(虽然我觉得这个模拟器界面很 low)，因为使用 Android Studio 自带的 AVD 很麻烦，所以我也没用\n\n### 创建并启动 React-Native\n\n特别提示：这之前你可以先准备一部电影:)，因为过程将很漫长 hhhh\n\n1. 创建一个工作的文件夹，如：MyProject，在该文件下使用 shift+右键，找到**在此处打开命令窗口**或者**Git Bash**并打开，输入以下命令：\n\n    ```bash\n    react-native init MyProject\n    ```\n\n    千万要耐心等待几~~分钟~~小时，而且还有很大可能失败……\n\n2. 运行你的 package\n\n    ```bash\n    react-native start\n    ```\n\n    之后会出现\n    ![](https://jackie-image.oss-cn-hangzhou.aliyuncs.com/16-5-9/58757400.jpg)\n    之后需要保持该窗口，不要关闭\n    打开[这个链接](http://localhost:8081/index.android.bundle?platform=android)如果能看到一堆 js 代码，说明已经启动成功（第一次访问的时候需要等待一会）\n\n3. 打开你的安卓模拟器\n\n4. 另外再打开一个 git 或者 cmd，进入到工程目录，运行\n\n    ```bash\n    react-native run-android\n    ```\n\n    第一次跑的时候要下载一个 gradle,会下载很长时间，出现很多白点点，你可以接着看上面没看完的那部电影 hhhh\n\n    如果你看到有各种 failed，可以去[React Native 的常见问题](http://www.jianshu.com/p/13adec293492)以下文章找找原因。\n    最常见的是找不到 device，需要检查你是否打开了虚拟机或者是否连接了真机，可以使用：\n\n    ```bash\n    adb shell\n    ```\n\n5. 在你的模拟器上调试\n   你的模拟器上应该会出现一个 MyProject 的 app，打开之后一般都会出现红屏，不要慌张，因为还没完成。\n   首先找到你的 ip 地址，比如 12.23.34.45\n   需要摇晃设备，或者按 menu 键打开菜单\n   点击 Dev Settings\n   选 Debug server host for device\n   输入 你的 IP 地址:8081，如:12.23.34.45:8081\n   返回之后进行 Reload JS, 大概就能看到完成后的样子了\n\n###最后\n如果你有什么不懂的地方，或者遇到没有解决的问题，欢迎留言咨询~我会及时回复\n","tags":["Coding"]}]